<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>This is xingyu.</title>
  
  <subtitle>要成为光，因为有怕黑的人</subtitle>
  <link href="http://blog.eltaos.top/atom.xml" rel="self"/>
  
  <link href="http://blog.eltaos.top/"/>
  <updated>2023-11-04T05:28:53.538Z</updated>
  <id>http://blog.eltaos.top/</id>
  
  <author>
    <name>Xingyu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>floj-logs</title>
    <link href="http://blog.eltaos.top/2023/floj-logs/"/>
    <id>http://blog.eltaos.top/2023/floj-logs/</id>
    <published>2023-11-04T05:27:10.000Z</published>
    <updated>2023-11-04T05:28:53.538Z</updated>
    
    <content type="html"><![CDATA[<p>可能是非官方的 floj 更新日志。</p><hr><h1>2023.11.4前</h1><p>配置好基本功能。网站基本可以运作。外网暂不能访问。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;可能是非官方的 floj 更新日志。&lt;/p&gt;
&lt;hr&gt;
&lt;h1&gt;2023.11.4前&lt;/h1&gt;
&lt;p&gt;配置好基本功能。网站基本可以运作。外网暂不能访问。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="OI" scheme="http://blog.eltaos.top/categories/OI/"/>
    
    
    <category term="FLOJ" scheme="http://blog.eltaos.top/tags/FLOJ/"/>
    
  </entry>
  
  <entry>
    <title>Simple-Algos-Notes</title>
    <link href="http://blog.eltaos.top/2023/Simple-Algos-Notes/"/>
    <id>http://blog.eltaos.top/2023/Simple-Algos-Notes/</id>
    <published>2023-11-02T12:36:19.000Z</published>
    <updated>2023-11-02T12:36:19.996Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Basic-Mathmatics-Notes</title>
    <link href="http://blog.eltaos.top/2023/Basic-Mathmatics-Notes/"/>
    <id>http://blog.eltaos.top/2023/Basic-Mathmatics-Notes/</id>
    <published>2023-10-31T16:00:00.000Z</published>
    <updated>2023-11-04T13:25:50.366Z</updated>
    
    <content type="html"><![CDATA[<h1>鲜花</h1><p>从树论赶来的，感觉这个东西没什么用啊…QwQ</p><h1>欧几里得</h1><h2 id="欧几里得算法">欧几里得算法</h2><p>也称辗转相除法。</p><p>就是一个简单的式子：<br>$$<br>\gcd(a,b)=\gcd(b,a \bmod b)<br>$$<br>证明如下：<br>$$<br>\text{令 } b=ka+r\ ,\ gcd(a,b)=d\<br>\text{则有 } d\ \vert\ a\ ,\ d\ \vert\ b\<br>r=b-ka\Rightarrow \frac{b}{d} - \frac{ka}{d}=\frac{r}{d}\<br>\text{由于左边显然为整数}\<br>\therefore r\ \text{和 } a \text{ 的公约数相等}\<br>\therefore r\ \text{和 } a \text{ 的最大公约数相等}<br>$$<br>证毕。</p><h2 id="扩展欧几里得算法（exgcd）">扩展欧几里得算法（exgcd）</h2><h3 id="裴蜀定理">裴蜀定理</h3><h4 id="定理">定理</h4><p>对于任意不全为 $0$ 的整数 $a,b$，均存在一组整数 $x,y$，使得 $ax+by=\gcd(a,b)$。</p><h4 id="证明">证明</h4><p>令 $d=\gcd(a,b),a=a_1d,b=b_1d$。</p><p>则有 $a_1dx+b_1dy=d(a_1x+b_1y)$。</p><p>那么可以把证明转化为<strong>对于任意不全为 $0$ 的整数 $a,b$ 满足 $\gcd(a,b)=1$，存在一组整数 $x,y$，满足 $ax+by=1$</strong>。</p><p>考虑模拟一遍欧几里得算法求 $\gcd(a,b)$。<br>$$<br>\gcd(a,b)\Rightarrow\gcd(b,a\bmod b)\Rightarrow\gcd(a\bmod b,b\bmod(a\bmod b))\Rightarrow\cdots\cdots<br>$$<br>发现很复杂，则把每一次的数记为 $r_1,r_2,r_3$，并记录每一次的等式：<br>$$<br>r_{m-1}=r_mq_m\<br>r_{m-2}=r_{m-1}q_{m-1}+r_m\\cdots\cdots\<br>r_1=r_2q_2+r_3\<br>a=r_1q_1+r_2<br>$$<br>考虑带入 $\gcd(a,b)=1$，则 $r_m=1$。然后把 $q_k$ 换成 $x_{k+1}$。<br>$$<br>\cdots\Rightarrow r_{m-2}=r_{m-1}x_{m}+1\Rightarrow 1=r_{m-2}-x_mr_{m-1}<br>$$<br>继续带入。<br>$$<br>r_{m-3}=r_{m-2}x_{m-1}+r_{m-1}\Rightarrow r_{m-1}=r_{m-3}-r_{m-2}x_{m-1}\<br>\cdots\Rightarrow 1=r_{m-2}-x_m(r_{m-3}-x_{m-1}r_{m-2})\Rightarrow 1=r_{m-2}-x_mr_{m-3}+x_mx_{m-1}r_{m-2}\Rightarrow 1=(1+x_mx_{m-1})r_{m-2}-x_mr_{m-3}\<br>r_{m-4}=r_{m-3}x_{m-2}+r_{m-2}\Rightarrow r_{m-2}=r_{m-4}-r_{m-3}x_{m-2}\<br>\cdots\Rightarrow1=(1+x_mx_{m-1})(r_{m-4}-r_{m-3}x_{m-2})-x_mr_{m-3}\Rightarrow 1=(1+x_mx_{m-1})r_{m-4}-(x_{m-2}x_{m-1}x_m+x_{m-2}+x_m)r_{m-3}<br>$$<br>可以通过模拟发现，总有系数可以满足等式左边为 $1$，由于最后 $r$ 可变为 $a,b$，所以可推出 $ax+by=1$ 成立。</p><p>证毕。</p><h4 id="例题：P4549">例题：<a href="https://www.lougu.com.cn/problem/P4549">P4549</a></h4><p>显然 $a_1x+b_1y=1$  是右边最小的情况。所以 $ax+by=\gcd(a,b)$ 是当前式子右边最小的情况。</p><p>由于 $\gcd(a,b)=\gcd(a,-b)$，所以只需要算出所有数的 $\gcd$ 即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="number">0</span>)<span class="keyword">return</span> b;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">gcd</span>(b%a,a);</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> a[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">a[i]=<span class="built_in">abs</span>(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)a[i]=<span class="built_in">gcd</span>(a[i],a[i<span class="number">-1</span>]);</span><br><span class="line">cout&lt;&lt;a[n];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="应用：CF510D">应用：<a href="https://www.luogu.com.cn/problem/CF510D">CF510D</a></h4><p>根据裴蜀定理可得，当 $\gcd(a,b)=1$ 时，一定有一组解 $x,y$，能满足 $ax+by=1$，此时就能满足题中所要求的 <code>能跳到所有位置上</code>。</p><p>然而题中要求最小。</p><p>考虑 dp，列出 dp 方程式：<br>$$<br>f_{\gcd(x,y)}=\min(f_{\gcd(x,y)},f_x+c_y)<br>$$<br>使用 <code>unordered_map</code> 记录之前的状态，对于每个点进行转移即可。</p><p>时间复杂度 $O(玄学)$。</p><p>咳咳，我之前写树上莫队的时候什么也没说。</p><p>但是很神奇的是用 <code>unordered_map</code> 会 <code>WA</code>，所以有点离谱。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!b)<span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,l[<span class="number">301</span>],c[<span class="number">303</span>];</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;l[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;c[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; x:mp)&#123;</span><br><span class="line"><span class="type">int</span> _next=<span class="built_in">gcd</span>(x.first,l[i]);</span><br><span class="line"><span class="keyword">if</span>(!mp[_next])mp[_next]=c[i]+x.second;</span><br><span class="line"><span class="keyword">else</span> mp[_next]=<span class="built_in">min</span>(mp[_next],c[i]+x.second);</span><br><span class="line"><span class="comment">//cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;_next&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!mp[l[i]])mp[l[i]]=c[i];</span><br><span class="line"><span class="keyword">else</span> mp[l[i]]=<span class="built_in">min</span>(mp[l[i]],c[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!mp[<span class="number">1</span>])mp[<span class="number">1</span>]=<span class="number">-1</span>;</span><br><span class="line">cout&lt;&lt;mp[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="进一步结论">进一步结论</h4><p>对于不定方程 $ax+by=n$，如果该方程有解，则称 $n$ 能被（系数） $a,b$ 表示。</p><p>记 $C=ab-a-b$，发现 $C=(a-1)(b-1)-1$，而若 $a,b$ 互质，那么至少其中有一个为偶数，那么 $C$ 必为奇数。</p><p>那么则有结论，<strong>对于任意整数 $n$，$n$ 和 $C-n$ 中只有一个能被 $a,b$ 表示</strong>。</p><p>注意此处的 $x,y$ 为自然数，即 $0$ 可被表示，$C$ 不可被表示；负数不可被表示，大于 $C$ 的数可被表示。</p><p>证明分三步：</p><p>令原方程解为：<br>$$<br>\begin{cases}<br>x=x_0+bt \cr<br>y=y_0-at<br>\end{cases}<br>$$<br>如果控制 $t$ 的大小，$y$ 能控制在 $0$ 到 $a-1$ 的范围内。其实可以发现对于 $[0,C]$ 的数， $y$ 不可能超过 $a-1$。</p><p>第一步：证明当 $n&gt;C$ 时，$n$ 都能被表示。</p><p>考虑 $y_{max}=a-1$，可以得到以下式子：<br>$$<br>ax=n-by&gt;ab-a-b-by\geq ab-a-b-b(a-1)=-a\Rightarrow x&gt;-1<br>$$<br>可见 $x$ 也是非负整数。</p><p>第二步：证明 $n=C$ 时，$n$ 不能被表示。</p><p>考虑如果 $n=C$ 时有解，即满足 $ax+by=ab-a-b$。</p><p>则有 $ab=a(x+1)+b(y+1)\Rightarrow a(b-x-1)=b(y+1)$。</p><p>由于 $a,b$ 互质，那么可以满足 $b-x-1=kb\ ,\ y+1=ka$。</p><p>由于 $y\in[0,a-1]$，所以 $k=1$。此时 $x=-1$，矛盾，故 $C$ 不能被表示。</p><p>此处的证明是作者口胡的，所以与 OI Wiki 上的解释不同。</p><p>第三步：证明当 $n$ 不能被表示时，$C-n$ 能被表示。</p><p>由于 $n$ 不能被表示，而 $y\in[0,a-1]$，故 $x$ 为负数。<br>$$<br>C-n=ab-a-b-ax-by=a(-1-x)+b(a-1-y)<br>$$<br>显然 $-1-x$ 和 $a-1-y$ 是非负的。</p><p>证毕。</p><p>几何意义看不懂。</p><h4 id="另一种解释">另一种解释</h4><p>考虑模 $b$ 意义下的每个剩余系最小能表示的值。因为 $\gcd(a,b)=1$，所以 $0,a,2a,\cdots,(b-1)a$ 在模 $b$ 的时候意义各不相同。</p><p>那么小于等于 $n$ 的能表示的所有非负整数的<strong>数量</strong>为：<br>$$<br>\sum_{i=0}^{\left\lfloor \frac{n}{a} \right\rfloor}\left\lfloor\frac{n-ai}{b}\right\rfloor<br>$$</p><p>因为对于所有剩余系的意义不同，所以要将所有剩余系的贡献累加。</p><p>用类欧几里得算法可以做到 $O(\log(\max(a,b)))$。</p><h3 id="exgcd">exgcd</h3><p>这个东西主要是来求不定方程 $ax+by=\gcd(a,b)$ 的一组整数解。也就是构造裴蜀定理的一组解。</p><h4 id="构造过程">构造过程</h4><p>考虑证明裴蜀定理的时候，对于 $\gcd(a,b)=1$ 的情况，我们是直接对欧几里得算法进行了反带最后得出解。</p><p>有了计算机，那么我们可以反带 $\gcd(a,b)\ne 1$ 的情况，是与 $\gcd(a,b)=1$ 时差不多的。</p><p>下面就是推式子环节了。</p><p>首先，对于欧几里得算法退出时，它的返回条件是 $b=0$，可发现此时一组可行解为：（不换行太丑了）<br>$$<br>\begin{cases}x=1\cr y=0\end{cases}<br>$$<br>然后对于任意 $ax+by=\gcd(a,b)$，考虑转化为递推。<br>$$<br>ax+by=\gcd(a,b)=\gcd(b,a \bmod b)=bx_0+(a\bmod b)y_0\<br>\Rightarrow ax+by=bx_0+(a-\left\lfloor\frac{a}{b}\right\rfloor\times b)y_0=ay_0+b(x_0-\left\lfloor\frac{a}{b}\right\rfloor y_0)<br>$$<br>所以推出一组可行的解 $x=y_0\ ,\ y=x_0-\left\lfloor\frac{a}{b}\right\rfloor y_0$。</p><p>递推即可。</p><h4 id="例题：P5656">例题：<a href="https://www.luogu.com.cn/problem/P5656">P5656</a></h4><p>这题要求是真的多。</p><p>首先用 exgcd 算出一组特解，然后来考虑各组解的关系。</p><p>列出式子 $a(x+p)+b(y-q)=ax+by=c$，发现 $ap=bq$。</p><p>由于 $p$ 和 $q$ 均为整数，所以 $p_{min}=\frac{1}{a}\times\operatorname{lcm}(a,b)$，$q_{min}$ 同。</p><p>然后就可以直接算出题中要求的所有信息了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> x,y,_a,_b,_c;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> d=a;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">0</span>)x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> d=<span class="built_in">exgcd</span>(b,a%b),<span class="built_in">swap</span>(x,y),y-=a/b*x;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line">cin&gt;&gt;_a&gt;&gt;_b&gt;&gt;_c;</span><br><span class="line"><span class="type">int</span> d=<span class="built_in">exgcd</span>(_a,_b);</span><br><span class="line"><span class="keyword">if</span>(_c%d)&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> k=_c/d;</span><br><span class="line">x*=k,y*=k;</span><br><span class="line"><span class="type">int</span> p=_b/d,q=_a/d;<span class="comment">//a(x+p)+b(y-q)=c，要交叉对应，别写反了！！！！</span></span><br><span class="line"><span class="comment">//用x,y其中一个最小整数解对应的那个数判断</span></span><br><span class="line"><span class="type">int</span> test=y/q;</span><br><span class="line"><span class="type">int</span> tx=test*p+x,ty=-test*q+y;</span><br><span class="line"><span class="keyword">if</span>(ty&lt;=<span class="number">0</span>)ty+=q,tx-=p;</span><br><span class="line"><span class="keyword">if</span>(tx&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">cout&lt;&lt;-(tx/p)*p+p+tx&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ty&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">cout&lt;&lt;(tx<span class="number">-1</span>)/p+<span class="number">1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;(tx<span class="number">-1</span>)%p+<span class="number">1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ty&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;tx&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;(tx<span class="number">-1</span>)/p*q+ty&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例题：P1516">例题：<a href="https://www.luogu.com.cn/problem/P1516">P1516</a></h4><p>考虑把这道题的参数转换成 $ax+by=n$。</p><p>考虑追及问题，所以可以列出：$\Delta vx+Ly=\Delta s$。</p><p>算出特解之后像上面那道题一样算 $x$ 的最小正整数解即可。</p><p>注意 $\Delta v$ 必须为正，如果要取反记得把 $\Delta s$ 也要取反。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> n,m,x,y,L;</span><br><span class="line"><span class="type">int</span> _x,_y;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> d=a;</span><br><span class="line"><span class="keyword">if</span>(!b)_x=<span class="number">1</span>,_y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> d=<span class="built_in">exgcd</span>(b,a%b),<span class="built_in">swap</span>(_x,_y),_y-=a/b*_x;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y&gt;&gt;m&gt;&gt;n&gt;&gt;L;</span><br><span class="line"><span class="type">int</span> z=n-m,f=x-y;</span><br><span class="line"><span class="keyword">if</span>(z&lt;<span class="number">0</span>)z=-z,f=-f;</span><br><span class="line"><span class="keyword">if</span>(f==<span class="number">0</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout&lt;&lt;z&lt;&lt;&quot; &quot;&lt;&lt;L&lt;&lt;&quot; &quot;&lt;&lt;f&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line"><span class="type">int</span> k=<span class="built_in">exgcd</span>(z,L),p=L/k,q=z/k;<span class="comment">//!!!</span></span><br><span class="line"><span class="comment">//cout&lt;&lt;k&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">_x*=(f/k),_y*=(f/k);</span><br><span class="line"><span class="comment">//cout&lt;&lt;p&lt;&lt;&quot; &quot;&lt;&lt;q&lt;&lt;&quot; &quot;&lt;&lt;_x&lt;&lt;&quot; &quot;&lt;&lt;_y&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line"><span class="keyword">if</span>(f%k)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Impossible&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(_x&gt;<span class="number">0</span>)cout&lt;&lt;(_x<span class="number">-1</span>)%p+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;_x%p+p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例题：P1082">例题：<a href="https://www.luogu.com/problem/P1082">P1082</a></h4><p>水题。</p><p>考虑式子 $ax \equiv 1\pmod b$，可以转换成 $ax-by=1$，由于题中说保证有解，故直接求 $x$ 的最小正整数解即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> d=a;</span><br><span class="line"><span class="keyword">if</span>(!b)x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> d=<span class="built_in">exgcd</span>(b,a%b),<span class="built_in">swap</span>(x,y),y-=a/b*x;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="type">int</span> d=<span class="built_in">exgcd</span>(n,m);</span><br><span class="line">y=-y;</span><br><span class="line"><span class="type">int</span> p=m/d,ans;</span><br><span class="line"><span class="keyword">if</span>(x&gt;<span class="number">0</span>)ans=(x<span class="number">-1</span>)%p+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> ans=x%p+p;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例题：P2421">例题：<a href="https://www.luogu.com.cn/problem/P2421">P2421</a></h4><p>较复杂的一道题。</p><p>判断每个野人生存周期以内的两两的 exgcd 即可。</p><p>然后由于没有单调性不能二分，直接枚举就行了。</p><p>和 P1516 差不多。</p><p>时间复杂度 $O(Mn^2\log c)$，随机打乱野人的遍历顺序之后应该能做到更优。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> d=a;</span><br><span class="line"><span class="keyword">if</span>(!b)x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> d=<span class="built_in">exgcd</span>(b,a%b),<span class="built_in">swap</span>(x,y),y-=a/b*x;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> c[<span class="number">21</span>],p[<span class="number">21</span>],l[<span class="number">21</span>],n;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> L)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line"><span class="type">int</span> z=p[j]-p[i],f=c[i]-c[j];</span><br><span class="line"><span class="keyword">if</span>(z&lt;<span class="number">0</span>)z=-z,f=-f;</span><br><span class="line"><span class="keyword">if</span>(f==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> d=<span class="built_in">exgcd</span>(z,L);</span><br><span class="line"><span class="keyword">if</span>(f%d)<span class="keyword">continue</span>;</span><br><span class="line"><span class="type">int</span> p=L/d,q=z/d;</span><br><span class="line">x*=(f/d),y*=(f/d);</span><br><span class="line"><span class="comment">//cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;p&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;f&lt;&lt;&quot; &quot;&lt;&lt;d&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="keyword">if</span>(x&gt;<span class="number">0</span>)ans=(x<span class="number">-1</span>)%p+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> ans=x%p+p;</span><br><span class="line"><span class="keyword">if</span>(ans&lt;=l[i]&amp;&amp;ans&lt;=l[j])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> maxc=<span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;c[i]&gt;&gt;p[i]&gt;&gt;l[i],maxc=<span class="built_in">max</span>(c[i],maxc);</span><br><span class="line"><span class="keyword">for</span>(;;maxc++)<span class="keyword">if</span>(<span class="built_in">check</span>(maxc))&#123;</span><br><span class="line">cout&lt;&lt;maxc;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="应用：UVA12775">应用：<a href="https://www.luogu.com.cn/problem/UVA12775">UVA12775</a></h4><p>枚举每个 $C$，然后先求 $\operatorname{exgcd}(A,B)$，然后枚举每个 $Ax+By=P-iC$ 的解的数量即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: Gift Dilemma</span></span><br><span class="line"><span class="comment">// Contest: Luogu</span></span><br><span class="line"><span class="comment">// URL: https://www.luogu.com.cn/problem/UVA12775</span></span><br><span class="line"><span class="comment">// Memory Limit: 0 MB</span></span><br><span class="line"><span class="comment">// Time Limit: 3000 ms</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Powered by CP Editor (https://cpeditor.org)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> T,a,b,c,p,x,y;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> d=a;</span><br><span class="line"><span class="keyword">if</span>(!b)x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> d=<span class="built_in">exgcd</span>(b,a%b),<span class="built_in">swap</span>(x,y),y-=a/b*x;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;T;</span><br><span class="line"><span class="type">int</span> Y=T;</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;p;</span><br><span class="line"><span class="type">int</span> d=<span class="built_in">exgcd</span>(a,b);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i*c&lt;=p;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>((p-i*c)%d)<span class="keyword">continue</span>;</span><br><span class="line"><span class="type">int</span> tx=x*(p-i*c)/d,ty=y*(p-i*c)/d;</span><br><span class="line"><span class="type">int</span> p=b/d,q=a/d;</span><br><span class="line"><span class="comment">//cout&lt;&lt;tx&lt;&lt;&quot; &quot;&lt;&lt;ty&lt;&lt;&quot; &quot;&lt;&lt;p&lt;&lt;&quot; &quot;&lt;&lt;q&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line"><span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(tx&gt;=<span class="number">0</span>||tx%p==<span class="number">0</span>)res=tx%p;</span><br><span class="line"><span class="keyword">else</span> res=tx%p+p;</span><br><span class="line">res=(res-tx)/p;</span><br><span class="line">ty-=res*q;</span><br><span class="line"><span class="keyword">if</span>(ty&gt;=<span class="number">0</span>)ans+=ty/q+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//cout&lt;&lt;ty-res*q&lt;&lt;&quot; &quot;&lt;&lt;res&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Case &quot;</span>&lt;&lt;Y-T&lt;&lt;<span class="string">&quot;: &quot;</span>&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="应用：UVA10104">应用：<a href="https://www.luogu.com.cn/problem/UVA10104">UVA10104</a></h4><p>不会证明这个结论，因此直接搬 tj 了。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/pi4uje7u.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: Euclid Problem</span></span><br><span class="line"><span class="comment">// Contest: Luogu</span></span><br><span class="line"><span class="comment">// URL: https://www.luogu.com.cn/problem/UVA10104</span></span><br><span class="line"><span class="comment">// Memory Limit: 0 MB</span></span><br><span class="line"><span class="comment">// Time Limit: 3000 ms</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Powered by CP Editor (https://cpeditor.org)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> d=a;</span><br><span class="line"><span class="keyword">if</span>(!b)x=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> d=<span class="built_in">exgcd</span>(b,a%b),<span class="built_in">swap</span>(x,y),y-=a/b*x;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> a,b,gcd;</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;a&gt;&gt;b)gcd=<span class="built_in">exgcd</span>(a,b),cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;y&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;gcd&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类欧几里得算法">类欧几里得算法</h2><p>这个算法是用来在 $O(\log n)$ 的时间内计算下面三个函数：<br>$$<br>f(a,b,c,n)=\sum_{i=0}^n\left\lfloor\frac{ai+b}{c}\right\rfloor\<br>g(a,b,c,n)=\sum_{i=0}^ni\left\lfloor\frac{ai+b}{c}\right\rfloor\<br>h(a,b,c,n)=\sum_{i=0}<sup>n\left\lfloor\frac{ai+b}{c}\right\rfloor</sup>2<br>$$</p><h3 id="推式子">推式子</h3><p>然后开始艰难地推式子…</p><p>先令 $s<sup>0(n)=n+1 , s</sup>1(n)=\frac{(n+1)n}{2}\ ,\ s^2(n)=\frac{n(n+1)(2n+1)}{6}$。</p><p>对于 $a&gt;c \or b&gt;c$ 的情况：<br>$$<br>\begin{aligned}<br>f(a,b,c,n)&amp;=\sum_{i=0}^n\left\lfloor\frac{ai+b}{c}\right\rfloor\cr<br>&amp;=\sum_{i=0}^n\left(\left\lfloor\frac{(a\bmod c)i+b\bmod c}{c}\right\rfloor+\left\lfloor\frac{a}{c}\right\rfloor i+\left\lfloor\frac{b}{c}\right\rfloor\right)\cr<br>&amp;=\left\lfloor\frac{b}{c}\right\rfloor\times s^0(n)+\left\lfloor\frac{a}{c}\right\rfloor \times s^1(n)+f(a\bmod c,b\bmod c,c,n)\cr<br>g(a,b,c,n)&amp;=\sum_{i=0}^ni\left\lfloor\frac{ai+b}{c}\right\rfloor\cr<br>&amp;=\sum_{i=0}^ni\left(\left\lfloor\frac{(a\bmod c)i+b\bmod c}{c}\right\rfloor+\left\lfloor\frac{a}{c}\right\rfloor i+\left\lfloor\frac{b}{c}\right\rfloor\right)\cr<br>&amp;=\sum_{i=0}^n\left(\left\lfloor\frac{a}{c}\right\rfloor i^2+\left\lfloor\frac{b}{c}\right\rfloor i\right)+g(a\bmod c,b\bmod c,c,n)\cr<br>&amp;=\left\lfloor\frac{a}{c}\right\rfloor\times s^2(n)+\left\lfloor\frac{b}{c}\right\rfloor\times s^1(n)+g(a\bmod c,b\bmod c,c,n)\cr<br>h(a,b,c,n)&amp;=\sum_{i=0}<sup>n\left\lfloor\frac{ai+b}{c}\right\rfloor</sup>2\cr<br>&amp;=\sum_{i=0}^n\left(\left\lfloor\frac{(a\bmod c)i+b\bmod c}{c}\right\rfloor+\left\lfloor\frac{a}{c}\right\rfloor i+\left\lfloor\frac{b}{c}\right\rfloor\right)^2\cr<br>&amp;=h(a\bmod c,b\bmod c,c,n)+2\left\lfloor\frac{a}{c}\right\rfloor g(a\bmod c,b\bmod c,c,n)+2\left\lfloor\frac{b}{c}\right\rfloor f(a\bmod c,b\bmod c,c,n)+\sum_{i=0}<sup>n\left(\left\lfloor\frac{a}{c}\right\rfloor</sup>2 i<sup>2+\left\lfloor\frac{b}{c}\right\rfloor</sup>2+2\left\lfloor\frac{a}{c}\right\rfloor \left\lfloor\frac{b}{c}\right\rfloor i\right)\cr<br>&amp;=s^0(n)\times \left\lfloor\frac{b}{c}\right\rfloor<sup>2+s</sup>1(n)\times 2\left\lfloor\frac{a}{c}\right\rfloor\left\lfloor\frac{b}{c}\right\rfloor+s^2(n)\times \left\lfloor\frac{a}{c}\right\rfloor^2+h(a\bmod c,b\bmod c,c,n)+2\left\lfloor\frac{a}{c}\right\rfloor g(a\bmod c,b\bmod c,c,n)+2\left\lfloor\frac{b}{c}\right\rfloor f(a\bmod c,b\bmod c,c,n)<br>\end{aligned}<br>$$<br>作者的手已经打废了。/kk</p><p>对于 $a&lt;c\and b&lt;c$ 的情况：</p><p>先看三个式子同样要用到的东西：</p><p>令 $\displaystyle m=\left\lfloor\frac{an+b}{c}\right\rfloor$。<br>$$<br>\begin{aligned}<br>\sum_{i=0}<sup>n\left[j&lt;\left\lfloor\frac{ai+b}{c}\right\rfloor\right]&amp;=\sum_{i=0}</sup>n\left[j+1\leq\frac{ai+b}{c}\right]\cr<br>&amp;=\sum_{i=0}^{n}\left[jc+c\leq ai+b\right]\cr<br>&amp;=\sum_{i=0}^{n}[ai\geq jc+c-b]\cr<br>&amp;=\sum_{i=0}^n[ai&gt;jc+c-b-1]\cr<br>&amp;=\sum_{i=0}^n\left[i&gt;\left\lfloor\frac{jc+c+b-1}{a}\right\rfloor\right]\cr<br>&amp;=n-\left\lfloor\frac{jc+c+b-1}{a}\right\rfloor<br>\end{aligned}<br>$$<br>然后逐个击破：<br>$$<br>\begin{aligned}<br>f(a,b,c,n)&amp;=\sum_{i=0}^n\left\lfloor\frac{ai+b}{c}\right\rfloor\cr<br>&amp;=\sum_{i=0}<sup>n\sum_{j=0}</sup>{\lfloor\frac{ai+b}{c}\rfloor-1}1\cr<br>&amp;=\sum_{i=0}<sup>n\sum_{j=0}</sup>{m-1}\left[j&lt;\left\lfloor\frac{ai+b}{c}\right\rfloor\right]\cr<br>&amp;=\sum_{j=0}<sup>{m-1}\sum_{i=0}</sup>n\left[j&lt;\left\lfloor\frac{ai+b}{c}\right\rfloor\right]\cr<br>&amp;=\sum_{j=0}^{m-1}\left(n-\left\lfloor\frac{jc+c+b-1}{a}\right\rfloor\right)\cr<br>&amp;=nm-f(c,c-b-1,a,m-1)\cr<br>g(a,b,c,n)&amp;=\sum_{i=0}^ni\left\lfloor\frac{ai+b}{c}\right\rfloor\cr<br>&amp;=\sum_{i=0}<sup>n\sum_{j=0}</sup>{\lfloor\frac{ai+b}{c}\rfloor-1}i\cr<br>&amp;=\sum_{i=0}<sup>n\sum_{j=0}</sup>{m-1}\left(\left[j&lt;\left\lfloor\frac{ai+b}{c}\right\rfloor\right]\times i\right)\cr<br>&amp;=\sum_{j=0}<sup>{m-1}\sum_{i=0}</sup>n\left(\left[j&lt;\left\lfloor\frac{ai+b}{c}\right\rfloor\right]\times i\right)\cr<br>&amp;=\sum_{j=0}<sup>{m-1}\sum_{i=0}</sup>n\left(\left[i&gt;\left\lfloor\frac{jc+c+b-1}{a}\right\rfloor\right]\times i\right)\cr<br>&amp;=\sum_{j=0}^{m-1}\frac{\left(n+\left\lfloor\frac{jc+c+b-1}{a}\right\rfloor+1\right)\times\left(n-\left\lfloor\frac{jc+c+b-1}{a}\right\rfloor\right)}{2}\cr<br>&amp;=\frac{\displaystyle\sum_{j=0}<sup>{m-1}\left(n</sup>2-\left\lfloor\frac{jc+c+b-1}{a}\right\rfloor^2+n-\left\lfloor\frac{jc+c+b-1}{a}\right\rfloor\right)}{2}\cr<br>&amp;=\frac{n(n+1)m-h(c,c-b-1,a,m-1)-f(c,c-b-1,a,m-1)}{2}\cr<br>h(a,b,c,n)&amp;=\sum_{i=0}<sup>n\left\lfloor\frac{ai+b}{c}\right\rfloor</sup>2\cr<br>&amp;=2\sum_{i=0}<sup>n\sum_{j=0}</sup>{\lfloor\frac{ai+b}{c}\rfloor-1}(j+1)-\sum_{i=0}^n\left\lfloor\frac{ai+b}{c}\right\rfloor\cr<br>&amp;=2\sum_{i=0}<sup>n\sum_{j=0}</sup>{m-1}\left(\left[j&lt;\left\lfloor\frac{ai+b}{c}\right\rfloor\right]\times (j+1)\right)-f(a,b,c,n)\cr<br>&amp;=2\sum_{j=0}<sup>{m-1}(j+1)\sum_{i=0}</sup>n\left[j&lt;\left\lfloor\frac{ai+b}{c}\right\rfloor\right]-f(a,b,c,n)\cr<br>&amp;=2\sum_{j=0}^{m-1}\left((j+1)\times \left(n-\left\lfloor\frac{jc+c+b-1}{a}\right\rfloor\right)\right)-f(a,b,c,n)\cr<br>&amp;=(m+1)mn-2\sum_{j=0}^{m-1}\left(j\left\lfloor\frac{jc+c+b-1}{a}\right\rfloor+\left\lfloor\frac{jc+c+b-1}{a}\right\rfloor\right)-f(a,b,c,n)\cr<br>&amp;=(m+1)mn-2g(c,c-b-1,a,m-1)-2f(c,c-b-1,a,m-1)-f(a,b,c,n)<br>\end{aligned}<br>$$<br>边界：<br>$$<br>\begin{aligned}<br>f(0,b,c,n)&amp;=s^0(n)\times \left\lfloor\frac{b}{c}\right\rfloor\cr<br>g(0,b,c,n)&amp;=s^1(n)\times \left\lfloor\frac{b}{c}\right\rfloor\cr<br>h(0,b,c,n)&amp;=s<sup>0(n)\times\left\lfloor\frac{b}{c}\right\rfloor</sup>2\cr<br>\end{aligned}<br>$$<br>写完这个东西就去复习 CSP 了。</p><h3 id="板子题：P5170">板子题：P5170</h3><p>没啥可说的，注意取模即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">R</span>&#123;</span><br><span class="line"><span class="type">int</span> f,g,h;</span><br><span class="line">&#125;ans;</span><br><span class="line"><span class="function">R <span class="title">getr</span><span class="params">(<span class="type">int</span> _f,<span class="type">int</span> _g,<span class="type">int</span> _h)</span></span>&#123;</span><br><span class="line">R temp;</span><br><span class="line">temp.f=_f;</span><br><span class="line">temp.g=_g;</span><br><span class="line">temp.h=_h;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> I2=<span class="number">499122177</span>,I6=<span class="number">166374059</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">s0</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> k+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">s1</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> k*(k+<span class="number">1</span>)%mod*I2%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">s2</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> k*(k+<span class="number">1</span>)%mod*(<span class="number">2</span>*k+<span class="number">1</span>)%mod*I6%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">R <span class="title">simgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> F=<span class="number">0</span>,G=<span class="number">0</span>,H=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">getr</span>((b/c)*<span class="built_in">s0</span>(n)%mod,(b/c)*<span class="built_in">s1</span>(n)%mod,(b/c)*(b/c)%mod*<span class="built_in">s0</span>(n)%mod);</span><br><span class="line">R res;</span><br><span class="line"><span class="keyword">if</span>(a&gt;=c||b&gt;=c)&#123;</span><br><span class="line">res=<span class="built_in">simgcd</span>(a%c,b%c,c,n);</span><br><span class="line">F=res.f+b/c*<span class="built_in">s0</span>(n)%mod+a/c*<span class="built_in">s1</span>(n)%mod;</span><br><span class="line">G=res.g+a/c*<span class="built_in">s2</span>(n)%mod+b/c*<span class="built_in">s1</span>(n)%mod;</span><br><span class="line">H=b/c*<span class="number">2</span>*res.f%mod+a/c*<span class="number">2</span>*res.g%mod+res.h+b/c*(b/c)%mod*<span class="built_in">s0</span>(n)%mod+b/c*(a/c)*<span class="number">2</span>%mod*<span class="built_in">s1</span>(n)%mod+(a/c)*(a/c)%mod*<span class="built_in">s2</span>(n)%mod;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">getr</span>(F%mod,G%mod,H%mod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m=(a*n+b)/c;</span><br><span class="line">res=<span class="built_in">simgcd</span>(c,c-b<span class="number">-1</span>,a,m<span class="number">-1</span>);</span><br><span class="line">F=n*m%mod-res.f%mod;</span><br><span class="line">G=(n*(n+<span class="number">1</span>)%mod*m%mod-res.h%mod-res.f%mod)*I2%mod;</span><br><span class="line">H=(m+<span class="number">1</span>)*m%mod*n%mod+<span class="number">-2</span>*res.g%mod<span class="number">-2</span>*res.f%mod-F%mod;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">getr</span>((F%mod+mod)%mod,(G%mod+mod)%mod,(H%mod+mod)%mod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> T,aa,bb,cc,nn;</span><br><span class="line">cin&gt;&gt;T;</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line">cin&gt;&gt;nn&gt;&gt;aa&gt;&gt;bb&gt;&gt;cc;</span><br><span class="line">ans=<span class="built_in">simgcd</span>(aa,bb,cc,nn);</span><br><span class="line">cout&lt;&lt;(ans.f%mod)&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;(ans.h%mod)&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;(ans.g%mod)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用：P5171">应用：P5171</h3><p>CSP 复习前的最后一道题。</p><p>考虑分开讨论 $x,y$。</p><p>之前好像有证明 $\gcd(a,b)=1$ 的特殊情况的式子。</p><p>先讨论 $y$ 的范围：<br>$$<br>ax+by\leq c\Rightarrow by\leq c-ax\Rightarrow y\leq\left\lfloor\frac{c-ax}{b}\right\rfloor<br>$$<br>所以对于 $y$ ，合法的 $x$ 至多有 $\left\lfloor\frac{c-ax}{b}\right\rfloor+1$ 个。</p><p>再来讨论 $x$ 的范围。考虑当 $y=0$ 的极限情况，$x$ 最大就是 $\lfloor\frac{c}{a}\rfloor$，所以 $x\in[0,\left\lfloor\frac{c}{a}\right\rfloor]$。</p><p>所以式子列出来就是：<br>$$<br>\sum_{x=0}^{\left\lfloor\frac{c}{a}\right\rfloor}\left(\left\lfloor\frac{c-ax}{b}\right\rfloor+1\right)<br>$$<br>因为 $-a&lt;0$，要进行转化。考虑此时的 $x$ 和 $y$ 无论以哪个作为对象都能得到答案，所以此时的 $a,b$ 互换是没有影响的，所以可以将式子改写为：<br>$$<br>\sum_{x=0}<sup>{\left\lfloor\frac{c}{a}\right\rfloor}\left(\left\lfloor\frac{(b-a)x+c}{b}\right\rfloor-x\right)+s</sup>0\left(\left\lfloor\frac{c}{a}\right\rfloor\right)=\sum_{x=0}<sup>{\left\lfloor\frac{c}{a}\right\rfloor}\left\lfloor\frac{(b-a)x+c}{b}\right\rfloor-s</sup>1\left(\left\lfloor\frac{c}{a}\right\rfloor\right)+s^0\left(\left\lfloor\frac{c}{a}\right\rfloor\right)<br>$$<br>然后就可以求解了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: P5171 Earthquake</span></span><br><span class="line"><span class="comment">// Contest: Luogu</span></span><br><span class="line"><span class="comment">// URL: https://www.luogu.com.cn/problem/P5171</span></span><br><span class="line"><span class="comment">// Memory Limit: 125 MB</span></span><br><span class="line"><span class="comment">// Time Limit: 250 ms</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Powered by CP Editor (https://cpeditor.org)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">s0</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> k+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">s1</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> k*(k+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">simgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(a&gt;=c||b&gt;=c)res+=<span class="built_in">s1</span>(n)*(a/c)+<span class="built_in">s0</span>(n)*(b/c),a%=c,b%=c;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">s0</span>(n)*(b/c)+res;</span><br><span class="line"><span class="type">int</span> m=(a*n+b)/c;</span><br><span class="line"><span class="keyword">return</span> m*n-<span class="built_in">simgcd</span>(c,c-b<span class="number">-1</span>,a,m<span class="number">-1</span>)+res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> A,B,C;</span><br><span class="line">cin&gt;&gt;A&gt;&gt;B&gt;&gt;C;</span><br><span class="line"><span class="keyword">if</span>(A&gt;B)<span class="built_in">swap</span>(A,B);</span><br><span class="line"><span class="type">int</span> ans=<span class="built_in">simgcd</span>(B-A,C,B,C/A);</span><br><span class="line">ans-=<span class="built_in">s1</span>(C/A)-C/A;</span><br><span class="line">cout&lt;&lt;ans+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="鸽">鸽</h3><p>这里应该还有 $3$ 道类欧没有写，CSP 回来之后再写，祝 RP++！</p><p>没写的：AT_abc283_h，P5172，P5179。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;鲜花&lt;/h1&gt;
&lt;p&gt;从树论赶来的，感觉这个东西没什么用啊…QwQ&lt;/p&gt;
&lt;h1&gt;欧几里得&lt;/h1&gt;
&lt;h2 id=&quot;欧几里得算法&quot;&gt;欧几里得算法&lt;/h2&gt;
&lt;p&gt;也称辗转相除法。&lt;/p&gt;
&lt;p&gt;就是一个简单的式子：&lt;br&gt;
$$&lt;br&gt;
&#92;gcd(a,b)=&#92;gcd(</summary>
      
    
    
    
    <category term="OI" scheme="http://blog.eltaos.top/categories/OI/"/>
    
    
    <category term="OI" scheme="http://blog.eltaos.top/tags/OI/"/>
    
  </entry>
  
  <entry>
    <title>search-Notes</title>
    <link href="http://blog.eltaos.top/2023/search-Notes/"/>
    <id>http://blog.eltaos.top/2023/search-Notes/</id>
    <published>2023-10-16T02:28:39.000Z</published>
    <updated>2023-10-16T02:28:39.110Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>tree-mo&#39;s-algo-Notes</title>
    <link href="http://blog.eltaos.top/2023/tree-mo-s-algo-Notes/"/>
    <id>http://blog.eltaos.top/2023/tree-mo-s-algo-Notes/</id>
    <published>2023-10-12T12:24:53.000Z</published>
    <updated>2023-10-12T12:27:33.277Z</updated>
    
    <content type="html"><![CDATA[<p>由于联考考到了树上莫队，然后我预处理和正解一样，就是单纯打不出来树上莫队，于是来写一发学习笔记。</p><h1>'树’上莫队</h1><p>应该没有人直接写在树上莫队的吧，都是把树转化成欧拉序的吧。</p><p>欧拉序好像就是括号序，但是记录的是<strong>节点编号，不是点权或者点上颜色</strong>。（考试时的误区，导致没有手胡出来代码）</p><p>然后再通过节点编号定位获取相应信息。</p><p>如果节点编号出现两次，那么就无视这个点。</p><p>欧拉序举例：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/r28qw480.png" alt=""></p><p>这个树按重链剖分来说的欧拉序是 $[0,1,4,6,6,7,7,8,8,4,3,3,1,2,9,9,5,5,2,0]$。</p><p>我们可以从中发现一些规律。</p><p>令 $st[a]$ 为编号 $a$ 第一次出现的位置，$ed[a]$ 为编号 $a$ 第二次出现的位置。</p><p>如果此时我们要询问路径 $7\to 2$，发现 $dfn_7&lt;dfn_2$，那么取 $[ed[7],st[2]]$ 作为询问的区间。按刚刚的策略 <code>如果节点编号出现两次，那么就无视这个点</code> 可以发现，这个区间可以转化：<br>$$<br>{7,8,8,4,3,3,1,2}\Rightarrow{7,4,1,2}<br>$$<br>再举个栗子：路径 $3\to 4$ 怎么转化？</p><p>发现 $dfn_4&lt;dfn_3$，则取 $[ed[4],st[3]]$ 区间进行询问，转化为 ${4,3}$。</p><p>发现这两个例子的 $LCA$ 都正好没有统计到，所以要加上起点和终点的 $LCA$ 的贡献。</p><p>但是如果 $u$ 是 $v$ 的祖先时，就不能再加一遍 $LCA$ 了。</p><h1>例题</h1><h2 id="板子题：SP10707">板子题：SP10707</h2><p>很惨的是，如果联考的时候这道题会，那么就是标准 std 了。/dk</p><p>因为权值很大，所以要离散化。</p><p>喜报，作者因为用了 <code>unordered_map</code> 然后卡常卡了 $1h$，然后换成离散化就过了。<code>unordered_map</code> 狗都不用，草！</p><p>注意细节即可。代码里有注释。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;Ofast&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span>&#123;</span><br><span class="line"><span class="type">int</span> to,link;</span><br><span class="line">&#125;E[<span class="number">800002</span>];</span><br><span class="line"><span class="type">int</span> head[<span class="number">500001</span>],tot=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addE</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">E[++tot].to=v;</span><br><span class="line">E[tot].link=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dep[<span class="number">500001</span>],siz[<span class="number">500001</span>],fa[<span class="number">500001</span>],hson[<span class="number">500001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">fa[now]=f;</span><br><span class="line">siz[now]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==f)<span class="keyword">continue</span>;</span><br><span class="line">dep[E[i].to]=dep[now]+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs1</span>(E[i].to,now);</span><br><span class="line">siz[now]+=siz[E[i].to];</span><br><span class="line"><span class="keyword">if</span>(siz[E[i].to]&gt;siz[hson[now]])hson[now]=E[i].to;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dfn[<span class="number">400001</span>],_dfn[<span class="number">400001</span>],rk[<span class="number">800001</span>],dfncnt,ltop[<span class="number">50001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> top)</span></span>&#123;</span><br><span class="line">ltop[now]=top;</span><br><span class="line">dfn[now]=++dfncnt;</span><br><span class="line">rk[dfncnt]=now;</span><br><span class="line"><span class="keyword">if</span>(!hson[now])&#123;</span><br><span class="line">_dfn[now]=++dfncnt;<span class="comment">//!!!!别忘了这里return的时候也要加_dfn数组</span></span><br><span class="line">rk[dfncnt]=now;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs2</span>(hson[now],top);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==fa[now]||E[i].to==hson[now])<span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(E[i].to,E[i].to);</span><br><span class="line">&#125;</span><br><span class="line">_dfn[now]=++dfncnt;</span><br><span class="line">rk[dfncnt]=now;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> w[<span class="number">400001</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(ltop[u]!=ltop[v])&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[ltop[u]]&gt;dep[ltop[v]])u=fa[ltop[u]];</span><br><span class="line"><span class="keyword">else</span> v=fa[ltop[v]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ((dep[u]&gt;dep[v])?v:u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mp[<span class="number">500001</span>];</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>,base,tes[<span class="number">500001</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">query</span>&#123;</span><br><span class="line"><span class="type">int</span> u,v,lca;</span><br><span class="line"><span class="type">int</span> l,r,id;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">lca=<span class="built_in">LCA</span>(u,v);</span><br><span class="line"><span class="keyword">if</span>(dfn[u]&gt;dfn[v])<span class="built_in">swap</span>(u,v);</span><br><span class="line"><span class="keyword">if</span>(u==lca)l=dfn[u],r=dfn[v],lca=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> l=_dfn[u],r=dfn[v];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> query &amp;a) <span class="type">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (l/base==a.l/base)?r&lt;a.r:l&lt;a.l;</span><br><span class="line">&#125;</span><br><span class="line">&#125;Q[<span class="number">400004</span>];</span><br><span class="line"><span class="type">int</span> bu[<span class="number">400001</span>],Ans[<span class="number">400001</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">const</span> <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">bu[rk[t]]^=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(bu[rk[t]])&#123;</span><br><span class="line">mp[w[rk[t]]]=mp[w[rk[t]]]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(mp[w[rk[t]]]==<span class="number">1</span>)cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(mp[w[rk[t]]]==<span class="number">1</span>)cnt--;</span><br><span class="line">mp[w[rk[t]]]=mp[w[rk[t]]]<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;w[i],tes[i]=w[i];</span><br><span class="line"><span class="built_in">sort</span>(tes+<span class="number">1</span>,tes+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)w[i]=<span class="built_in">lower_bound</span>(tes+<span class="number">1</span>,tes+n+<span class="number">1</span>,w[i])-tes;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="built_in">addE</span>(x,y);</span><br><span class="line"><span class="built_in">addE</span>(y,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">cin&gt;&gt;Q[i].u&gt;&gt;Q[i].v;</span><br><span class="line">Q[i].<span class="built_in">init</span>();</span><br><span class="line">Q[i].id=i;</span><br><span class="line">&#125;</span><br><span class="line">base=n*<span class="number">2</span>/<span class="built_in">sqrt</span>(m*<span class="number">2</span>/<span class="number">3</span>);</span><br><span class="line"><span class="built_in">sort</span>(Q+<span class="number">1</span>,Q+m+<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(l&gt;Q[i].l)<span class="built_in">upd</span>(--l);</span><br><span class="line"><span class="keyword">while</span>(l&lt;Q[i].l)<span class="built_in">upd</span>(l++);</span><br><span class="line"><span class="keyword">while</span>(r&gt;Q[i].r)<span class="built_in">upd</span>(r--);</span><br><span class="line"><span class="keyword">while</span>(r&lt;Q[i].r)<span class="built_in">upd</span>(++r);</span><br><span class="line"><span class="comment">//cerr&lt;&lt;cnt&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line"><span class="keyword">if</span>(Q[i].lca)<span class="built_in">upd</span>(dfn[Q[i].lca]);<span class="comment">//注意这里是dfn序</span></span><br><span class="line">Ans[Q[i].id]=cnt;</span><br><span class="line"><span class="comment">//cerr&lt;&lt;cnt&lt;&lt;&quot; &quot;&lt;&lt;Q[i].len&lt;&lt;&quot; &quot;&lt;&lt;Q[i].lca&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line"><span class="keyword">if</span>(Q[i].lca)<span class="built_in">upd</span>(dfn[Q[i].lca]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">cout&lt;&lt;Ans[i]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="20231012T3">20231012T3</h2><p>考虑转换问题即可。</p><p>预处理质数的平方，暴力将原来的权值中间的平方因子除掉，然后就变成了是否有一种一个点对的权值相同。</p><p>考虑存在时，直接判断路径上的点数是否和颜色数是否相等即可。</p><p>代码就不贴了。</p><p>有其他例题欢迎在评论区提出。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由于联考考到了树上莫队，然后我预处理和正解一样，就是单纯打不出来树上莫队，于是来写一发学习笔记。&lt;/p&gt;
&lt;h1&gt;&#39;树’上莫队&lt;/h1&gt;
&lt;p&gt;应该没有人直接写在树上莫队的吧，都是把树转化成欧拉序的吧。&lt;/p&gt;
&lt;p&gt;欧拉序好像就是括号序，但是记录的是&lt;strong&gt;节点编</summary>
      
    
    
    
    <category term="OI" scheme="http://blog.eltaos.top/categories/OI/"/>
    
    
    <category term="OI" scheme="http://blog.eltaos.top/tags/OI/"/>
    
  </entry>
  
  <entry>
    <title>Tree-Theory-Notes</title>
    <link href="http://blog.eltaos.top/2023/Tree-Theory-Notes/"/>
    <id>http://blog.eltaos.top/2023/Tree-Theory-Notes/</id>
    <published>2023-10-07T09:06:07.000Z</published>
    <updated>2023-11-04T13:25:35.326Z</updated>
    
    <content type="html"><![CDATA[<h1>鲜花</h1><p>听 Mea 讲树论，但是还是脱不了修锅的命运（</p><hr><p>注：本文中，<code>dfs 序</code> 等同于 <code>dfn 序</code>。</p><h1>树的基础</h1><h2 id="树的直径">树的直径</h2><p>定义就是树上的最长路径，非常好理解。</p><h3 id="求法">求法</h3><ul class="lvl-0"><li class="lvl-2"><p>对于所有树</p></li></ul><p>对于所有树，均可以使用树形 DP 的方式求解，但是带负权的树据 Mea 说非常抽象，不怎么考，所以没什么用（</p><p>记录最长路和次长路即可。</p><p>参考代码（现场写的）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> d1[N],d2[N],len;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    d1[now]=d2[now]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line">        <span class="keyword">if</span>(E[i].to==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(E[i].to,now);</span><br><span class="line">        <span class="type">int</span> temp=d1[E[i].to]+E[i].v;</span><br><span class="line">        <span class="keyword">if</span>(d1[now]&lt;temp)&#123;</span><br><span class="line">            d2[now]=d1[now];</span><br><span class="line">            d1[now]=temp;<span class="comment">//d1与d2数组记录的路径不能边交</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d2[now]&lt;temp)&#123;</span><br><span class="line">            d2[now]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    len=<span class="built_in">max</span>(len,d1[now]+d2[now]);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>仅对于正权边的树</p></li></ul><p>两次 dfs 即可。</p><p>这时，我们需要证明，树上任意一点与树上其他点形成的最长路径的终点是直径一个的端点。</p><p>设 $a\rightarrow y$ 是当前遍历到的最长路径，$s\rightarrow t$ 为直径，设 $y$ 不为直径端点，钦定 $dis_{a\rightarrow s}\leq dis_{a\rightarrow t}$。</p><ul class="lvl-0"><li class="lvl-2"><p>$y$ 在 $s\rightarrow t$ 上，此时 $dis_{a\rightarrow t}&lt;dis_{a\rightarrow y}$，则有 $dis_{s\rightarrow y}&gt;dis_{s\rightarrow t}$，矛盾。</p></li><li class="lvl-2"><p>$a\rightarrow y$ 与 $s\rightarrow t$ 有交 $c\rightarrow d$，显然仍有 $dis_{a\rightarrow t}&lt;dis_{a\rightarrow y}$，那么去掉相同部分可得 $dis_{c\rightarrow y}&gt;dis_{c\rightarrow t}$，就转化成了第一种情况。</p></li><li class="lvl-2"><p>$a\rightarrow y$ 与 $s\rightarrow t$ 无交，显然还是有 $dis_{a\rightarrow t}&lt;dis_{a\rightarrow y}$，易发现 $y$ 一定为叶子节点，故 $a$ 比 $y$ 离 $s\rightarrow t$ 近。所以一定有 $dis_{s\rightarrow a\rightarrow y}&gt;dis_{s\rightarrow a\rightarrow t}\geq dis_{s\rightarrow t}$，矛盾。</p></li></ul><p>证毕。</p><p>那就好实现了，直接 dfs 求两次距离当前点最远的点即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dep[N],ed;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[now]&gt;dep[ed])ed=now;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line">        <span class="keyword">if</span>(E[i].to==fa)<span class="keyword">continue</span>;</span><br><span class="line">        dep[E[i].to]=dep[now]+E[i].v;</span><br><span class="line">        <span class="built_in">dfs</span>(E[i].to,now);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">    dep[<span class="number">1</span>]=<span class="number">0</span>;<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> st=ed;</span><br><span class="line">    dep[ed]=<span class="number">0</span>;<span class="built_in">dfs</span>(ed,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> len=dep[ed];<span class="comment">//即为st-&gt;ed的路径长</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在这种情况下，是可以发现所有直径的中点重合。</p><p>证明很简单。设直径 $s_1\to t_1$ 的中点为 $a_1$，$s_2 \to t_2$ 的直径同。那么如果这两条直径中点不重合，一定能找到一条 $s_1\to a_1\to a_2\to t_2$ 或与其类似的路径。而 $dis_{a_1\to a_2}&gt;0$，故矛盾。</p><h3 id="一些题">一些题</h3><h4 id="模板题：SP1437">模板题：<a href="https://www.luogu.com.cn/problem/SP1437">SP1437</a></h4><p>上面已经讲清楚了，略。</p><h4 id="例题：P1099、P2491">例题：<a href="https://www.luogu.com.cn/problem/P1099">P1099</a>、<a href="https://www.luogu.com.cn/problem/P2491">P2491</a></h4><p>此处只讲 $O(n)$ 做法。</p><p>考虑偏心距性质，如果该路径不完全重合于直径，那么可以分割为一条完全重合于直径的路径和几条完全不重合于直径的路径。令该路径为 $a\to k\to b$（$k$ 在 $s\to t$ 上），那么有 $dis_{k\to t}&gt;dis_{b\to farthest_b}$，故如果该路径完全重合于直径一定不劣。</p><p>那么可以每次尺取一条完全重合于直径的路径，用一种类似于滑动窗口算法的方式枚举，然后统计直径两端偏心距的答案。</p><p>但是最大值不一定能在直径两端取到，就比如说长度的限制就等于直径的长度的时候。那么我们可以发现，每种情况的答案都<strong>至少</strong>统计了旁边子树的答案。由于直径的长度相对最长，所以这些未被选中路径的子树的答案最多也不会超过该处直径到某一端点的长度。所以这部分要取最大，以免错过正确答案。</p><h3 id="由树的直径而来—树的中心">由树的直径而来—树的中心</h3><p>顾名思义，树的中心就是树的最中间的点，它被定义为离树的直径的中点最靠近的点，可以有多个。</p><p>求法与直径类似，就是还需要再遍历一边直径来求中心。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">    fa[now]=...;<span class="comment">//记边</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">    fa[ed]=<span class="number">0</span>;<span class="built_in">dfs</span>(ed,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> dest=ed,nowtot=<span class="number">0</span>,_1,_2,mid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=dest;i;i=E[fa[i]].to)&#123;</span><br><span class="line">        nowtot+=E[fa[i]].v;</span><br><span class="line">        <span class="keyword">if</span>(nowtot&gt;dep[ed]/<span class="number">2</span>)&#123;</span><br><span class="line">            _1=i;</span><br><span class="line">            _2=E[fa[i]].to;</span><br><span class="line">            <span class="keyword">if</span>(nowtot-dep[ed]/<span class="number">2</span>&gt;=dep[ed]/<span class="number">2</span>+E[fa[i]].v-nowtot)mid=_1;</span><br><span class="line">            <span class="keyword">else</span> mid=_2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><s>（上面的代码应该是对的吧，不知道，没测过）</s></p><h3 id="又是一些题">又是一些题</h3><h4 id="例题：P5536">例题：<a href="https://www.luogu.com.cn/problem/P5536">P5536</a></h4><p>感觉比上面的那个紫题还难。</p><p>考虑当 $k=1$ 的时候，为了平均，必然选到树的中心。</p><p>当 $k&gt;1$ 时，首先，仍然要选树的中心。然后仍然为了平均，就以中心为根，贪心选择当前距离最远的叶子最远的那个路径，即 $maxdep[now]-dep[now]$ 最大。排序选第 $k+1$ 大即可，因为这个数最大的存的就是一条链上最多的节点数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(dd+<span class="number">1</span>,dd+n+<span class="number">1</span>,<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">dd[n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">cout&lt;&lt;dd[k+<span class="number">1</span>]+<span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="例题：P3761">例题：<a href="https://www.luogu.com.cn/problem/P3761">P3761</a></h4><p>没写 $O(n^2)$ 的算法，但是看起来好写多了。</p><ul class="lvl-0"><li class="lvl-2"><p>算法一：时间复杂度 $O(n^2)$</p></li></ul><p>考虑枚举断边 $(u,v)$，这个时候已经是 $O(n)$ 的了，于是考虑在分离的两个连通块里选择哪两个点连接起来更优。由于此时要保证两连通块里的距离保持平均从而距离最短，那么选择这两个联通块里的中心一定不劣。</p><p>每次暴力求中心即可。</p><ul class="lvl-0"><li class="lvl-2"><p>算法二：时间复杂度 $O(nL)\ (L=\Theta (n),L\leq n)$</p></li></ul><p>考虑优化。</p><p>考虑断边可能存在的位置。如果断边不在直径上，那么有一连通块内必然存在原树的直径的长，和原树的答案一样，则一定不优。所以断边在直径上一定不劣。</p><p>所以每次在直径上枚举断边，暴力跑中心即可。</p><p>虽然直径的长度 $L$ 与 $n$ 同阶，但是速度还是显著的比算法一快。</p><ul class="lvl-0"><li class="lvl-2"><p>算法三：时间复杂度 $O(n)$</p></li></ul><p>继续优化。</p><p>考虑在枚举断边的时候，是重复 dfs 了很多东西的。由 <code>树上任意一点为起点的最长路径的终点一定是直径的端点</code> 可知，只需在直径两端点各进行一次 dfs 即可求解。</p><p>发现其实每次的答案的贡献来自于两连通块的直径或两连通块的半径和加上原边边权，统计一下即可。</p><p>剩下的最后一个问题是定中心的问题，其实很好解决。考虑有顺序地断直径上的边，必定有一个连通块的直径单调递减，另一个单调递增。那么维护中心就很简单了，按单调性在直径上跳即可。</p><p>算法三好难写啊 qwq，就写算法二吧。</p><p>然后我的半径求法跑得居然比树形 dp 快，但是容易写错。</p><h4 id="例题：P3629">例题：<a href="https://www.luogu.com.cn/problem/P3629">P3629</a></h4><p>感觉无论是代码实现还是理解都很简单，但是不知道为什么没几个人做。</p><p>考虑 $k=0$ 时，因为树上每个点到另一个点的路径均只有一条路径，不能形成任何欧拉回路，所以每条边都需要走两次，$ans=2\times (n-1)$。</p><p>那么 $k=1$ 时，为了答案最优，我们就要连出最大的一条欧拉回路，由于树的形态，这条回路只能是一个环。那么显然，最大的环出自于连接直径的两端点，此时记直径长度为 $L_1$，可以简单推得 $ans=2\times (n-1)-L_1+1=2\times n-L_1-1$。</p><p>$k=2$ 时，容易想到用缩点的办法把刚刚的环缩成一个点再跑一次直径，但是如果这两条路径有重叠部分那就不好玩了。所以可以使用类似于网络流中退流的办法，把相交的两个路径转换为不交的两个路径，即把刚刚的直径的边权置为 $-1$，然后再跑一遍直径即可。注意此处只能用树形 dp 求解，因为有负边权的边。</p><p>此时 $ans=2\times n -L_1-L_2$。</p><p>时间复杂度 $O(n)$。</p><h2 id="树的重心">树的重心</h2><h3 id="定义">定义</h3><p>对于无根树，对于所有点为根的情况，拥有最小的点最多的子树的根称为该树的重心。</p><p>有点抽象？</p><p>看看 Mea 的 pdf 吧：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/mut8mw4c.png" alt=""></p><h3 id="性质">性质</h3><p><strong>当且仅当</strong>以重心为根时，所有子树的大小不超过整棵树的一半。</p><p>怎么证？</p><p>首先，如果重心的某棵子树大小超过了整棵树的一半，那么如果重心向那棵子树转移一定不劣。</p><p>相似地，如果重心的某棵子树大小没有超过整棵树的一半，那么重心向那棵子树转移一定不优。</p><p>所以最优的情况下，重心的所有子树大小都没有超过整棵树的一半，此时重心往哪里转移都是不优的。</p><p>证毕。</p><h3 id="一些题-2">一些题</h3><h4 id="模板题：P1363">模板题：<a href="https://www.luogu.com.cn/problem/P1363">P1363</a></h4><p>模板，但是这道题点也带权。</p><p>原题是求一个点使得所有人到这个点的距离和最小。</p><p>考虑这个点的性质。假设这个点为重心，那么可以发现无论往哪个方向，变化量是非负的，因为 <code>当且仅当以重心为根时，所有子树的大小不超过整棵树的一半</code>。</p><p>所以<strong>重心的第二条性质</strong>出来了：树上所有的点到某个点的距离和<strong>当且仅当</strong>这个点取到重心时最小，如果有多个重心，那么取这些重心的距离和相等。</p><p>因此这道题就是求树的带权重心。</p><p>好像有两种算法求重心。</p><ul class="lvl-0"><li class="lvl-2"><p>算法一：依据定义，计算子树最大值。</p></li></ul><p>不知道是不是适用于求带权重心时。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> w[N],siz[N],maxw[N],zx[<span class="number">2</span>];<span class="comment">//一个树好像最多有2个重心</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    siz[now]=w[now];</span><br><span class="line">    maxw[now]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line">        <span class="keyword">if</span>(E[i].to==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(E[i].to,now);</span><br><span class="line">        siz[now]+=siz[E[i].to];</span><br><span class="line">        maxw[now]=<span class="built_in">max</span>(maxw[now],siz[E[i].to]);</span><br><span class="line">    &#125;</span><br><span class="line">    maxw[now]=<span class="built_in">max</span>(maxw[now],sum-siz[now]);</span><br><span class="line">    <span class="keyword">if</span>(maxw[now]&lt;=sum/<span class="number">2</span>)&#123;<span class="comment">//sum是点权和，无权时就是n</span></span><br><span class="line">        zx[zx[<span class="number">0</span>]!=<span class="number">0</span>]=now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>算法二：换根 dp 求树上所有点到某个点的距离和最小的点。</p></li></ul><p>考虑先预处理出一个点到其他点的距离和，记 $f_u$ 是距离和，$size_u$ 是之前算出来了的子树大小，然后推出换根 dp 式子：<br>$$<br>\begin{aligned}<br>f_v&amp;=f_u+(n-size_v)\times dis_{u\to v}-size_v\times dis_{u\to v}\&amp;=f_u+(n-size_v\times 2)\times dis_{u\to v}<br>\end{aligned}<br>$$</p><p>不要以为只用判断 $n-size_v\times 2$ 的正负性就能转移了，$dis_{u\to v}$ 的值不一样还是白搭，还是要算出所有点的 $f$ 值再做比较找找最大的那个点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> f[N],dep[N],w[N],siz[N],res,zx;<span class="comment">//这里就只写一个重心的情况了，本质相同</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> fa)</span></span>&#123;<span class="comment">//预处理</span></span><br><span class="line">    siz[now]=w[now];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line">        <span class="keyword">if</span>(E[i].to==fa)<span class="keyword">continue</span>;</span><br><span class="line">        dep[E[i].to]=dep[now]+E[i].v;</span><br><span class="line">        <span class="built_in">dfs</span>(E[i].to,now);</span><br><span class="line">        siz[now]+=siz[E[i].to];</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">1</span>]+=dep[now]*w[now];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line">        <span class="keyword">if</span>(E[i].to==fa)<span class="keyword">continue</span>;</span><br><span class="line">        f[E[i].to]=f[now]+(sum-siz[E[i].to]*<span class="number">2</span>)*E[i].v;<span class="comment">//sum是所有点点权之和</span></span><br><span class="line">        <span class="built_in">dfs2</span>(E[i].to,now);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f[now]&lt;res)&#123;</span><br><span class="line">        res=f[now];</span><br><span class="line">        zx=now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例题（自己找的）：CF1406C">例题（自己找的）：<a href="https://www.luogu.com.cn/problem/CF1406C">CF1406C</a></h4><p>考虑只有一个重心时，随便选定一条边，删了之后然后再加回来就行了。</p><p>有两个重心时，考虑这两个重心的相对位置：</p><p>这里引用一下某洛谷大佬的图：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/mui5q3yu.png" alt=""></p><p>如果有两个重心 $1$ 和 $2$，则这两个重心必然直接相连，否则往这两个重心中间的点转移一定不劣。</p><p>根据重心的性质，假如说 $2$ 号重心为根时的最大子树为 $5$ 号或者 $6$ 号子树，那么 $1$ 号为根时最大子树一定大于 $2$ 号的最大子树，矛盾，所以 $2$ 号重心的最大子树是 $1$ 号节点为根的子树，$1$ 号节点同理。</p><p>所以我们可以推出 $3$ 号子树与 $4$ 号子树的大小和等于 $5$ 号子树与 $6$ 号子树的大小和。</p><p>怎么破坏这种平衡？</p><p>那就是随便选一个 $3$ 号子树或者 $4$ 号子树的叶子连到 $2$ 号节点即可。</p><h4 id="例题（自己找的）：CF708C">例题（自己找的）：<a href="https://www.luogu.com.cn/problem/CF780C">CF708C</a></h4><hr><p>鲜花：我当时把这个当成了 CF780C，然后…</p><p>首先猜结论：以树的重心为根然后染色一定最优。</p><p>但是后面发现，好像在哪里染都是一样的。/jk</p><p>为什么 OI Wiki 上要用这个做例题啊…/fn</p><p>好好好，为了练习还是写一遍树的重心吧…</p><p>…？？？看错题号了？？？</p><p>好好好，不写重心了，直接一遍 DFS！</p><hr><p>考虑什么样的点改造之后有可能成为重心。题中提示重心子树大小不超过 $\frac{n}{2}$，那么这种点要么是原来就是重心，要么就是有且仅有一个子树的子树分离之后原子树和分离后的子树大小不大于 $\frac{n}{2}$。</p><p>由于是我最不擅长的 dp，所以只能看题解。</p><p>然而看了题解还是不会，看来得要补补 dp 了，先鸽。</p><h3 id="悲报">悲报</h3><p>Mea 讲的重心的题一个也不会做。</p><h2 id="遍历序与-LCA">遍历序与 LCA</h2><p>直接抛题了。</p><h3 id="P2680-运输计划">P2680 运输计划</h3><p>树上差分的题。</p><p>写完这道题就写树上差分的笔记。</p><p>考虑求最大值最小，想到二分答案，这样把求解变成了判定。</p><p>每次树上差分（边差分）出链长大于当前二分答案的链长的重叠部分，再在这些重叠部分处查找有没有一条边的边权大于最长链与该二分答案出的链的长度差即可。</p><p>显然，求链长需要预处理出 $LCA$ ，不预处理 $LCA$ 时间复杂度为 $O(n\log^2n)$，应该能勉强卡过。</p><p>好好好，注意常数！理论时间复杂度 $O(n\log n)$。</p><p>然后注意用 <code>unordered_map</code> 会喜提 95pts。</p><h3 id="树上差分">树上差分</h3><p>树上差分就是将信息转化成差分的形式记录，最后进行一遍前缀和得到原数组。</p><p>有两种基本形式：边差分与点差分。</p><p>边差分：$f_u$ 与 $f_v$ 加上 $v$，然后 $f_{lca(u,v)}$ 减去 $2\times v$。</p><p>点差分：$f_u$ 与 $f_v$ 加上 $v$，然后 $f_{lca(u,v)}$ 减去 $v$，$f_{fa(lca(u,v))}$ 减去 $v$。</p><h3 id="P3398-仓鼠找-sugar">P3398 仓鼠找 sugar</h3><p>考虑两条路径相交时的性质。</p><p>此时，其中一条路径的起点和终点的 $LCA$，必定在另一条路径上。</p><p>如何判断点是否在路径上？</p><p>一种简单的方法是：利用路径长判断。如果判断 $k$ 是否在路径 $a\to b$ 上，只需判断 $dis_{a\to k}+dis_{k\to b}=dis_{a\to b}$。</p><p>怪不得只有绿，但是我没看出来怎么做。/kk</p><p>注意要要判断两次，即 $a,b$ 的 $LCA$ 判断是否在 $c\to d$ 上，$c,d$ 的 $LCA$ 同，任意一个满足即可。</p><h3 id="P1600-天天爱跑步">P1600 天天爱跑步</h3><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/01j3zhwl.png" alt=""></p><p><s>（好恐怖）</s></p><p>喜报，作者有些看不懂，所以这应该是最后一道专属 $LCA$ 板块的题了。</p><p>喜报，作者看了一个下午，才有点起色…</p><p>终于看懂了，之前是我傻逼了。</p><p>考虑将一段路径转化成两段，一段向上走，一段向下走，用符号语言理解：<br>$$<br>s\to t \Rightarrow s\to son(LCA_{s,t})+LCA_{s,t}\to t<br>$$<br>那么就可以分两段处理了。</p><p>首先，对于每一个点 $s$ 都有观察时的时间 $w_s$，因为在上面我们已经将一条路径分成了只上升与只下降两部分，那么我们就可以只维护两个桶：对于向上走，维护当前点被多少路径覆盖；和对于向下走，维护终点深度减去当前链长度的桶（也就是把链拉直了）。</p><p>这道题感觉不是差分，就是一个桶维护加生存周期标记。所以不要看代码没有差分的部分就看不懂了。</p><p>统计答案时，统计桶的增量即可；记录标记 $-1$ 时，记得要记录到当前路径端点的父亲，否则会少统计一个。</p><p>注意在 $-1,+1$ 操作时顺序要与 dfs 与统计答案的顺序一样。</p><p>写完之后感觉不看看就又会理解错…/kk</p><h2 id="终于完结一个版块了！！！">终于完结一个版块了！！！</h2><h1>树链剖分</h1><p>分为重链剖分，长链剖分，和实链剖分（不写，填 LCT 的坑的时候写在 LCT 那里）。</p><h2 id="重链剖分">重链剖分</h2><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/dpg7y4id.png" alt=""></p><p>浅浅一眼，作用很多。</p><h3 id="一些基础定义">一些基础定义</h3><p>定义<strong>重子节点</strong>为一个节点子树最大的儿子，其余儿子为<strong>轻子节点</strong>。</p><p>定义<strong>重边</strong>为父亲连向<strong>自己的重子节点</strong>的边，其余父亲向儿子连的边叫<strong>轻边</strong>。</p><p>定义几条<strong>重边</strong>首尾衔接起来的一条链为<strong>重链</strong>。<s>（出生登场）</s></p><p>显然，如果把单个节点也看成一条重链的话，整个树会被<strong>剖分</strong>成很多条重链。</p><p>OI Wiki 上放了图，那我也放一张：</p><p><img src="https://oi-wiki.org/graph/images/hld.png" alt=""></p><p><s>（一样的图）</s></p><h3 id="实现">实现</h3><p>两次 dfs 即可。</p><p>第一次预处理出重子节点，深度，子树大小和父节点。</p><p>第二次求 dfs 序（dfn 数组），每个节点的链顶，和 dfs 序对应的节点（rk 数组）。</p><ul class="lvl-0"><li class="lvl-2"><p>eg</p></li></ul><p>如果 $dfn[2]=3$，代表 $2$ 号节点第 $3$ 次被访问到。</p><p>而 $rk[3]=2$，代表第 $3$ 次访问到的节点为 $2$ 号节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里作者鸽了，明天再学，咕咕咕。</span><br></pre></td></tr></table></figure><p>实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dep[N],siz[N],fa[N],hs[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">    fa[now]=f;</span><br><span class="line">    siz[now]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line">        <span class="keyword">if</span>(E[i].to==f)<span class="keyword">continue</span>;</span><br><span class="line">        dep[E[i].to]=dep[now]+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(E[i].to,now);</span><br><span class="line">        siz[now]+=siz[E[i].to];</span><br><span class="line">        <span class="keyword">if</span>(siz[hs[now]]&lt;siz[E[i].to])hs[now]=E[i].to;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> rk[N],dfn[N],dfncnt,ltop[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> top)</span></span>&#123;</span><br><span class="line">    dfn[now]=++dfncnt;</span><br><span class="line">    rk[dfncnt]=now;</span><br><span class="line">    ltop[now]=top;</span><br><span class="line">    <span class="keyword">if</span>(!hs[now])<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(hs[now],top);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line">        <span class="keyword">if</span>(E[i].to==fa[now]||E[i].to==hs[now])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(E[i].to,E[i].to);<span class="comment">//注意此处不要和第一个dfs写成一样的了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于是现写的代码，也一样地不知道代码是否正确，但是应该是对的？</p><p><strong>即时UPD：经测试，有误，不过已经改回来了，并且加了注释提醒自己。</strong></p><h3 id="性质-2">性质</h3><p>最本质的一条：树上任意节点都<strong>只会被一条重链覆盖</strong>。</p><p>由于剖分时是按照<strong>重边优先遍历</strong>来遍历的，所以 dfn 序也很特殊，按照重链的剖分顺序并且每个重链内部从上到下遍历，会发现这个顺序和 dfn 序是一致的。（可能没讲太清楚…）</p><p>还有一条：由于剖分时<strong>重子节点</strong>的子树大小最大，所以每向下走一条<strong>轻边</strong>时，子树大小<strong>至少减半</strong>。</p><p>所以这条性质证明了树剖求 $LCA$ 的复杂度：如果把一条路径拆成起点与终点的 $LCA$ 向下走走到起点和终点两条路径，那么根据这两条性质，因为 $LCA$ 的子树大小与 $n$ 同阶，所以最多经过 $O(\log n)$ 条重链，复杂度就有保证了。</p><h3 id="常见应用">常见应用</h3><p>多用于维护信息和平均比倍增快地求 $LCA$。</p><p><s>（想在写板子题之前找点hack数据，没找到，太失败了）</s></p><h4 id="用于求-LCA">用于求 LCA</h4><p>自认为是下面维护路径信息的基础。</p><p>每次根据重链的顶端大小情况跳重链即可。上面也已经有证明，时间复杂度 $O(\log n)$。</p><p>易错点已在代码中标出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//怎么又是现写代码啊</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(ltop[u]!=ltop[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[ltop[u]]&gt;dep[ltop[v]]<span class="comment">/*注意是谁与谁比较*/</span>)u=fa[ltop[u]];</span><br><span class="line">        <span class="keyword">else</span> v=fa[ltop[v]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ((dep[u]&gt;dep[v])?v:u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么是 <code>dep[ltop[u]]&gt;dep[ltop[v]]</code> 呢？考虑这是跳重链，所以要比较重链的顶端。</p><h4 id="用于维护路径信息（P2590）">用于维护路径信息（P2590）</h4><p>这部分应该最后会贴一个完整代码。</p><p>维护路径信息指的是如维护路径点权最大值，点权和，修改点权等等。</p><p>显然，树剖强悍的 $O(\log n)$ 求 $LCA$ 和一条重链上 dfn 序连续的性质让树剖可以在 $O(\log^2n)$ 的时间内解决一个询问。</p><p>考虑这样一个问题：</p><p>$n$ 个节点的树，$q$ 次询问，询问内容：</p><ol><li class="lvl-3"><p>求 $u\to v$ 路径上点权最大值。</p></li><li class="lvl-3"><p>求 $u\to v$ 路径上点权和。</p></li><li class="lvl-3"><p>修改点 $u$ 的点权为 $v$。</p></li></ol><p>（其实这里是可以考路径修改的，这个时候的线段树就要有标记这种东西了（悲））</p><p>依据<strong>一条重链上 dfn 序连续</strong>的性质，我们可以对所有节点<strong>按 dfn 序</strong>建一棵线段树，而不是对每一条重链建一棵线段树（不然不好控制空间大小）。</p><p>首先树剖后，注意建树的过程（$rk$ 数组终于用上了）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//好好好，又是现写的</span></span><br><span class="line"><span class="type">int</span> segtm[<span class="number">1000001</span>],segts[<span class="number">1000001</span>];<span class="comment">//...m维护点权最大值，...s维护点权和</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line">    segtm[now]=<span class="built_in">max</span>(segtm[now&lt;&lt;<span class="number">1</span>],segtm[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">    segts[now]=segts[now&lt;&lt;<span class="number">1</span>]+segts[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bulid</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        segtm[now]=w[rk[l]];<span class="comment">//rk数组记录的是当前dfn序所对应的真实节点</span></span><br><span class="line">        <span class="comment">//由于线段树是把dfn序作为下标建的，所以这里要把dfn序转化为真实的点编号来找到原来的点权</span></span><br><span class="line">        segts[now]=w[rk[l]];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">bulid</span>(now&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">bulid</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">pushup</span>(now);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后询问区间最大值，询问区间和等正常敲线段树板子即可。</p><p>现在重头戏来了：融合求 $LCA$ 和线段树询问来完成路径上的询问。</p><p>注意到线段树是<strong>按照 dfn 序</strong>建的，所以对于每一个求 $LCA$ 时跳到的重链，都可以直接用线段树直接区间询问该重链上形成贡献的部分。</p><p>那么代码就和求 $LCA$ 时的代码差不多了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//应该是这种应用最后一次现写代码了，累死</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmax</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> nowmax=<span class="number">-1e9</span>;<span class="comment">//注意边权有负，初始值要赋为绝对值很大的负数</span></span><br><span class="line">    <span class="keyword">while</span>(ltop[u]!=ltop[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[ltop[u]]&gt;dep[ltop[v]])&#123;</span><br><span class="line">            nowmax=<span class="built_in">max</span>(nowmax,<span class="built_in">getmax</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[ltop[u]],dfn[u]));<span class="comment">//注意l和r给的大小顺序</span></span><br><span class="line">            u=fa[ltop[u]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            nowmax=<span class="built_in">max</span>(nowmax,<span class="built_in">getmax</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[ltop[v]],dfn[v]));</span><br><span class="line">            v=fa[ltop[v]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不像求LCA，就算已经在一条重链上，这里还要加上该条重链的贡献</span></span><br><span class="line">    <span class="keyword">if</span>(dep[u]&gt;dep[v])<span class="built_in">swap</span>(u,v);<span class="comment">//注意统一深度大小情况，然后不要在这里把顺序搞反了，是dep从小到大（树上从上到下）</span></span><br><span class="line">    nowmax=<span class="built_in">max</span>(nowmax,<span class="built_in">getmax</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[u],dfn[v]));</span><br><span class="line">    <span class="keyword">return</span> nowmax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他询问或修改同。</p><p>贴个完整代码，把重剖学完就要鸽一鸽树论了，咕咕。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span>&#123;</span><br><span class="line"><span class="type">int</span> to,link;</span><br><span class="line">&#125;E[<span class="number">200002</span>];</span><br><span class="line"><span class="type">int</span> segtm[<span class="number">1000010</span>],segts[<span class="number">1000010</span>],head[<span class="number">100001</span>],tot=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addE</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">E[++tot].link=head[u];</span><br><span class="line">E[tot].to=v;</span><br><span class="line">head[u]=tot;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dep[<span class="number">100001</span>],siz[<span class="number">100001</span>],hs[<span class="number">100001</span>],fa[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">fa[now]=f;</span><br><span class="line">siz[now]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==f)<span class="keyword">continue</span>;</span><br><span class="line">dep[E[i].to]=dep[now]+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs1</span>(E[i].to,now);</span><br><span class="line">siz[now]+=siz[E[i].to];</span><br><span class="line"><span class="keyword">if</span>(siz[hs[now]]&lt;siz[E[i].to])hs[now]=E[i].to;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dfn[<span class="number">100001</span>],rk[<span class="number">100001</span>],dfncnt,ltop[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> top)</span></span>&#123;</span><br><span class="line">ltop[now]=top;</span><br><span class="line">dfn[now]=++dfncnt;</span><br><span class="line">rk[dfncnt]=now;</span><br><span class="line"><span class="keyword">if</span>(!hs[now])<span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(hs[now],top);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==fa[now]||E[i].to==hs[now])<span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(E[i].to,E[i].to);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> w[<span class="number">100001</span>],n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line">segtm[now]=<span class="built_in">max</span>(segtm[now&lt;&lt;<span class="number">1</span>],segtm[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">segts[now]=segts[now&lt;&lt;<span class="number">1</span>]+segts[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bulid</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">segtm[now]=w[rk[l]];<span class="comment">//着重注意</span></span><br><span class="line">segts[now]=w[rk[l]];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">bulid</span>(now&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line"><span class="built_in">bulid</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">pushup</span>(now);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> q,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">segtm[now]=v;</span><br><span class="line">segts[now]=v;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(q&gt;mid)<span class="built_in">upd</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,q,v);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">upd</span>(now&lt;&lt;<span class="number">1</span>,l,mid,q,v);</span><br><span class="line"><span class="built_in">pushup</span>(now);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getmax</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> sl,<span class="type">int</span> sr)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> res=<span class="number">-1e9</span>;</span><br><span class="line"><span class="keyword">if</span>(l==sl&amp;&amp;r==sr)<span class="keyword">return</span> segtm[now];</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(sl&lt;=mid)res=<span class="built_in">max</span>(res,<span class="built_in">getmax</span>(now&lt;&lt;<span class="number">1</span>,l,mid,sl,<span class="built_in">min</span>(sr,mid)));</span><br><span class="line"><span class="keyword">if</span>(sr&gt;mid)res=<span class="built_in">max</span>(res,<span class="built_in">getmax</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,<span class="built_in">max</span>(sl,mid+<span class="number">1</span>),sr));</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getsum</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> sl,<span class="type">int</span> sr)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(sl==l&amp;&amp;r==sr)<span class="keyword">return</span> segts[now];</span><br><span class="line"><span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(sl&lt;=mid)res+=<span class="built_in">getsum</span>(now&lt;&lt;<span class="number">1</span>,l,mid,sl,<span class="built_in">min</span>(mid,sr));</span><br><span class="line"><span class="keyword">if</span>(sr&gt;mid)res+=<span class="built_in">getsum</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,<span class="built_in">max</span>(sl,mid+<span class="number">1</span>),sr);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qsum</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> nowsum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(ltop[u]!=ltop[v])&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[ltop[u]]&gt;dep[ltop[v]])&#123;</span><br><span class="line">nowsum+=<span class="built_in">getsum</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[ltop[u]],dfn[u]);</span><br><span class="line">u=fa[ltop[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">nowsum+=<span class="built_in">getsum</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[ltop[v]],dfn[v]);</span><br><span class="line">v=fa[ltop[v]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[u]&lt;dep[v])<span class="built_in">swap</span>(u,v);</span><br><span class="line">nowsum+=<span class="built_in">getsum</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[v],dfn[u]);</span><br><span class="line"><span class="keyword">return</span> nowsum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmax</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> nowmax=<span class="number">-1e9</span>;</span><br><span class="line"><span class="keyword">while</span>(ltop[u]!=ltop[v])&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[ltop[u]]&gt;dep[ltop[v]])&#123;</span><br><span class="line">nowmax=<span class="built_in">max</span>(nowmax,<span class="built_in">getmax</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[ltop[u]],dfn[u]));</span><br><span class="line">u=fa[ltop[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">nowmax=<span class="built_in">max</span>(nowmax,<span class="built_in">getmax</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[ltop[v]],dfn[v]));</span><br><span class="line">v=fa[ltop[v]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[u]&lt;dep[v])<span class="built_in">swap</span>(u,v);</span><br><span class="line">nowmax=<span class="built_in">max</span>(nowmax,<span class="built_in">getmax</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[v],dfn[u]));</span><br><span class="line"><span class="keyword">return</span> nowmax;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="built_in">addE</span>(x,y);</span><br><span class="line"><span class="built_in">addE</span>(y,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;w[i];</span><br><span class="line"><span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">bulid</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">string s;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line">cin&gt;&gt;T;</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line">s=<span class="string">&quot;&quot;</span>;</span><br><span class="line">cin&gt;&gt;s&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="keyword">if</span>(s[<span class="number">1</span>]==<span class="string">&#x27;M&#x27;</span>)cout&lt;&lt;<span class="built_in">qmax</span>(x,y)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s[<span class="number">1</span>]==<span class="string">&#x27;S&#x27;</span>)cout&lt;&lt;<span class="built_in">qsum</span>(x,y)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">upd</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[x],y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用于维护子树信息（P3384）">用于维护子树信息（P3384）</h4><p>由于这道题与上道题的询问更多样，并且这道题线段树我写挂了 $2$ 次，所以还是把这道题的完整代码贴上来。</p><p>考虑如何维护子树信息。因为 dfs 求 dfn 序的时候，仍然满足进入一棵子树后，遍历完该子树的所有节点才会回溯出来，所以<strong>一棵子树内的 dfn 序连续</strong>。</p><p>那么这就好维护了，OI Wiki 里面写的甚至还要维护一个什么 bottom 数组，实际上这个 dfn 序是与子树大小有关的，直接用 siz 数组转化为区间询问即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//少现写代码，快乐你我他</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updsubt</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="built_in">upd</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[u],dfn[u]+siz[u]<span class="number">-1</span>,w);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qsumsubt</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getsum</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[u],dfn[u]+siz[u]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意右边界的取值即可。</p><p>完整代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span>&#123;</span><br><span class="line"><span class="type">int</span> to,link;</span><br><span class="line">&#125;E[<span class="number">200003</span>];</span><br><span class="line"><span class="type">int</span> head[<span class="number">100001</span>],tot=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addE</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">E[++tot].link=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">E[tot].to=v;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> siz[<span class="number">100001</span>],dep[<span class="number">100001</span>],hson[<span class="number">100001</span>],fa[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">fa[now]=f;</span><br><span class="line">siz[now]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==f)<span class="keyword">continue</span>;</span><br><span class="line">dep[E[i].to]=dep[now]+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs1</span>(E[i].to,now);</span><br><span class="line">siz[now]+=siz[E[i].to];</span><br><span class="line"><span class="keyword">if</span>(siz[E[i].to]&gt;siz[hson[now]])hson[now]=E[i].to;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dfn[<span class="number">100001</span>],rk[<span class="number">100001</span>],ltop[<span class="number">100001</span>],dfncnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> top)</span></span>&#123;</span><br><span class="line">dfn[now]=++dfncnt;</span><br><span class="line">rk[dfncnt]=now;</span><br><span class="line">ltop[now]=top;</span><br><span class="line"><span class="keyword">if</span>(!hson[now])<span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(hson[now],top);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==fa[now]||E[i].to==hson[now])<span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(E[i].to,E[i].to);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> segts[<span class="number">400001</span>],lazy[<span class="number">400001</span>],w[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="comment">//if(l==r)return;</span></span><br><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">segts[now&lt;&lt;<span class="number">1</span>]+=(mid-l+<span class="number">1</span>)*lazy[now];</span><br><span class="line">segts[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=(r-mid)*lazy[now];</span><br><span class="line">lazy[now&lt;&lt;<span class="number">1</span>]+=lazy[now];</span><br><span class="line">lazy[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=lazy[now];</span><br><span class="line">lazy[now]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line">segts[now]=segts[now&lt;&lt;<span class="number">1</span>]+segts[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> sl,<span class="type">int</span> sr,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==sl&amp;&amp;r==sr)&#123;</span><br><span class="line">segts[now]+=v*(r-l+<span class="number">1</span>);</span><br><span class="line">lazy[now]+=v;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushdown</span>(now,l,r);</span><br><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(sl&lt;=mid)<span class="built_in">upd</span>(now&lt;&lt;<span class="number">1</span>,l,mid,sl,<span class="built_in">min</span>(mid,sr),v);</span><br><span class="line"><span class="keyword">if</span>(sr&gt;mid)<span class="built_in">upd</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,<span class="built_in">max</span>(sl,mid+<span class="number">1</span>),sr,v);</span><br><span class="line"><span class="built_in">pushup</span>(now);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getsum</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> sl,<span class="type">int</span> sr)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==sl&amp;&amp;r==sr)<span class="keyword">return</span> segts[now];</span><br><span class="line"><span class="built_in">pushdown</span>(now,l,r);</span><br><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>,res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(sl&lt;=mid)res+=<span class="built_in">getsum</span>(now&lt;&lt;<span class="number">1</span>,l,mid,sl,<span class="built_in">min</span>(sr,mid));</span><br><span class="line"><span class="keyword">if</span>(sr&gt;mid)res+=<span class="built_in">getsum</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,<span class="built_in">max</span>(sl,mid+<span class="number">1</span>),sr);</span><br><span class="line"><span class="built_in">pushup</span>(now);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bulid</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">segts[now]=w[rk[l]];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">bulid</span>(now&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line"><span class="built_in">bulid</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">pushup</span>(now);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,s,p;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updsubt</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line"><span class="built_in">upd</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[u],dfn[u]+siz[u]<span class="number">-1</span>,w);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qsumsubt</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">getsum</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[u],dfn[u]+siz[u]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qsuml</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> nowsum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(ltop[u]!=ltop[v])&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[ltop[u]]&gt;dep[ltop[v]])&#123;</span><br><span class="line">nowsum+=<span class="built_in">getsum</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[ltop[u]],dfn[u]);</span><br><span class="line">u=fa[ltop[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">nowsum+=<span class="built_in">getsum</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[ltop[v]],dfn[v]);</span><br><span class="line">v=fa[ltop[v]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[u]&gt;dep[v])<span class="built_in">swap</span>(u,v);</span><br><span class="line">nowsum+=<span class="built_in">getsum</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[u],dfn[v]);</span><br><span class="line"><span class="keyword">return</span> nowsum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updl</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(ltop[u]!=ltop[v])&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[ltop[u]]&gt;dep[ltop[v]])&#123;</span><br><span class="line"><span class="built_in">upd</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[ltop[u]],dfn[u],w);</span><br><span class="line">u=fa[ltop[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">upd</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[ltop[v]],dfn[v],w);</span><br><span class="line">v=fa[ltop[v]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[u]&gt;dep[v])<span class="built_in">swap</span>(u,v);</span><br><span class="line"><span class="built_in">upd</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[u],dfn[v],w);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;p;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;w[i];</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="built_in">addE</span>(x,y);</span><br><span class="line"><span class="built_in">addE</span>(y,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs1</span>(s,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">dfs2</span>(s,s);</span><br><span class="line"><span class="built_in">bulid</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="type">int</span> op,z;</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line">cin&gt;&gt;op&gt;&gt;x;</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">cin&gt;&gt;y&gt;&gt;z;</span><br><span class="line"><span class="built_in">updl</span>(x,y,z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">cin&gt;&gt;y;</span><br><span class="line">cout&lt;&lt;<span class="built_in">qsuml</span>(x,y)%p&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">3</span>)&#123;</span><br><span class="line">cin&gt;&gt;y;</span><br><span class="line"><span class="built_in">updsubt</span>(x,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="built_in">qsumsubt</span>(x)%p&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一些非传统应用">一些非传统应用</h3><p>还有一道题就下班了，咕咕。</p><p>有些时候，重剖除了这些应用以外，还有一些不常见的应用。</p><p>由于作者只想写洛谷上的题，所以就有了：CF1174F。</p><p>其他题欢迎在评论区补充。</p><h4 id="交互-CF1174F">交互-CF1174F</h4><p>还好的一道题，但是记得 <code>cout.flush()</code>！</p><p>题目主要是想让你用 $2$ 种询问来确定一个点。</p><p>首先要确定这个点的深度，那么在 $1$ 号节点问路径距离即可。</p><p>考虑重链剖分每次跳一次轻边子树至少减半的性质，使用跳重链的方式保证能在 $36$ 次以内完成确定（$36\leq 2\times \log maxn$）。</p><p>那么如何跳重链呢？</p><p>考虑求路径长的公式：$dis_{u\to v}=dis_{u\to LCA(u,v)}+dis_{LCA(u,v)\to v}=dep_u+dep_v-2\times dep_{LCA(u,v)}$，可以发现如果我们能确定一个点到所求点的路径长，那么就一定能求出它们的 $LCA$ 深度，再用类似于 $k$ 级祖先的方式求出它们的 $LCA$ 之后就可以继续询问下一个轻子节点了。注意这里不排除它们的 $LCA$ 就是我们要求的点，所以要特判。</p><p>但是有了重链剖分，对于这道题谁会用树上 $k$ 级祖先这种东西啊。</p><p>考虑既然我们的目的是找到所求节点在这条重链上的哪个轻子节点的子树中，那么在剖分时记录重链长度，第一次直接询问重链最底部与所求点的路径长以求 $LCA$，再在 $LCA$ 处询问路径 $LCA\to x$ 上的下一个点即可。</p><p>迭代最多 $\log n$ 次即可求出该点。</p><p>放代码，下班！QwQ</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span>&#123;</span><br><span class="line"><span class="type">int</span> to,link;</span><br><span class="line">&#125;E[<span class="number">400004</span>];</span><br><span class="line"><span class="type">int</span> head[<span class="number">200001</span>],tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addE</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">E[++tot].to=v;</span><br><span class="line">E[tot].link=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> siz[<span class="number">200001</span>],dep[<span class="number">200001</span>],fa[<span class="number">200001</span>],hson[<span class="number">200001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">fa[now]=f;</span><br><span class="line">siz[now]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==f)<span class="keyword">continue</span>;</span><br><span class="line">dep[E[i].to]=dep[now]+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs1</span>(E[i].to,now);</span><br><span class="line">siz[now]+=siz[E[i].to];</span><br><span class="line"><span class="keyword">if</span>(siz[E[i].to]&gt;siz[hson[now]])hson[now]=E[i].to;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dfn[<span class="number">200001</span>],rk[<span class="number">200001</span>],dfncnt,ltop[<span class="number">200001</span>],lsiz[<span class="number">200001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> top)</span></span>&#123;</span><br><span class="line">dfn[now]=++dfncnt;</span><br><span class="line">rk[dfncnt]=now;</span><br><span class="line">ltop[now]=top;</span><br><span class="line">lsiz[top]++;</span><br><span class="line"><span class="keyword">if</span>(!hson[now])<span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(hson[now],top);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==fa[now]||E[i].to==hson[now])<span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(E[i].to,E[i].to);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//cin.tie(0);</span></span><br><span class="line"><span class="comment">//cout.tie(0);</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="built_in">addE</span>(x,y);</span><br><span class="line"><span class="built_in">addE</span>(y,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> no=<span class="number">1</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;d &quot;</span>&lt;&lt;<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line">cout.<span class="built_in">flush</span>();</span><br><span class="line"><span class="type">int</span> depx;</span><br><span class="line">cin&gt;&gt;depx;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;d &quot;</span>&lt;&lt;rk[dfn[no]+lsiz[no]<span class="number">-1</span>]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">cout.<span class="built_in">flush</span>();</span><br><span class="line"><span class="type">int</span> depno;</span><br><span class="line">cin&gt;&gt;depno;</span><br><span class="line"><span class="keyword">if</span>(depno==<span class="number">0</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;! &quot;</span>&lt;&lt;rk[dfn[no]+lsiz[no]<span class="number">-1</span>];</span><br><span class="line">cout.<span class="built_in">flush</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> deplca=(dep[rk[dfn[no]+lsiz[no]<span class="number">-1</span>]]-depno+depx)/<span class="number">2</span>;</span><br><span class="line">no=rk[dfn[no]+lsiz[no]<span class="number">-1</span>-dep[rk[dfn[no]+lsiz[no]<span class="number">-1</span>]]+deplca];</span><br><span class="line"><span class="keyword">if</span>(dep[no]==depx)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;! &quot;</span>&lt;&lt;no&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">cout.<span class="built_in">flush</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;s &quot;</span>&lt;&lt;no&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">cout.<span class="built_in">flush</span>();</span><br><span class="line">cin&gt;&gt;no;</span><br><span class="line"><span class="keyword">if</span>(dep[no]==depx)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;! &quot;</span>&lt;&lt;no&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">cout.<span class="built_in">flush</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树上启发式合并">树上启发式合并</h2><p>鸽…咕咕咕…</p><p>然后作者回来了。</p><p>树上启发式合并的思想很精妙，感觉和人类智慧乱搞算法有的一拼。</p><p>考虑随便抛出一棵树，假设我们要数树上每个点子树的颜色：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/gp6q038f.png" alt=""></p><p>先不管颜色是什么，考虑如何优化 $O(n^2)$ 的暴力统计。</p><p>由于每次我们都要逐一求颜色个数并清空桶，我们可以利用<strong>继承</strong>的思想来优化，也就是把该节点花时间最多的儿子向上继承显然最优，也就有了 <code>小的往大的合并</code> 这种俗语了。</p><p>就像上面的树，重边已用 <code>H</code> 标识标记。可以发现如果</p><p>对于 $2$ 号节点，显然 从 $7$ 号节点继承比从 $6$ 号节点继承优。</p><p>这样做的复杂度是 $O(n\log n)$ 的，可以感性理解一下，因为每次暴力算轻儿子，子树大小至少减半，对于所有轻儿子都是这样，所以是 $O(n\log n)$。</p><h3 id="例题：CF600E">例题：<a href="https://www.luogu.com.cn/problem/CF600E">CF600E</a></h3><p>典题。</p><p>首先使用树剖的 dfn 序。然后每次像启发式合并一样统计。</p><p>维护出现次数的桶，并且对每个出现次数维护和，当要删除贡献时，直接清零，注意清零的卡常即可。</p><p>（不然要被链卡到 $O(n^2)$）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: Lomsat gelral</span></span><br><span class="line"><span class="comment">// Contest: Luogu</span></span><br><span class="line"><span class="comment">// URL: https://www.luogu.com.cn/problem/CF600E</span></span><br><span class="line"><span class="comment">// Memory Limit: 250 MB</span></span><br><span class="line"><span class="comment">// Time Limit: 2000 ms</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Powered by CP Editor (https://cpeditor.org)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,c[<span class="number">100001</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; tag[<span class="number">100001</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"><span class="type">int</span> cnt[<span class="number">100001</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans[<span class="number">100001</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span>&#123;</span><br><span class="line"><span class="type">int</span> to,link;</span><br><span class="line">&#125;E[<span class="number">200001</span>];</span><br><span class="line"><span class="type">int</span> head[<span class="number">100001</span>],tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addE</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">E[++tot].link=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">E[tot].to=v;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dep[<span class="number">100001</span>],hson[<span class="number">100001</span>],fa[<span class="number">100001</span>],siz[<span class="number">100001</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> L[<span class="number">100001</span>],R[<span class="number">100001</span>],rk[<span class="number">100001</span>],dfncnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">fa[now]=f;</span><br><span class="line">siz[now]=<span class="number">1</span>;</span><br><span class="line">L[now]=++dfncnt;</span><br><span class="line">rk[dfncnt]=now;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==f)<span class="keyword">continue</span>;</span><br><span class="line">dep[E[i].to]=dep[now]+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs1</span>(E[i].to,now);</span><br><span class="line">siz[now]+=siz[E[i].to];</span><br><span class="line"><span class="keyword">if</span>(siz[E[i].to]&gt;siz[hson[now]])hson[now]=E[i].to;</span><br><span class="line">&#125;</span><br><span class="line">R[now]=dfncnt;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> maxx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> u=rk[id];</span><br><span class="line">cnt[c[u]]++;</span><br><span class="line">tag[cnt[c[u]]].<span class="built_in">push_back</span>(c[u]);<span class="comment">//由于maxx只能越加越多，所以不用删除前面加的c[u]</span></span><br><span class="line">sum[cnt[c[u]]]+=c[u];</span><br><span class="line">maxx=<span class="built_in">max</span>(cnt[c[u]],maxx);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> si=tag[<span class="number">1</span>].<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;si;i++)cnt[tag[<span class="number">1</span>][i]]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=maxx;i++)tag[i].<span class="built_in">clear</span>(),sum[i]=<span class="number">0</span>;</span><br><span class="line">maxx=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now,<span class="type">bool</span> fl=<span class="number">0</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==fa[now]||E[i].to==hson[now])<span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs</span>(E[i].to);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(hson[now])<span class="built_in">dfs</span>(hson[now],<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==fa[now]||E[i].to==hson[now])<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=L[E[i].to];k&lt;=R[E[i].to];k++)<span class="built_in">add</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout&lt;&lt;maxx&lt;&lt;&quot; &quot;&lt;&lt;now&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line"><span class="built_in">add</span>(L[now]);</span><br><span class="line">ans[now]=sum[maxx];</span><br><span class="line"><span class="keyword">if</span>(!fl)<span class="built_in">init</span>(now);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;c[i];</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)cin&gt;&gt;x&gt;&gt;y,<span class="built_in">addE</span>(x,y),<span class="built_in">addE</span>(y,x);</span><br><span class="line"><span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题：CF1709E">例题：<a href="https://www.luogu.com.cn/problem/CF1709E">CF1709E</a></h3><p>省流：别用什么 <code>set&lt;int&gt; a,b;  a=b;</code> 之类的赋值，会 T 飞！！！！用 <code>swap</code> ！！！</p><p>直接暴力维护取值集合。使用树上差分，设 $dis_u=w_1\oplus \cdots\oplus w_u$（路径异或和），那么 $dis_{u\to v}=dis_u\oplus dis_v\oplus w_{LCA(u,v)}$。</p><p>如果有 $dis_{u\to v}=0$，显然 $dis_u=dis_v\oplus w_{LCA(u,v)}$，用 <code>set</code> 或者 <code>unordered_set</code> 维护取值集合即可。如果有重复的，直接将该集合清空，然后答案加一。显然这样做是最优的，因为可以取 $LCA(u,v)$ 来赋值，可以赋一个什么 $2^{114514+u}$ 这种点权使异或和一定不为 $0$，那么赋值后可以使子树内完全符合条件，还可以防止子树内的点和子树外的点的路径形成不合法的情况。</p><p>注意 <code>unordered_set</code> 的空间和省流即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span>&#123;</span><br><span class="line"><span class="type">int</span> to,link;</span><br><span class="line">&#125;E[<span class="number">400001</span>];</span><br><span class="line"><span class="type">int</span> head[<span class="number">200001</span>],tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addE</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">E[++tot].link=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">E[tot].to=v;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; s[<span class="number">200001</span>];</span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="type">int</span> dep[<span class="number">200001</span>],siz[<span class="number">200001</span>],w[<span class="number">200001</span>],dis[<span class="number">200001</span>],fa[<span class="number">200001</span>];</span><br><span class="line"><span class="type">int</span> hson[<span class="number">200001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">fa[now]=f;</span><br><span class="line">siz[now]=<span class="number">1</span>;</span><br><span class="line">dis[now]^=w[now];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==f)<span class="keyword">continue</span>;</span><br><span class="line">dep[E[i].to]=dep[now]+<span class="number">1</span>;</span><br><span class="line">dis[E[i].to]^=dis[now];</span><br><span class="line"><span class="built_in">dfs1</span>(E[i].to,now);</span><br><span class="line">siz[now]+=siz[E[i].to];</span><br><span class="line"><span class="keyword">if</span>(siz[E[i].to]&gt;siz[hson[now]])hson[now]=E[i].to;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//int st=clock();</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> dep=<span class="number">0</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!hson[now])&#123;</span><br><span class="line">s[now].<span class="built_in">insert</span>(dis[now]);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> maxx=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==fa[now])<span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs</span>(E[i].to,dep+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(s[E[i].to].<span class="built_in">size</span>()&gt;s[maxx].<span class="built_in">size</span>())maxx=E[i].to;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(s[now],s[maxx]);</span><br><span class="line"><span class="comment">//cout&lt;&lt;(dis[now]^w[now])&lt;&lt;&quot; &quot;&lt;&lt;now&lt;&lt;&quot; &quot;&lt;&lt;dis[now]&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line"><span class="keyword">if</span>(s[now].<span class="built_in">find</span>(dis[now]^w[now])!=s[now].<span class="built_in">end</span>())&#123;</span><br><span class="line">s[now].<span class="built_in">clear</span>();</span><br><span class="line">ans++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">s[now].<span class="built_in">insert</span>(dis[now]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==fa[now]||E[i].to==maxx)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(it=s[E[i].to].<span class="built_in">begin</span>();it!=s[E[i].to].<span class="built_in">end</span>();it++)&#123;</span><br><span class="line"><span class="keyword">if</span>(s[now].<span class="built_in">find</span>(*it^w[now])!=s[now].<span class="built_in">end</span>())&#123;</span><br><span class="line">s[now].<span class="built_in">clear</span>();</span><br><span class="line">ans++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(it=s[E[i].to].<span class="built_in">begin</span>();it!=s[E[i].to].<span class="built_in">end</span>();it++)s[now].<span class="built_in">insert</span>(*it);</span><br><span class="line">s[E[i].to].<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep&gt;n)<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//assert(clock()-st&gt;=2*CLOCKS_PER_SEC&amp;&amp;ans&gt;5);</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;w[i];</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="built_in">addE</span>(x,y);</span><br><span class="line"><span class="built_in">addE</span>(y,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//if(w[1]==5791252)return 0;</span></span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//cerr&lt;&lt;s[1].size();</span></span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好像 $O(set.find())&lt;O(set.count())$，好神奇。</p><p>还有 $2$ 题的启发式合并，先去写什么计划了。</p><h3 id="例题：CF246E">例题：<a href="https://www.luogu.com.cn/problem/CF246E">CF246E</a></h3><p>Mea 的 pdf 已经讲得比较清楚了。</p><p>先正常 dsu 一遍，对每个深度维护一个桶，然后计数即可。对于在该点的询问，就直接访问该桶即可。</p><p>感觉这次 <code>unordered_set</code> 是可行的。开写！</p><p>做这道题脑子是昏的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LUOGU_RID: 131245815</span></span><br><span class="line"><span class="comment">// Problem: Blood Cousins Return</span></span><br><span class="line"><span class="comment">// Contest: Luogu</span></span><br><span class="line"><span class="comment">// URL: https://www.luogu.com.cn/problem/CF246E</span></span><br><span class="line"><span class="comment">// Memory Limit: 250 MB</span></span><br><span class="line"><span class="comment">// Time Limit: 3000 ms</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Powered by CP Editor (https://cpeditor.org)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">unordered_map&lt;string,<span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="type">int</span> mpcnt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span>&#123;</span><br><span class="line"><span class="type">int</span> to,link;</span><br><span class="line">&#125;E[<span class="number">200001</span>];</span><br><span class="line"><span class="type">int</span> head[<span class="number">100001</span>],tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addE</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">E[++tot].link=head[u];</span><br><span class="line">E[tot].to=v;</span><br><span class="line">head[u]=tot;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dep[<span class="number">100001</span>],siz[<span class="number">100001</span>],hson[<span class="number">100001</span>],fa[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> cnt[<span class="number">200001</span>],w[<span class="number">100001</span>],L[<span class="number">100001</span>],R[<span class="number">100001</span>],rk[<span class="number">200001</span>],dfncnt;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; Q[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> ans[<span class="number">100001</span>];</span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt; s[<span class="number">200001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">fa[now]=f;</span><br><span class="line">siz[now]=<span class="number">1</span>;</span><br><span class="line">L[now]=++dfncnt;</span><br><span class="line">rk[dfncnt]=now;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==f)<span class="keyword">continue</span>;</span><br><span class="line">dep[E[i].to]=dep[now]+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs1</span>(E[i].to,now);</span><br><span class="line">siz[now]+=siz[E[i].to];</span><br><span class="line"><span class="keyword">if</span>(siz[E[i].to]&gt;siz[hson[now]])hson[now]=E[i].to;</span><br><span class="line">&#125;</span><br><span class="line">R[now]=dfncnt;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> u=rk[id];</span><br><span class="line"><span class="keyword">if</span>(!s[dep[u]].<span class="built_in">count</span>(w[u]))&#123;</span><br><span class="line">s[dep[u]].<span class="built_in">insert</span>(w[u]);</span><br><span class="line">cnt[dep[u]]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dsu</span><span class="params">(<span class="type">int</span> now,<span class="type">bool</span> fl=<span class="number">0</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==fa[now]||E[i].to==hson[now])<span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dsu</span>(E[i].to);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cerr&lt;&lt;now&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line"><span class="keyword">if</span>(hson[now])<span class="built_in">dsu</span>(hson[now],<span class="number">1</span>);</span><br><span class="line"><span class="built_in">add</span>(L[now]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==fa[now]||E[i].to==hson[now])<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=L[E[i].to];j&lt;=R[E[i].to];j++)<span class="built_in">add</span>(j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> num:Q[now])&#123;</span><br><span class="line">ans[num.second]=cnt[dep[now]+num.first];</span><br><span class="line"><span class="comment">//if(now==1&amp;&amp;num.first==2)&#123;</span></span><br><span class="line"><span class="comment">//cout&lt;&lt;cnt[1]&lt;&lt;&quot; &quot;&lt;&lt;cnt[2]&lt;&lt;&quot; &quot;&lt;&lt;cnt[3]&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//cout&lt;&lt;num.first&lt;&lt;&quot; &quot;&lt;&lt;now&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(fl)<span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=dep[now];i&lt;=dep[now]+siz[now]<span class="number">-1</span>;i++)cnt[i]=<span class="number">0</span>,s[i].<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> deg[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">string s;</span><br><span class="line"><span class="type">int</span> ff;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;s&gt;&gt;ff;</span><br><span class="line"><span class="keyword">if</span>(ff)<span class="built_in">addE</span>(ff,i),deg[i]++;</span><br><span class="line"><span class="keyword">if</span>(!mp[s])mp[s]=++mpcnt;</span><br><span class="line">w[i]=mp[s];</span><br><span class="line">&#125;</span><br><span class="line">cin&gt;&gt;m;</span><br><span class="line"><span class="type">int</span> v,k;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">cin&gt;&gt;v&gt;&gt;k;</span><br><span class="line">Q[v].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(k,i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)<span class="keyword">if</span>(deg[k]==<span class="number">0</span>)<span class="built_in">dfs1</span>(k,<span class="number">0</span>),<span class="built_in">dsu</span>(k);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题：CF741D">例题：CF741D</h3><p>树启发明者出的题。</p><p>考虑一个 <code>重排之后能形成回文字符串</code> 的路径的性质，不难发现它的各个字母出现次数最多有一个是奇数，想到异或。</p><p>记 $d_u$ 为从根到该点路径的异或和，那么对这 $22$ 个字符进行状压，只有 $23$ 种情况符合条件：$000\cdots0,000\cdots1,\cdots,100\cdots0$。</p><p>那么对于每个点记录该点子树的 $d$，不难发现其实 $d_{u\to v}=d_u\oplus d_v$，那么可以用桶记录每个 $d$ 深度的最大值进行 dsu，然后 $O(23)$ 判断合法即可。注意每个节点还要像它的儿子的答案去取最大值。最后对于每个点去找 $dep_u+dep_v$ 的最大值，然后减去 $2\times dep_{now}$ 即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: Arpa’s letter-marked tree and Mehrdad’s Dokhtar-kosh paths</span></span><br><span class="line"><span class="comment">// Contest: Luogu</span></span><br><span class="line"><span class="comment">// URL: https://www.luogu.com.cn/problem/CF741D</span></span><br><span class="line"><span class="comment">// Memory Limit: 250 MB</span></span><br><span class="line"><span class="comment">// Time Limit: 3000 ms</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Powered by CP Editor (https://cpeditor.org)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">char</span> a)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>&lt;&lt;(a-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ri[<span class="number">24</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">21</span>;i++)ri[i+<span class="number">1</span>]=<span class="number">1</span>&lt;&lt;i;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span>&#123;</span><br><span class="line"><span class="type">int</span> to,link,w;</span><br><span class="line">&#125;E[<span class="number">1000001</span>];</span><br><span class="line"><span class="type">int</span> head[<span class="number">500001</span>],w[<span class="number">500001</span>],tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addE</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">E[++tot].w=<span class="built_in">get</span>(c);</span><br><span class="line">E[tot].to=v;</span><br><span class="line">E[tot].link=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dis[<span class="number">10000001</span>];</span><br><span class="line"><span class="type">int</span> L[<span class="number">500001</span>],R[<span class="number">500001</span>],rk[<span class="number">500001</span>],dep[<span class="number">500001</span>],siz[<span class="number">500001</span>];</span><br><span class="line"><span class="type">int</span> hson[<span class="number">500001</span>],fa[<span class="number">500001</span>],di[<span class="number">500001</span>],dfncnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">fa[now]=f;</span><br><span class="line">siz[now]=<span class="number">1</span>;</span><br><span class="line">L[now]=++dfncnt;</span><br><span class="line">rk[dfncnt]=now;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==f)<span class="keyword">continue</span>;</span><br><span class="line">dep[E[i].to]=dep[now]+<span class="number">1</span>;</span><br><span class="line">w[E[i].to]=E[i].w;</span><br><span class="line">di[E[i].to]=di[now]^E[i].w;</span><br><span class="line"><span class="built_in">dfs</span>(E[i].to,now);</span><br><span class="line">siz[now]+=siz[E[i].to];</span><br><span class="line"><span class="keyword">if</span>(siz[E[i].to]&gt;siz[hson[now]])hson[now]=E[i].to;</span><br><span class="line">&#125;</span><br><span class="line">R[now]=dfncnt;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans[<span class="number">500001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dsu</span><span class="params">(<span class="type">int</span> now,<span class="type">bool</span> fl)</span></span>&#123;</span><br><span class="line"><span class="comment">// cout&lt;&lt;now&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==fa[now]||E[i].to==hson[now])<span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dsu</span>(E[i].to,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(hson[now])<span class="built_in">dsu</span>(hson[now],<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==fa[now]||E[i].to==hson[now])<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=L[E[i].to];j&lt;=R[E[i].to];j++)&#123;</span><br><span class="line"><span class="comment">//dis[di[now]^di[rk[j]]];</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;=<span class="number">22</span>;l++)ans[now]=<span class="built_in">max</span>(dis[di[rk[j]]^ri[l]]+dep[rk[j]],ans[now]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=L[E[i].to];j&lt;=R[E[i].to];j++)dis[di[rk[j]]]=<span class="built_in">max</span>(dis[di[rk[j]]],dep[rk[j]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;=<span class="number">22</span>;l++)ans[now]=<span class="built_in">max</span>(dis[di[now]^ri[l]]+dep[now],ans[now]);</span><br><span class="line">dis[di[now]]=<span class="built_in">max</span>(dis[di[now]],dep[now]);</span><br><span class="line"><span class="comment">//cout&lt;&lt;ans[now]&lt;&lt;&quot; &quot;&lt;&lt;dep[now]&lt;&lt;&quot; &quot;&lt;&lt;now&lt;&lt;&quot; a\n&quot;;</span></span><br><span class="line">ans[now]-=<span class="number">2</span>*dep[now];</span><br><span class="line"><span class="comment">//cout&lt;&lt;ans[now]&lt;&lt;&quot; &quot;&lt;&lt;dep[now]&lt;&lt;&quot; &quot;&lt;&lt;now&lt;&lt;&quot; b\n&quot;;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==fa[now])<span class="keyword">continue</span>;</span><br><span class="line">ans[now]=<span class="built_in">max</span>(ans[now],ans[E[i].to]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout&lt;&lt;ans[now]&lt;&lt;&quot; &quot;&lt;&lt;dep[now]&lt;&lt;&quot; &quot;&lt;&lt;now&lt;&lt;&quot; c\n&quot;;</span></span><br><span class="line"><span class="comment">//for(int i=1;i&lt;=n;i++)cout&lt;&lt;ans[i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="keyword">if</span>(fl)<span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=L[now];i&lt;=R[now];i++)dis[di[rk[i]]]=<span class="number">-1e9</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=(<span class="number">1</span>&lt;&lt;<span class="number">22</span>);i++)dis[i]=<span class="number">-1e9</span>;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="type">char</span> cc;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;cc;</span><br><span class="line"><span class="built_in">addE</span>(x,i,cc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">dsu</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cout&lt;&lt;<span class="built_in">max</span>(ans[i],<span class="number">0</span>)&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="长链剖分">长链剖分</h2><p>就是把 <code>重儿子</code> 的定义改为 <code>高度最高的儿子</code>。</p><h3 id="长链剖分优化-dp">长链剖分优化 dp</h3><h4 id="例题：CF1009F">例题：CF1009F</h4><p>没看太懂，dsu 不就行了？</p><p>写个长剖下实现的 dsu 算了。</p><p>感觉挺简单的，直接贴代码吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: Dominant Indices</span></span><br><span class="line"><span class="comment">// Contest: Luogu</span></span><br><span class="line"><span class="comment">// URL: https://www.luogu.com.cn/problem/CF1009F</span></span><br><span class="line"><span class="comment">// Memory Limit: 500 MB</span></span><br><span class="line"><span class="comment">// Time Limit: 4500 ms</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Powered by CP Editor (https://cpeditor.org)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span>&#123;</span><br><span class="line"><span class="type">int</span> to,link;</span><br><span class="line">&#125;E[<span class="number">2000001</span>];</span><br><span class="line"><span class="type">int</span> head[<span class="number">1000001</span>],tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addE</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">E[++tot].to=v;</span><br><span class="line">E[tot].link=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cnt[<span class="number">1000001</span>],xb,maxdep;</span><br><span class="line"><span class="type">int</span> dep[<span class="number">1000001</span>],dd[<span class="number">1000001</span>],hson[<span class="number">1000001</span>],fa[<span class="number">1000001</span>],ans[<span class="number">1000001</span>];</span><br><span class="line"><span class="type">int</span> L[<span class="number">1000001</span>],R[<span class="number">1000001</span>],rk[<span class="number">1000001</span>],dfncnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">fa[now]=f;</span><br><span class="line">L[now]=++dfncnt;</span><br><span class="line">rk[dfncnt]=now;</span><br><span class="line">maxdep=<span class="built_in">max</span>(maxdep,dep[now]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==f)<span class="keyword">continue</span>;</span><br><span class="line">dep[E[i].to]=dep[now]+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(E[i].to,now);</span><br><span class="line">dd[now]=<span class="built_in">max</span>(dd[now],dd[E[i].to]+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(dd[E[i].to]&gt;dd[hson[now]])hson[now]=E[i].to;</span><br><span class="line">&#125;</span><br><span class="line">R[now]=dfncnt;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt[num]&gt;cnt[xb]||(cnt[num]==cnt[xb]&amp;&amp;xb&gt;num))xb=num;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dsu</span><span class="params">(<span class="type">int</span> now,<span class="type">bool</span> fl=<span class="number">0</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==fa[now]||E[i].to==hson[now])<span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dsu</span>(E[i].to);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(hson[now])<span class="built_in">dsu</span>(hson[now],<span class="number">1</span>);</span><br><span class="line">cnt[dep[now]]++;<span class="built_in">upd</span>(dep[now]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==fa[now]||E[i].to==hson[now])<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=L[E[i].to];j&lt;=R[E[i].to];j++)cnt[dep[rk[j]]]++,<span class="built_in">upd</span>(dep[rk[j]]);</span><br><span class="line">&#125;</span><br><span class="line">ans[now]=xb-dep[now];</span><br><span class="line"><span class="keyword">if</span>(fl)<span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=dep[now];i&lt;=maxdep;i++)cnt[i]=<span class="number">0</span>;</span><br><span class="line">xb=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)cin&gt;&gt;x&gt;&gt;y,<span class="built_in">addE</span>(x,y),<span class="built_in">addE</span>(y,x);</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">dsu</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好像长链 dsu 比重链 dsu 慢（复杂度假了）？离谱，这个优化 dp 还是没有理解。</p><p>好像长链剖分优化 dp 是要记录 dp 时所有节点的状态的，草。</p><p>然后下一道题就是正宗优化了，然而由于作者 dp 能力 欠佳，可能需要较久时间看懂如何推的 dp 转移式。</p><p>看懂了。</p><h4 id="正宗例题：P5904">正宗例题：P5904</h4><p>这道题看你怎么用 dsu。只能用 dp。</p><p>设 $f_{i,j}$ 为在 $i$ 子树中距离 $i$ 距离为 $j$ 的点个数，$g_{i,j}$ 为在 $i$ 子树中，满足 $dis_{x\to LCA(x,y)}=dis_{y\to LCA(x,y)}=dis_{i\to LCA(x,y)}+j$ 的 $(x,y)$ 无序对数量。</p><p>不难发现一下较为简单的转移：<br>$$<br>f_{i,j}\leftarrow\sum f_{son(i),j-1}\<br>g_{i,j}\leftarrow\sum g_{son(i),j+1}<br>$$<br>$g_{i,j}$ 的转移还有一种情况，就是 $x,y$ 在不同儿子的子树中，那么有：<br>$$<br>g_{i,j}\leftarrow\sum_{x,y\in son(i)\and x\not=y}f_{x,j-1}\times f_{y,j-1}<br>$$<br>然后就是对 $ans$ 的贡献了。对于每个点，首先， $ans\leftarrow g_{now,0}$。</p><p>然后讨论其他能对 $ans$ 做出贡献的地方，即 $(x,y)$ 和 $z$ 在 $i$ 的不同子树上，可知：<br>$$<br>ans\leftarrow\sum_j\sum_{x,y\in son(i)\and x\not=y}g_{x,j+1}\times f_{y,j-1}<br>$$<br>那么…这是一个 $O(n^2)$ 算法，因为我们开不了二维数组…</p><p>因为深度为下标，并且可以通过指针直接 $O(1)$ 转移，考虑使用长链剖分优化，时间复杂度优化至 $O(n)$。</p><p>有几点需要注意的：</p><ul class="lvl-0"><li class="lvl-2"><p>注意数组下标 $\in [0,height_{now})$，不能越界。</p></li><li class="lvl-2"><p>注意叶子节点的高度为 $1$，因为 $f_{now,0}$ 对于所有节点都有。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: P5904 [POI2014] HOT-Hotels 加强版</span></span><br><span class="line"><span class="comment">// Contest: Luogu</span></span><br><span class="line"><span class="comment">// URL: https://www.luogu.com.cn/problem/P5904</span></span><br><span class="line"><span class="comment">// Memory Limit: 62 MB</span></span><br><span class="line"><span class="comment">// Time Limit: 1000 ms</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Powered by CP Editor (https://cpeditor.org)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span>&#123;</span><br><span class="line"><span class="type">int</span> to,link;</span><br><span class="line">&#125;E[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> head[N],tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addE</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">E[++tot].link=head[u];</span><br><span class="line">E[tot].to=v;</span><br><span class="line">head[u]=tot;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dep[N],qsy[N&lt;&lt;<span class="number">2</span>],dd[N],fa[N],hson[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">fa[now]=f;</span><br><span class="line">dd[now]=<span class="number">1</span>;<span class="comment">//!!!!!叶子节点高度为1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==f)<span class="keyword">continue</span>;</span><br><span class="line">dep[E[i].to]=dep[now]+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(E[i].to,now);</span><br><span class="line">dd[now]=<span class="built_in">max</span>(dd[now],dd[E[i].to]+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(dd[E[i].to]&gt;dd[hson[now]])hson[now]=E[i].to;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> *no=qsy,*f[N],*g[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(hson[now])f[hson[now]]=f[now]+<span class="number">1</span>,g[hson[now]]=g[now]<span class="number">-1</span>,<span class="built_in">dp</span>(hson[now]);</span><br><span class="line">f[now][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">ans+=g[now][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==fa[now]||E[i].to==hson[now])<span class="keyword">continue</span>;</span><br><span class="line">f[E[i].to]=no,no+=dd[E[i].to]&lt;&lt;<span class="number">1</span>;</span><br><span class="line">g[E[i].to]=no,no+=dd[E[i].to]&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dp</span>(E[i].to);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;dd[E[i].to];j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(j)ans+=f[now][j<span class="number">-1</span>]*g[E[i].to][j];<span class="comment">//同下</span></span><br><span class="line">ans+=f[E[i].to][j]*g[now][j+<span class="number">1</span>];<span class="comment">//在已遍历的子树中，找 两个 节点匹配新遍历的子树中的 一个 节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;dd[E[i].to];j++)&#123;</span><br><span class="line">g[now][j+<span class="number">1</span>]+=f[E[i].to][j]*f[now][j+<span class="number">1</span>],f[now][j+<span class="number">1</span>]+=f[E[i].to][j];</span><br><span class="line"><span class="keyword">if</span>(j)g[now][j<span class="number">-1</span>]+=g[E[i].to][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)cin&gt;&gt;x&gt;&gt;y,<span class="built_in">addE</span>(x,y),<span class="built_in">addE</span>(y,x);</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">f[<span class="number">1</span>]=no,no+=dd[<span class="number">1</span>]&lt;&lt;<span class="number">1</span>;</span><br><span class="line">g[<span class="number">1</span>]=no,no+=dd[<span class="number">1</span>]&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dp</span>(<span class="number">1</span>);</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="长链剖分求树上-k-级祖先">长链剖分求树上 k 级祖先</h3><p>设 $2^i\leq k&lt;2^{i+1}$，那么可以先向上跳到 $2^i$ 级祖先，然后使用长链剖分。</p><p>可以证明 $l_{chain}\geq k-2^i$，分两种情况。</p><ol><li class="lvl-3"><p>跳完之后跳到了同一条链上，显然，$l_{chain}\geq2<sup>i&gt;k-2</sup>i$。</p></li><li class="lvl-3"><p>跳完之后跳到了不同链上，则必有 $l_{orginal_chain}&lt;l_{now_chain}$，因为该链并没有向原来的节点延伸，则有 $l_{now_chain}\geq2^i$，剩余同上。</p></li></ol><p>那么可以在链顶暴力记录 $1\sim l$ 级祖先与儿子即可。</p><p>空间 $O(n)$。时间复杂度 $O(n\log n+q)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: P5903 【模板】树上 K 级祖先</span></span><br><span class="line"><span class="comment">// Contest: Luogu</span></span><br><span class="line"><span class="comment">// URL: https://www.luogu.com.cn/problem/P5903</span></span><br><span class="line"><span class="comment">// Memory Limit: 500 MB</span></span><br><span class="line"><span class="comment">// Time Limit: 3000 ms</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Powered by CP Editor (https://cpeditor.org)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span>&#123;</span><br><span class="line"><span class="type">int</span> to,link;</span><br><span class="line">&#125;E[<span class="number">1000001</span>];</span><br><span class="line"><span class="type">int</span> head[<span class="number">500001</span>],tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addE</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">E[++tot].link=head[u];</span><br><span class="line">E[tot].to=v;</span><br><span class="line">head[u]=tot;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> fa[<span class="number">500001</span>][<span class="number">29</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; up[<span class="number">500001</span>];</span><br><span class="line"><span class="type">int</span> ltop[<span class="number">500001</span>],dfn[<span class="number">500001</span>],rk[<span class="number">500001</span>],dfncnt;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"><span class="type">int</span> dep[<span class="number">500001</span>],dd[<span class="number">500001</span>],hson[<span class="number">500001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">fa[now][<span class="number">0</span>]=f;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;fa[now][i];)i++,fa[now][i]=fa[fa[now][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==f)<span class="keyword">continue</span>;</span><br><span class="line">dep[E[i].to]=dep[now]+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(E[i].to,now);</span><br><span class="line">dd[now]=<span class="built_in">max</span>(dd[now],dd[E[i].to]+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(dd[E[i].to]&gt;dd[hson[now]])hson[now]=E[i].to;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> top)</span></span>&#123;</span><br><span class="line">dfn[now]=++dfncnt;</span><br><span class="line">rk[dfncnt]=now;</span><br><span class="line">ltop[now]=top;</span><br><span class="line"><span class="keyword">if</span>(!hson[now])<span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(now==top)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,o=fa[now][<span class="number">0</span>];o&amp;&amp;i&lt;=dd[now];i++,o=fa[o][<span class="number">0</span>])up[now].<span class="built_in">push_back</span>(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">init</span>(hson[now],top);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==fa[now][<span class="number">0</span>]||E[i].to==hson[now])<span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">init</span>(E[i].to,E[i].to);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ui unsigned int</span></span><br><span class="line">ui s;</span><br><span class="line"><span class="type">int</span> lg[<span class="number">500001</span>]=&#123;<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ui <span class="title">get</span><span class="params">(ui x)</span> </span>&#123;</span><br><span class="line">x ^= x &lt;&lt; <span class="number">13</span>;</span><br><span class="line">x ^= x &gt;&gt; <span class="number">17</span>;</span><br><span class="line">x ^= x &lt;&lt; <span class="number">5</span>;</span><br><span class="line"><span class="keyword">return</span> s = x; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">0</span>)<span class="keyword">return</span> u;</span><br><span class="line"><span class="comment">//cerr&lt;&lt;u&lt;&lt;&quot; &quot;&lt;&lt;k&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">u=fa[u][lg[k]];</span><br><span class="line">k-=(<span class="number">1</span>&lt;&lt;lg[k]);</span><br><span class="line"><span class="comment">//cerr&lt;&lt;k&lt;&lt;&quot; &quot;&lt;&lt;u&lt;&lt;&quot; &quot;&lt;&lt;ltop[u]&lt;&lt;&quot; &quot;&lt;&lt;dep[u]&lt;&lt;&quot; &quot;&lt;&lt;dep[ltop[u]]&lt;&lt;&quot; &quot;&lt;&lt;up[ltop[u]].size()&lt;&lt;&quot; &quot;&lt;&lt;k-dep[ltop[u]]+dep[u]&lt;&lt;&quot; degub\n&quot;;</span></span><br><span class="line"><span class="keyword">if</span>(k&lt;=dep[u]-dep[ltop[u]])<span class="keyword">return</span> rk[dfn[u]-k];</span><br><span class="line"><span class="comment">//cerr&lt;&lt;k+dep[ltop[u]]-dep[u]-1&lt;&lt;up[ltop[u]].size()&lt;&lt;&quot; &quot;&lt;&lt;dep[ltop[u]]&lt;&lt;&quot; &quot;&lt;&lt;dep[u]&lt;&lt;&quot; &quot;&lt;&lt;k&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line"><span class="comment">//assert(k+dep[ltop[u]]-dep[u]-1&lt;up[ltop[u]].size());</span></span><br><span class="line"><span class="keyword">return</span> up[ltop[u]][k+dep[ltop[u]]-dep[u]<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> lans;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;q&gt;&gt;s;</span><br><span class="line"><span class="comment">//cout&lt;&lt;s&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line"><span class="type">int</span> sss=q,kkk;</span><br><span class="line"><span class="type">int</span> kl;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;kl;</span><br><span class="line"><span class="keyword">if</span>(kl)<span class="built_in">addE</span>(kl,i);</span><br><span class="line"><span class="keyword">else</span> kkk=i;</span><br><span class="line">lg[i]=lg[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(kkk,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">init</span>(kkk,kkk);</span><br><span class="line"><span class="comment">//return 0;</span></span><br><span class="line"><span class="keyword">while</span>(q--)&#123;</span><br><span class="line"><span class="comment">//cerr&lt;&lt;dep[4];</span></span><br><span class="line"><span class="comment">//cerr&lt;&lt;sss-q&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">ui v=(<span class="built_in">get</span>(s)^lans)%n+<span class="number">1</span>,k=(<span class="built_in">get</span>(s)^lans)%(dep[v]+<span class="number">1</span>);</span><br><span class="line"><span class="comment">//cerr&lt;&lt;v&lt;&lt;&quot; &quot;&lt;&lt;k&lt;&lt;&quot; &quot;&lt;&lt;dep[v]&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">lans=<span class="built_in">ask</span>(v,k);</span><br><span class="line"></span><br><span class="line"><span class="comment">//cout&lt;&lt;lans&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">ans=ans^(<span class="number">1ll</span>*(sss-q)*lans);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调了好久，结果跑不过树剖跳重链，输！</p><h2 id="一些练手题">一些练手题</h2><p>下面是整理的一些例题与变式。还有树分治，虚树，树同构三个板块。</p><h3 id="例题：P4211">例题：P4211</h3><p>小清新题，求 $\sum_{i=l}^rdep_{LCA(i,z)}$。</p><p>初次拿到这道题肯定毫无思路。考虑将 $dep_u$ 转化为 $dis_{1\to u}$，发现这道题可以使用差分。具体就是对于 $1\to i$ 路径上的所有边权值加 $1$，因为 $LCA$ 一定在 $1\to i$ 这条路径上。最后统计 $1\to z$ 路径的边权和即可。</p><p>但是这样差分的复杂度是 $O(nq)$ 的。尝试优化。</p><p>考虑离线，对状态进行前缀和优化，即算出 $[1,i](i\in [1,n])$ 的所有状态。对于每个询问，求 $ans_{[1,r]}-ans_{[1,l)}$ 即可。用树链剖分 + 线段树维护链加一。时间复杂度 $O(n\log^2n)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: P4211 [LNOI2014] LCA</span></span><br><span class="line"><span class="comment">// Contest: Luogu</span></span><br><span class="line"><span class="comment">// URL: https://www.luogu.com.cn/problem/P4211</span></span><br><span class="line"><span class="comment">// Memory Limit: 125 MB</span></span><br><span class="line"><span class="comment">// Time Limit: 1000 ms</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Powered by CP Editor (https://cpeditor.org)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">201314</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span>&#123;</span><br><span class="line"><span class="type">int</span> to,link;</span><br><span class="line">&#125;E[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> head[<span class="number">50001</span>],tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addE</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">E[++tot].link=head[u];</span><br><span class="line">E[tot].to=v;</span><br><span class="line">head[u]=tot;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> fa[<span class="number">100001</span>],dep[<span class="number">100001</span>],hson[<span class="number">100001</span>],siz[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">fa[now]=f;</span><br><span class="line">siz[now]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==f)<span class="keyword">continue</span>;</span><br><span class="line">dep[E[i].to]=dep[now]+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs1</span>(E[i].to,now);</span><br><span class="line">siz[now]+=siz[E[i].to];</span><br><span class="line"><span class="keyword">if</span>(siz[E[i].to]&gt;siz[hson[now]])hson[now]=E[i].to;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dfn[<span class="number">100001</span>],rk[<span class="number">100001</span>],dfncnt,ltop[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> top)</span></span>&#123;</span><br><span class="line">dfn[now]=++dfncnt;</span><br><span class="line">rk[dfncnt]=now;</span><br><span class="line">ltop[now]=top;</span><br><span class="line"><span class="keyword">if</span>(!hson[now])<span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(hson[now],top);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==fa[now]||E[i].to==hson[now])<span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(E[i].to,E[i].to);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; Q[<span class="number">50001</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[<span class="number">50001</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"><span class="type">int</span> xds[<span class="number">800001</span>],lazy[<span class="number">800001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(lazy[now])&#123;</span><br><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">xds[now&lt;&lt;<span class="number">1</span>]+=(mid-l+<span class="number">1</span>)*lazy[now];</span><br><span class="line">xds[now&lt;&lt;<span class="number">1</span>]%=mod;</span><br><span class="line">xds[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=(r-mid)*lazy[now];</span><br><span class="line">xds[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]%=mod;</span><br><span class="line">lazy[now&lt;&lt;<span class="number">1</span>]+=lazy[now];</span><br><span class="line">lazy[now&lt;&lt;<span class="number">1</span>]%=mod;</span><br><span class="line">lazy[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=lazy[now];</span><br><span class="line">lazy[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]%=mod;</span><br><span class="line">lazy[now]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line">xds[now]=(xds[now&lt;&lt;<span class="number">1</span>]+xds[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])%mod;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> sl,<span class="type">int</span> sr,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==sl&amp;&amp;r==sr)&#123;</span><br><span class="line">xds[now]+=(r-l+<span class="number">1</span>)*v;</span><br><span class="line">lazy[now]+=v;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">pushdown</span>(now,l,r);</span><br><span class="line"><span class="keyword">if</span>(sl&lt;=mid)<span class="built_in">upd</span>(now&lt;&lt;<span class="number">1</span>,l,mid,sl,<span class="built_in">min</span>(sr,mid),v);</span><br><span class="line"><span class="keyword">if</span>(sr&gt;mid)<span class="built_in">upd</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,<span class="built_in">max</span>(sl,mid+<span class="number">1</span>),sr,v);</span><br><span class="line"><span class="built_in">pushup</span>(now);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getsum</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> sl,<span class="type">int</span> sr)</span></span>&#123;</span><br><span class="line"><span class="comment">//cerr&lt;&lt;sl&lt;&lt;&quot; &quot;&lt;&lt;sr&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line"><span class="keyword">if</span>(l==sl&amp;&amp;r==sr)<span class="keyword">return</span> xds[now];</span><br><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>,res=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">pushdown</span>(now,l,r);</span><br><span class="line"><span class="keyword">if</span>(sl&lt;=mid)res+=<span class="built_in">getsum</span>(now&lt;&lt;<span class="number">1</span>,l,mid,sl,<span class="built_in">min</span>(sr,mid)),res%=mod;</span><br><span class="line"><span class="keyword">if</span>(sr&gt;mid)res+=<span class="built_in">getsum</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,<span class="built_in">max</span>(sl,mid+<span class="number">1</span>),sr),res%=mod;</span><br><span class="line"><span class="built_in">pushup</span>(now);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mdf</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(u<span class="comment">/*ltop[u]!=1*/</span>)&#123;</span><br><span class="line"><span class="built_in">upd</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[ltop[u]],dfn[u],<span class="number">1</span>);</span><br><span class="line"><span class="comment">//cerr&lt;&lt;ltop[u]&lt;&lt;&quot; &quot;&lt;&lt;u&lt;&lt;&quot; debug\n&quot;;</span></span><br><span class="line">u=fa[ltop[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//if(u!=1)upd(1,1,n,2,dfn[u],1);</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qsum</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(u)res+=<span class="built_in">getsum</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[ltop[u]],dfn[u]),u=fa[ltop[u]],res%=mod;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> l[<span class="number">50001</span>],r[<span class="number">50001</span>],z[<span class="number">50001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//dep[1]=1;</span></span><br><span class="line"><span class="type">int</span> q;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line"><span class="type">int</span> temp;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)cin&gt;&gt;temp,<span class="built_in">addE</span>(temp+<span class="number">1</span>,i);</span><br><span class="line"><span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)cin&gt;&gt;l[i]&gt;&gt;r[i]&gt;&gt;z[i],G[l[i]].<span class="built_in">push_back</span>(z[i]+<span class="number">1</span>),G[r[i]+<span class="number">1</span>].<span class="built_in">push_back</span>(z[i]+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="comment">//cerr&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line"><span class="built_in">mdf</span>(i);</span><br><span class="line"><span class="comment">//cerr&lt;&lt;qsum(1)&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line"><span class="comment">//cerr&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">for</span>(it=G[i].<span class="built_in">begin</span>();it!=G[i].<span class="built_in">end</span>();it++)<span class="keyword">if</span>(Q[i][*it]==<span class="number">0</span>)Q[i][*it]=<span class="built_in">qsum</span>(*it);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line"><span class="comment">//cerr&lt;&lt;Q[r[i]+1][z[i]+1]&lt;&lt;&quot; &quot;&lt;&lt;Q[l[i]][z[i]+1]&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line"><span class="comment">//cout&lt;&lt;(Q[r[i]+1][z[i]+1]-Q[l[i]][z[i]+1]+(r[i]-l[i]+1)+mod)%mod&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">cout&lt;&lt;(Q[r[i]+<span class="number">1</span>][z[i]+<span class="number">1</span>]-Q[l[i]][z[i]+<span class="number">1</span>]+mod)%mod&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线段树又写挂 $2$ 次，悲。</p><h3 id="例题：P5305">例题：P5305</h3><p>这道题是上一道题的扩展版。</p><p>不难想到继续离线做，但是需要用线段树支持区间加 $1<sup>k-0</sup>k,2<sup>k-1</sup>k\cdots (d+1)<sup>k-d</sup>k$ 的操作。</p><p>考虑标记这段区间被标记覆盖了多少次，预处理出 $d^k$ 的值，然后每次下放标记的时候，就加上 $lazy\times(dep_{rk_{r}}<sup>k-(dep_{rk_l}-1)</sup>k)$ 即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: P5305 [GXOI/GZOI2019] 旧词</span></span><br><span class="line"><span class="comment">// Contest: Luogu</span></span><br><span class="line"><span class="comment">// URL: https://www.luogu.com.cn/problem/P5305</span></span><br><span class="line"><span class="comment">// Memory Limit: 500 MB</span></span><br><span class="line"><span class="comment">// Time Limit: 1000 ms</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Powered by CP Editor (https://cpeditor.org)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">a+=b;</span><br><span class="line">a%=mod;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minu</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">a-=b%mod;</span><br><span class="line">a=(a+mod)%mod;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> _k[<span class="number">50001</span>],n,m,k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ksm</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">1</span>)<span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">return</span> (b&amp;<span class="number">1</span>?a:<span class="number">1</span>)*(<span class="built_in">ksm</span>(a*a%mod,b/<span class="number">2</span>))%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span>&#123;</span><br><span class="line"><span class="type">int</span> to,link;</span><br><span class="line">&#125;E[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> head[<span class="number">50001</span>],tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addE</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">E[++tot].link=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">E[tot].to=v;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> fa[<span class="number">50001</span>],dep[<span class="number">50001</span>],siz[<span class="number">50001</span>],hson[<span class="number">50001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">fa[now]=f;</span><br><span class="line">siz[now]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==f)<span class="keyword">continue</span>;</span><br><span class="line">dep[E[i].to]=dep[now]+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs1</span>(E[i].to,now);</span><br><span class="line">siz[now]+=siz[E[i].to];</span><br><span class="line"><span class="keyword">if</span>(siz[E[i].to]&gt;siz[hson[now]])hson[now]=E[i].to;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dfn[<span class="number">50001</span>],rk[<span class="number">50001</span>],ltop[<span class="number">50001</span>],dfncnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> top)</span></span>&#123;</span><br><span class="line">ltop[now]=top;</span><br><span class="line">dfn[now]=++dfncnt;</span><br><span class="line">rk[dfncnt]=now;</span><br><span class="line"><span class="keyword">if</span>(!hson[now])<span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(hson[now],top);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==fa[now]||E[i].to==hson[now])<span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(E[i].to,E[i].to);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> xds[<span class="number">400001</span>];</span><br><span class="line"><span class="type">int</span> lazy[<span class="number">400001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(lazy[now])&#123;</span><br><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">lazy[now&lt;&lt;<span class="number">1</span>]+=lazy[now];</span><br><span class="line">lazy[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=lazy[now];</span><br><span class="line">xds[now&lt;&lt;<span class="number">1</span>]+=<span class="built_in">minu</span>(_k[dep[rk[mid]]],_k[dep[rk[l]]<span class="number">-1</span>])*lazy[now]%mod;</span><br><span class="line">xds[now&lt;&lt;<span class="number">1</span>]%=mod;</span><br><span class="line">xds[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=<span class="built_in">minu</span>(_k[dep[rk[r]]],_k[dep[rk[mid]]])*lazy[now]%mod;</span><br><span class="line">xds[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]%=mod;</span><br><span class="line"><span class="comment">//cerr&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;mid&lt;&lt;&quot; &quot;&lt;&lt;mid+1&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;&quot; &quot;&lt;&lt;xds[now&lt;&lt;1]&lt;&lt;&quot; &quot;&lt;&lt;xds[now&lt;&lt;1|1]&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">lazy[now]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line">xds[now]=<span class="built_in">sum</span>(xds[now&lt;&lt;<span class="number">1</span>],xds[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> sl,<span class="type">int</span> sr)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==sl&amp;&amp;r==sr)&#123;</span><br><span class="line">lazy[now]++;</span><br><span class="line">xds[now]+=<span class="built_in">minu</span>(_k[dep[rk[r]]],_k[dep[rk[l]]<span class="number">-1</span>])%mod;</span><br><span class="line">xds[now]%=mod;</span><br><span class="line"><span class="comment">//cerr&lt;&lt;xds[now]&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;&quot; &quot;&lt;&lt;l-1&lt;&lt;&quot; &quot;&lt;&lt;dep[rk[r]]&lt;&lt;&quot; &quot;&lt;&lt;dep[rk[l-1]]&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cerr&lt;&lt;now&lt;&lt;&quot; &quot;&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;&quot; &quot;&lt;&lt;sl&lt;&lt;&quot; &quot;&lt;&lt;sr&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line"><span class="built_in">pushdown</span>(now,l,r);</span><br><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(sl&lt;=mid)<span class="built_in">upd</span>(now&lt;&lt;<span class="number">1</span>,l,mid,sl,<span class="built_in">min</span>(sr,mid));</span><br><span class="line"><span class="keyword">if</span>(sr&gt;mid)<span class="built_in">upd</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,<span class="built_in">max</span>(sl,mid+<span class="number">1</span>),sr);</span><br><span class="line"><span class="built_in">pushup</span>(now);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getsum</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> sl,<span class="type">int</span> sr)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==sl&amp;&amp;r==sr)<span class="keyword">return</span> xds[now];</span><br><span class="line"><span class="built_in">pushdown</span>(now,l,r);</span><br><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>,res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(sl&lt;=mid)res=<span class="built_in">sum</span>(res,<span class="built_in">getsum</span>(now&lt;&lt;<span class="number">1</span>,l,mid,sl,<span class="built_in">min</span>(sr,mid)));</span><br><span class="line"><span class="keyword">if</span>(sr&gt;mid)res=<span class="built_in">sum</span>(res,<span class="built_in">getsum</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,<span class="built_in">max</span>(sl,mid+<span class="number">1</span>),sr));</span><br><span class="line"><span class="built_in">pushup</span>(now);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mdf</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(u)<span class="built_in">upd</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[ltop[u]],dfn[u]),u=fa[ltop[u]];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qsum</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(u)res=<span class="built_in">sum</span>(res,<span class="built_in">getsum</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[ltop[u]],dfn[u])),u=fa[ltop[u]];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; Q[<span class="number">50001</span>];</span><br><span class="line"><span class="type">int</span> ans[<span class="number">50001</span>];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">_k[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)_k[i]=<span class="built_in">ksm</span>(i,k);</span><br><span class="line">dep[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)cin&gt;&gt;x,<span class="built_in">addE</span>(x,i);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">Q[x].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(i,y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">mdf</span>(i);</span><br><span class="line"><span class="type">int</span> si=Q[i].<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;si;j++)ans[Q[i][j].first]=<span class="built_in">qsum</span>(Q[i][j].second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题：P2146">例题：P2146</h3><p>不难看出 <code>install u</code> 操作是修改所有 $1\to u$ 路径上的节点状态为已安装，而 <code>uninstall u</code> 操作是修改以 $u$ 为根的子树的所有节点的状态为未安装。我们需要一种数据结构维护这些，并且需要输出每次修改了多少个。</p><p>线段树就够了。维护已安装状态出现的次数即可。设定三个懒标记：</p><ul class="lvl-0"><li class="lvl-2"><p>$lazy=0$，无需操作。</p></li><li class="lvl-2"><p>$lazy=1$，将当前区间内的所有节点设定为已安装。</p></li><li class="lvl-2"><p>$lazy=2$，将当前区间内的所有节点设定为未安装。</p></li></ul><p>下放懒标记时分类讨论，然后在修改时统计修改后的值与原来的值的差的绝对值即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: P2146 [NOI2015] 软件包管理器</span></span><br><span class="line"><span class="comment">// Contest: Luogu</span></span><br><span class="line"><span class="comment">// URL: https://www.luogu.com.cn/problem/P2146</span></span><br><span class="line"><span class="comment">// Memory Limit: 125 MB</span></span><br><span class="line"><span class="comment">// Time Limit: 1000 ms</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Powered by CP Editor (https://cpeditor.org)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span>&#123;</span><br><span class="line"><span class="type">int</span> to,link;</span><br><span class="line">&#125;E[<span class="number">200005</span>];</span><br><span class="line"><span class="type">int</span> head[<span class="number">100005</span>],tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addE</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">E[++tot].link=head[u];</span><br><span class="line">E[tot].to=v;</span><br><span class="line">head[u]=tot;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dep[<span class="number">100001</span>],siz[<span class="number">100001</span>],hson[<span class="number">100001</span>],fa[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">fa[now]=f;</span><br><span class="line">siz[now]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==f)<span class="keyword">continue</span>;</span><br><span class="line">dep[E[i].to]=dep[now]+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs1</span>(E[i].to,now);</span><br><span class="line">siz[now]+=siz[E[i].to];</span><br><span class="line"><span class="keyword">if</span>(siz[E[i].to]&gt;siz[hson[now]])hson[now]=E[i].to;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dfn[<span class="number">100001</span>],rk[<span class="number">100001</span>],dfncnt,ltop[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> top)</span></span>&#123;</span><br><span class="line">ltop[now]=top;</span><br><span class="line">dfn[now]=++dfncnt;</span><br><span class="line">rk[dfncnt]=now;</span><br><span class="line"><span class="keyword">if</span>(!hson[now])<span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(hson[now],top);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==fa[now]||E[i].to==hson[now])<span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(E[i].to,E[i].to);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> xds[<span class="number">400001</span>];<span class="comment">//统计 `1` 的个数</span></span><br><span class="line"><span class="type">int</span> lazy[<span class="number">400001</span>];<span class="comment">//1-&gt;全部置 `1`;2-&gt;全部置 `0`</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line">xds[now]=xds[now&lt;&lt;<span class="number">1</span>]+xds[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!lazy[now])<span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(lazy[now]==<span class="number">1</span>)&#123;</span><br><span class="line">lazy[now&lt;&lt;<span class="number">1</span>]=lazy[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">xds[now&lt;&lt;<span class="number">1</span>]=mid-l+<span class="number">1</span>;</span><br><span class="line">xds[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=r-mid;</span><br><span class="line">lazy[now]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">lazy[now&lt;&lt;<span class="number">1</span>]=lazy[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">xds[now&lt;&lt;<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">xds[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">lazy[now]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> sl,<span class="type">int</span> sr,<span class="type">bool</span> ty)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==sl&amp;&amp;r==sr)&#123;</span><br><span class="line"><span class="type">int</span> org=xds[now];</span><br><span class="line"><span class="keyword">if</span>(ty==<span class="number">1</span>)lazy[now]=<span class="number">1</span>,xds[now]=r-l+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> lazy[now]=<span class="number">2</span>,xds[now]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">abs</span>(org-xds[now]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushdown</span>(now,l,r);</span><br><span class="line"><span class="comment">//cerr&lt;&lt;now&lt;&lt;&quot; &quot;&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;&quot; &quot;&lt;&lt;sl&lt;&lt;&quot; &quot;&lt;&lt;sr&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>,res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(sl&lt;=mid)res+=<span class="built_in">upd</span>(now&lt;&lt;<span class="number">1</span>,l,mid,sl,<span class="built_in">min</span>(sr,mid),ty);</span><br><span class="line"><span class="keyword">if</span>(sr&gt;mid)res+=<span class="built_in">upd</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,<span class="built_in">max</span>(sl,mid+<span class="number">1</span>),sr,ty);</span><br><span class="line"><span class="built_in">pushup</span>(now);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mdf</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(u)res+=<span class="built_in">upd</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[ltop[u]],dfn[u],<span class="number">1</span>),u=fa[ltop[u]];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)cin&gt;&gt;x,<span class="built_in">addE</span>(x+<span class="number">1</span>,i);</span><br><span class="line">cin&gt;&gt;q;</span><br><span class="line"><span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">cin&gt;&gt;s&gt;&gt;x;</span><br><span class="line">x++;</span><br><span class="line"><span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;i&#x27;</span>)cout&lt;&lt;<span class="built_in">mdf</span>(x)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="built_in">upd</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[x],dfn[x]+siz[x]<span class="number">-1</span>,<span class="number">0</span>)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线段树记得开 $4$ 倍空间！！！！</p><h3 id="例题（？）：P3258">例题（？）：P3258</h3><p>树上差分例题。</p><p>细节较多，但是题意是真的读不懂。</p><p>小猫第一次要到达 $a_1$，所以显然先要在 $a_1$ 处拿一块糖果。</p><p>然后出发时的房间都不用拿糖果，于是要对 $a_1\sim a_n$ 去重。</p><p>然后就是普通点差分即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: P3258 [JLOI2014] 松鼠的新家</span></span><br><span class="line"><span class="comment">// Contest: Luogu</span></span><br><span class="line"><span class="comment">// URL: https://www.luogu.com.cn/problem/P3258</span></span><br><span class="line"><span class="comment">// Memory Limit: 125 MB</span></span><br><span class="line"><span class="comment">// Time Limit: 1000 ms</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Powered by CP Editor (https://cpeditor.org)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span>&#123;</span><br><span class="line"><span class="type">int</span> to,link;</span><br><span class="line">&#125;E[<span class="number">600001</span>];</span><br><span class="line"><span class="type">int</span> head[<span class="number">300001</span>],tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addE</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">E[++tot].link=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line">E[tot].to=v;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> w[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> fa[<span class="number">300001</span>][<span class="number">26</span>],dep[<span class="number">300001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">fa[now][<span class="number">0</span>]=f;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;fa[now][i];)i++,fa[now][i]=fa[fa[now][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==f)<span class="keyword">continue</span>;</span><br><span class="line">dep[E[i].to]=dep[now]+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(E[i].to,now);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[u]&gt;dep[v])<span class="built_in">swap</span>(u,v);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=dep[v]-dep[u],ci=<span class="number">0</span>;i;i&gt;&gt;=<span class="number">1</span>,ci++)<span class="keyword">if</span>(i&amp;<span class="number">1</span>)v=fa[v][ci];</span><br><span class="line"><span class="keyword">if</span>(u==v)<span class="keyword">return</span> u;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">23</span>;i&gt;=<span class="number">0</span>;i--)<span class="keyword">if</span>(fa[u][i]!=fa[v][i])u=fa[u][i],v=fa[v][i];</span><br><span class="line"><span class="keyword">return</span> fa[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans[<span class="number">300001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==fa[now][<span class="number">0</span>])<span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">calc</span>(E[i].to);</span><br><span class="line">ans[now]+=ans[E[i].to];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Q[<span class="number">300001</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;Q[i];</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)cin&gt;&gt;x&gt;&gt;y,<span class="built_in">addE</span>(x,y),<span class="built_in">addE</span>(y,x);</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="type">int</span> lca=<span class="built_in">LCA</span>(Q[i],Q[i+<span class="number">1</span>]);</span><br><span class="line">ans[Q[i]]++,ans[Q[i+<span class="number">1</span>]]++,ans[lca]--,ans[fa[lca][<span class="number">0</span>]]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">calc</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)ans[Q[i]]--;</span><br><span class="line">ans[Q[<span class="number">1</span>]]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题：P4315">例题：P4315</h3><p>树剖 + 线段树的综合题，很适合练手。</p><p>我这道题线段树写挂了，然后调了 2h。</p><p>没什么可说的，注意路径 $LCA$ 不要查询或修改，然后注意标记下放即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: P4315 月下“毛景树”</span></span><br><span class="line"><span class="comment">// Contest: Luogu</span></span><br><span class="line"><span class="comment">// URL: https://www.luogu.com.cn/problem/P4315</span></span><br><span class="line"><span class="comment">// Memory Limit: 125 MB</span></span><br><span class="line"><span class="comment">// Time Limit: 1000 ms</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Powered by CP Editor (https://cpeditor.org)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string s;</span><br><span class="line"><span class="type">int</span> x,y,z;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span>&#123;</span><br><span class="line"><span class="type">int</span> to,link,w;</span><br><span class="line">&#125;E[<span class="number">200001</span>];</span><br><span class="line"><span class="type">int</span> head[<span class="number">100001</span>],tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addE</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">E[++tot].link=head[u];</span><br><span class="line">E[tot].to=v;</span><br><span class="line">E[tot].w=w;</span><br><span class="line">head[u]=tot;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dw[<span class="number">100001</span>];</span><br><span class="line"><span class="type">int</span> dep[<span class="number">100001</span>],fa[<span class="number">100001</span>],siz[<span class="number">100001</span>],hson[<span class="number">100001</span>],w[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">fa[now]=f;</span><br><span class="line">siz[now]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==f)<span class="keyword">continue</span>;</span><br><span class="line">dep[E[i].to]=dep[now]+<span class="number">1</span>;</span><br><span class="line">w[E[i].to]=E[i].w;</span><br><span class="line">dw[(i+<span class="number">1</span>)/<span class="number">2</span>]=E[i].to;</span><br><span class="line"><span class="built_in">dfs1</span>(E[i].to,now);</span><br><span class="line">siz[now]+=siz[E[i].to];</span><br><span class="line"><span class="keyword">if</span>(siz[E[i].to]&gt;siz[hson[now]])hson[now]=E[i].to;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dfn[<span class="number">100001</span>],rk[<span class="number">100001</span>],dfncnt,ltop[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> top)</span></span>&#123;</span><br><span class="line">ltop[now]=top;</span><br><span class="line">dfn[now]=++dfncnt;</span><br><span class="line">rk[dfncnt]=now;</span><br><span class="line"><span class="keyword">if</span>(!hson[now])<span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(hson[now],top);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==fa[now]||E[i].to==hson[now])<span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(E[i].to,E[i].to);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> xds[<span class="number">400001</span>],sumtag[<span class="number">400001</span>],covtag[<span class="number">400001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line">xds[now]=<span class="built_in">max</span>(xds[now&lt;&lt;<span class="number">1</span>],xds[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line"><span class="comment">//assert(xds[now]!=98318);</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bulid</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">xds[now]=w[rk[l]];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">bulid</span>(now&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line"><span class="built_in">bulid</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">pushup</span>(now);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(!(covtag[now]&amp;&amp;sumtag[now]));</span><br><span class="line"><span class="keyword">if</span>(covtag[now])&#123;<span class="comment">//covtag存要覆盖的数+1</span></span><br><span class="line">covtag[now]--;</span><br><span class="line">sumtag[now&lt;&lt;<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">sumtag[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">xds[now&lt;&lt;<span class="number">1</span>]=covtag[now];</span><br><span class="line">xds[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=covtag[now];</span><br><span class="line">covtag[now&lt;&lt;<span class="number">1</span>]=covtag[now]+<span class="number">1</span>;</span><br><span class="line">covtag[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=covtag[now]+<span class="number">1</span>;</span><br><span class="line">covtag[now]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sumtag[now])&#123;</span><br><span class="line"><span class="keyword">if</span>(covtag[now&lt;&lt;<span class="number">1</span>])covtag[now&lt;&lt;<span class="number">1</span>]+=sumtag[now],xds[now&lt;&lt;<span class="number">1</span>]=covtag[now&lt;&lt;<span class="number">1</span>]<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> sumtag[now&lt;&lt;<span class="number">1</span>]+=sumtag[now],xds[now&lt;&lt;<span class="number">1</span>]+=sumtag[now];</span><br><span class="line"><span class="keyword">if</span>(covtag[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])covtag[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=sumtag[now],xds[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=covtag[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> sumtag[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=sumtag[now],xds[now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=sumtag[now];</span><br><span class="line">sumtag[now]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cov</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> sl,<span class="type">int</span> sr,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==sl&amp;&amp;r==sr)&#123;</span><br><span class="line">covtag[now]=v+<span class="number">1</span>;</span><br><span class="line">sumtag[now]=<span class="number">0</span>;</span><br><span class="line">xds[now]=v;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushdown</span>(now,l,r);</span><br><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(sl&lt;=mid)<span class="built_in">cov</span>(now&lt;&lt;<span class="number">1</span>,l,mid,sl,<span class="built_in">min</span>(sr,mid),v);</span><br><span class="line"><span class="keyword">if</span>(sr&gt;mid)<span class="built_in">cov</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,<span class="built_in">max</span>(sl,mid+<span class="number">1</span>),sr,v);</span><br><span class="line"><span class="built_in">pushup</span>(now);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> sl,<span class="type">int</span> sr,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==sl&amp;&amp;r==sr)&#123;</span><br><span class="line"><span class="keyword">if</span>(covtag[now])covtag[now]+=v;</span><br><span class="line"><span class="keyword">else</span> sumtag[now]+=v;</span><br><span class="line">xds[now]+=v;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushdown</span>(now,l,r);</span><br><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(sl&lt;=mid)<span class="built_in">add</span>(now&lt;&lt;<span class="number">1</span>,l,mid,sl,<span class="built_in">min</span>(mid,sr),v);</span><br><span class="line"><span class="keyword">if</span>(sr&gt;mid)<span class="built_in">add</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,<span class="built_in">max</span>(sl,mid+<span class="number">1</span>),sr,v);</span><br><span class="line"><span class="built_in">pushup</span>(now);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getmax</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> sl,<span class="type">int</span> sr)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==sl&amp;&amp;r==sr)<span class="keyword">return</span> xds[now];</span><br><span class="line"><span class="built_in">pushdown</span>(now,l,r);</span><br><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>,res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(sl&lt;=mid)res=<span class="built_in">max</span>(res,<span class="built_in">getmax</span>(now&lt;&lt;<span class="number">1</span>,l,mid,sl,<span class="built_in">min</span>(sr,mid)));</span><br><span class="line"><span class="keyword">if</span>(sr&gt;mid)res=<span class="built_in">max</span>(res,<span class="built_in">getmax</span>(now&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,<span class="built_in">max</span>(sl,mid+<span class="number">1</span>),sr));</span><br><span class="line"><span class="built_in">pushup</span>(now);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">uadd</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(ltop[u]!=ltop[v])&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[ltop[u]]&gt;dep[ltop[v]])<span class="built_in">add</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[ltop[u]],dfn[u],w),u=fa[ltop[u]];</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">add</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[ltop[v]],dfn[v],w),v=fa[ltop[v]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(u!=v)&#123;</span><br><span class="line"><span class="keyword">if</span>(dfn[u]&gt;dfn[v])<span class="built_in">swap</span>(u,v);</span><br><span class="line"><span class="built_in">add</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[u]+<span class="number">1</span>,dfn[v],w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ucover</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(ltop[u]!=ltop[v])&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[ltop[u]]&gt;dep[ltop[v]])<span class="built_in">cov</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[ltop[u]],dfn[u],w),u=fa[ltop[u]];</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cov</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[ltop[v]],dfn[v],w),v=fa[ltop[v]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(u!=v)&#123;</span><br><span class="line"><span class="keyword">if</span>(dfn[u]&gt;dfn[v])<span class="built_in">swap</span>(u,v);</span><br><span class="line"><span class="built_in">cov</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[u]+<span class="number">1</span>,dfn[v],w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmax</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(ltop[u]!=ltop[v])&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[ltop[u]]&gt;dep[ltop[v]])res=<span class="built_in">max</span>(res,<span class="built_in">getmax</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[ltop[u]],dfn[u])),u=fa[ltop[u]];</span><br><span class="line"><span class="keyword">else</span> res=<span class="built_in">max</span>(res,<span class="built_in">getmax</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[ltop[v]],dfn[v])),v=fa[ltop[v]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(u!=v)&#123;</span><br><span class="line"><span class="keyword">if</span>(dfn[u]&gt;dfn[v])<span class="built_in">swap</span>(u,v);</span><br><span class="line">res=<span class="built_in">max</span>(res,<span class="built_in">getmax</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[u]+<span class="number">1</span>,dfn[v]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)cin&gt;&gt;x&gt;&gt;y&gt;&gt;z,<span class="built_in">addE</span>(x,y,z),<span class="built_in">addE</span>(y,x,z);</span><br><span class="line"><span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">bulid</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="type">int</span> de=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">de++;</span><br><span class="line"><span class="comment">//cout&lt;&lt;de&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line"><span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;S&#x27;</span>)<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;M&#x27;</span>)cin&gt;&gt;x&gt;&gt;y,cout&lt;&lt;<span class="built_in">qmax</span>(x,y)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;A&#x27;</span>)cin&gt;&gt;x&gt;&gt;y&gt;&gt;z,<span class="built_in">uadd</span>(x,y,z);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s[<span class="number">1</span>]==<span class="string">&#x27;h&#x27;</span>)cin&gt;&gt;x&gt;&gt;y,<span class="built_in">cov</span>(<span class="number">1</span>,<span class="number">1</span>,n,dfn[dw[x]],dfn[dw[x]],y);</span><br><span class="line"><span class="keyword">else</span> cin&gt;&gt;x&gt;&gt;y&gt;&gt;z,<span class="built_in">ucover</span>(x,y,z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于结束了，之后再补剩余的题（理论来讲还有 $3$ 道）。</p><h1>树分治</h1><p>分为点分治，边分治，和点分树，边分树。</p><p>此处先只写点分治，其他的科技后面再补。</p><p><a href="https://www.luogu.com.cn/blog/command-block/shu-fen-zhi-xiao-ji">1</a></p><p><a href="https://www.luogu.com.cn/blog/jzp1115/bian-fen-zhi">2</a></p><h2 id="点分治">点分治</h2><p>本来想写 $3$ 道点分治的，结果这三道都可以用 dsu 做，那么，就先写两道，然后有一道用 dsu 和点分治都写一遍，另外一道就只用点分治写就行了。</p><p>小声 bb：虚树会鸽，所以写完这个和树哈希就跑路了。</p><p>点分治常用于处理大规模路径信息。</p><p>具体地，我们每次选取一个点，处理经过该点的所有路径的信息，然后删去该点，递归处理该点所有子树。假设共递归 $h$ 层，时间复杂度 $O(hn)$。</p><p>显然，每块取重心分治最优，时间复杂度 $O(n\log n)$。</p><h3 id="例题：P3806">例题：P3806</h3><p>提供两种 $O(mn\log n)$ 做法。</p><ol><li class="lvl-3"><p>dsu</p></li></ol><p>当我使用 dsu：无语死了，这是什么简单题。</p><p>不管输出格式一发就过了，40ms。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: P3806 【模板】点分治 1</span></span><br><span class="line"><span class="comment">// Contest: Luogu</span></span><br><span class="line"><span class="comment">// URL: https://www.luogu.com.cn/problem/P3806</span></span><br><span class="line"><span class="comment">// Memory Limit: 500 MB</span></span><br><span class="line"><span class="comment">// Time Limit: 200000 ms</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Powered by CP Editor (https://cpeditor.org)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,x,y,z;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span>&#123;</span><br><span class="line"><span class="type">int</span> to,link,w;</span><br><span class="line">&#125;E[<span class="number">20001</span>];</span><br><span class="line"><span class="type">int</span> head[<span class="number">10001</span>],tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addE</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">E[++tot].link=head[u];</span><br><span class="line">E[tot].to=v;</span><br><span class="line">head[u]=tot;</span><br><span class="line">E[tot].w=w;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dep[<span class="number">10001</span>],siz[<span class="number">10001</span>],fa[<span class="number">10001</span>],hson[<span class="number">10001</span>];</span><br><span class="line"><span class="type">int</span> R[<span class="number">10001</span>],L[<span class="number">10001</span>],rk[<span class="number">10001</span>],dfncnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">fa[now]=f;</span><br><span class="line">siz[now]=<span class="number">1</span>;</span><br><span class="line">L[now]=++dfncnt;</span><br><span class="line">rk[dfncnt]=now;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==f)<span class="keyword">continue</span>;</span><br><span class="line">dep[E[i].to]=dep[now]+E[i].w;</span><br><span class="line"><span class="built_in">dfs1</span>(E[i].to,now);</span><br><span class="line">siz[now]+=siz[E[i].to];</span><br><span class="line"><span class="keyword">if</span>(siz[E[i].to]&gt;siz[hson[now]])hson[now]=E[i].to;</span><br><span class="line">&#125;</span><br><span class="line">R[now]=dfncnt;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Q[<span class="number">101</span>];</span><br><span class="line"><span class="type">bool</span> ans[<span class="number">101</span>];</span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dsu</span><span class="params">(<span class="type">int</span> now,<span class="type">bool</span> fl=<span class="number">0</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==fa[now]||E[i].to==hson[now])<span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dsu</span>(E[i].to);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(hson[now])<span class="built_in">dsu</span>(hson[now],<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==fa[now]||E[i].to==hson[now])<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=L[E[i].to];j&lt;=R[E[i].to];j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=m;k++)&#123;</span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">count</span>(Q[k]+<span class="number">2</span>*dep[now]-dep[rk[j]]))ans[k]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=L[E[i].to];j&lt;=R[E[i].to];j++)s.<span class="built_in">insert</span>(dep[rk[j]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=m;k++)&#123;</span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">count</span>(dep[now]+Q[k]))ans[k]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">s.<span class="built_in">insert</span>(dep[now]);</span><br><span class="line"><span class="keyword">if</span>(fl)<span class="keyword">return</span>;</span><br><span class="line">s.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="type">int</span> x,y,z;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)cin&gt;&gt;x&gt;&gt;y&gt;&gt;z,<span class="built_in">addE</span>(x,y,z),<span class="built_in">addE</span>(y,x,z);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)cin&gt;&gt;Q[i];</span><br><span class="line"><span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">dsu</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)cout&lt;&lt;(ans[i]?<span class="string">&quot;AYE\n&quot;</span>:<span class="string">&quot;NAY\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于可以开 $10^4$ 个 <code>unordered_set</code>，这道题应该还可以继续优化，但是作者太懒了。</p><ol start="2"><li class="lvl-3"><p>点分治</p></li></ol><p>重心写挂了，然后虚空调试 1.5h，草！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: P3806 【模板】点分治 1</span></span><br><span class="line"><span class="comment">// Contest: Luogu</span></span><br><span class="line"><span class="comment">// URL: https://www.luogu.com.cn/problem/P3806</span></span><br><span class="line"><span class="comment">// Memory Limit: 500 MB</span></span><br><span class="line"><span class="comment">// Time Limit: 200000 ms</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Powered by CP Editor (https://cpeditor.org)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span>&#123;</span><br><span class="line"><span class="type">int</span> to,link,w;</span><br><span class="line">&#125;E[<span class="number">20001</span>];</span><br><span class="line"><span class="type">int</span> head[<span class="number">10001</span>],tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addE</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">E[++tot].w=w;</span><br><span class="line">E[tot].to=v;</span><br><span class="line">E[tot].link=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Q[<span class="number">101</span>],ans[<span class="number">101</span>];</span><br><span class="line"><span class="type">int</span> dep[<span class="number">10001</span>],dis[<span class="number">10001</span>],dp[<span class="number">10001</span>]=&#123;<span class="number">1000000000</span>&#125;,fa[<span class="number">10001</span>];</span><br><span class="line"><span class="type">int</span> vis[<span class="number">10001</span>],sum,siz[<span class="number">10001</span>];</span><br><span class="line"><span class="type">int</span> rt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">fa[now]=f;</span><br><span class="line">sum++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==fa[now]||vis[E[i].to])<span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs</span>(E[i].to,now);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> L[<span class="number">10001</span>],R[<span class="number">10001</span>],rk[<span class="number">10001</span>],dfncnt;</span><br><span class="line"><span class="type">void</span> _dfs(<span class="type">int</span> now,<span class="type">int</span> f)&#123;</span><br><span class="line">L[now]=++dfncnt;</span><br><span class="line">rk[dfncnt]=now;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==f||vis[E[i].to])<span class="keyword">continue</span>;</span><br><span class="line">dep[E[i].to]=dep[now]+E[i].w;</span><br><span class="line">_dfs(E[i].to,now);</span><br><span class="line">&#125;</span><br><span class="line">R[now]=dfncnt;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> _getrt(<span class="type">int</span> now,<span class="type">int</span> f)&#123;</span><br><span class="line">siz[now]=<span class="number">1</span>;</span><br><span class="line">dp[now]=<span class="number">0</span>;<span class="comment">//!!!注意清零!!!</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==f||vis[E[i].to])<span class="keyword">continue</span>;</span><br><span class="line">_getrt(E[i].to,now);</span><br><span class="line">siz[now]+=siz[E[i].to];</span><br><span class="line">dp[now]=<span class="built_in">max</span>(siz[E[i].to],dp[now]);</span><br><span class="line">&#125;</span><br><span class="line">dp[now]=<span class="built_in">max</span>(dp[now],sum-siz[now]);</span><br><span class="line"><span class="keyword">if</span>(dp[now]&lt;dp[rt])rt=now;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getrt</span><span class="params">(<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line">rt=dfncnt=<span class="number">0</span>;</span><br><span class="line">_getrt(now,<span class="number">0</span>);</span><br><span class="line">dep[rt]=<span class="number">0</span>;</span><br><span class="line">_dfs(rt,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> s[<span class="number">10000001</span>];</span><br><span class="line"><span class="type">int</span> in[<span class="number">10000001</span>],cn;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line">vis[now]=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//cerr&lt;&lt;__LINE__&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">s[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//cerr&lt;&lt;__LINE__&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">cn=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[E[i].to])<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=L[E[i].to];j&lt;=R[E[i].to];j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=m;k++)<span class="keyword">if</span>(Q[k]-dep[rk[j]]&gt;=<span class="number">0</span>&amp;&amp;Q[k]-dep[rk[j]]&lt;=<span class="number">1e7</span>&amp;&amp;s[Q[k]-dep[rk[j]]])ans[k]=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//cerr&lt;&lt;__LINE__&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=L[E[i].to];j&lt;=R[E[i].to];j++)<span class="keyword">if</span>(dep[rk[j]]&lt;=<span class="number">1e7</span>&amp;&amp;!s[dep[rk[j]]])s[dep[rk[j]]]=<span class="number">1</span>,in[++cn]=dep[rk[j]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cn;i++)s[in[i]]=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//cout&lt;&lt;now&lt;&lt;&quot; &quot;&lt;&lt;__LINE__&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[E[i].to])<span class="keyword">continue</span>;</span><br><span class="line">sum=siz[E[i].to];</span><br><span class="line"><span class="built_in">getrt</span>(E[i].to);</span><br><span class="line"><span class="comment">//cerr&lt;&lt;rt&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line"><span class="built_in">solve</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="type">int</span> x,y,z;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)cin&gt;&gt;x&gt;&gt;y&gt;&gt;z,<span class="built_in">addE</span>(x,y,z),<span class="built_in">addE</span>(y,x,z);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)cin&gt;&gt;Q[i];</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">getrt</span>(<span class="number">1</span>),<span class="built_in">solve</span>(rt);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)cout&lt;&lt;(ans[i]?<span class="string">&quot;AYE\n&quot;</span>:<span class="string">&quot;NAY\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题：P4178">例题：P4178</h3><p>考虑这道题是求 $[0,k]$ 的路径数量，那么我们不难发现这道题就是单点修改，区间前缀和查询，使用树状数组维护即可。</p><p>注意树状数组的上界是 $k$，不是 $n$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: P4178 Tree</span></span><br><span class="line"><span class="comment">// Contest: Luogu</span></span><br><span class="line"><span class="comment">// URL: https://www.luogu.com.cn/problem/P4178</span></span><br><span class="line"><span class="comment">// Memory Limit: 500 MB</span></span><br><span class="line"><span class="comment">// Time Limit: 1000 ms</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Powered by CP Editor (https://cpeditor.org)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span>&#123;</span><br><span class="line"><span class="type">int</span> to,link,w;</span><br><span class="line">&#125;E[<span class="number">800001</span>];</span><br><span class="line"><span class="type">int</span> head[<span class="number">400001</span>],tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addE</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">E[++tot].w=w;</span><br><span class="line">E[tot].to=v;</span><br><span class="line">E[tot].link=head[u];</span><br><span class="line">head[u]=tot;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dep[<span class="number">400001</span>],vis[<span class="number">400001</span>],siz[<span class="number">400001</span>],dp[<span class="number">400001</span>]=&#123;<span class="number">998244353</span>&#125;,rt;</span><br><span class="line"><span class="type">int</span> sum,dfncnt,L[<span class="number">400001</span>],R[<span class="number">400001</span>];</span><br><span class="line"><span class="type">int</span> T[<span class="number">400002</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getsum</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">res+=T[x];</span><br><span class="line"><span class="comment">//cout&lt;&lt;x&lt;&lt;&quot; getting\n&quot;;</span></span><br><span class="line">x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(x&lt;=k)&#123;<span class="comment">//注意树状数组范围</span></span><br><span class="line">T[x]+=v;</span><br><span class="line"><span class="comment">//cout&lt;&lt;x&lt;&lt;&quot; updating\n&quot;;</span></span><br><span class="line">x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> rk[<span class="number">400001</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">L[now]=++dfncnt;</span><br><span class="line">rk[dfncnt]=now;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==f||vis[E[i].to])<span class="keyword">continue</span>;</span><br><span class="line">dep[E[i].to]=dep[now]+E[i].w;</span><br><span class="line"><span class="built_in">dfs</span>(E[i].to,now);</span><br><span class="line">&#125;</span><br><span class="line">R[now]=dfncnt;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> _getrt(<span class="type">int</span> now,<span class="type">int</span> f)&#123;</span><br><span class="line">dp[now]=<span class="number">0</span>;</span><br><span class="line">siz[now]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i].to==f||vis[E[i].to])<span class="keyword">continue</span>;</span><br><span class="line">_getrt(E[i].to,now);</span><br><span class="line">siz[now]+=siz[E[i].to];</span><br><span class="line">dp[now]=<span class="built_in">max</span>(siz[E[i].to],dp[now]);</span><br><span class="line">&#125;</span><br><span class="line">dp[now]=<span class="built_in">max</span>(dp[now],sum-siz[now]);</span><br><span class="line"><span class="keyword">if</span>(dp[now]&lt;dp[rt])rt=now;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getrt</span><span class="params">(<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line">rt=dfncnt=<span class="number">0</span>;</span><br><span class="line">sum=siz[now];</span><br><span class="line">_getrt(now,<span class="number">0</span>);</span><br><span class="line">dep[rt]=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">dfs</span>(rt,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//cerr&lt;&lt;rt&lt;&lt;&quot; debug\n&quot;;</span></span><br><span class="line"><span class="comment">//cerr&lt;&lt;__LINE__&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line">vis[now]=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//upd(1,1);</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[E[i].to])<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=L[E[i].to];j&lt;=R[E[i].to];j++)<span class="keyword">if</span>(dep[rk[j]]&lt;=k)ans+=<span class="built_in">getsum</span>(k-dep[rk[j]])+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=L[E[i].to];j&lt;=R[E[i].to];j++)<span class="keyword">if</span>(dep[rk[j]]&lt;=k)<span class="built_in">upd</span>(dep[rk[j]],<span class="number">1</span>);</span><br><span class="line"><span class="comment">//cerr&lt;&lt;E[i].to&lt;&lt;&quot; &quot;&lt;&lt;ans&lt;&lt;&quot; test\n&quot;;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cerr&lt;&lt;now&lt;&lt;&quot; &quot;&lt;&lt;ans&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)T[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now];i;i=E[i].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[E[i].to])<span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">getrt</span>(E[i].to);</span><br><span class="line"><span class="built_in">solve</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="type">int</span> x,y,z;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)cin&gt;&gt;x&gt;&gt;y&gt;&gt;z,<span class="built_in">addE</span>(x,y,z),<span class="built_in">addE</span>(y,x,z);</span><br><span class="line">cin&gt;&gt;k;</span><br><span class="line">siz[<span class="number">1</span>]=n;</span><br><span class="line"><span class="built_in">getrt</span>(<span class="number">1</span>),<span class="built_in">solve</span>(rt);</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还剩下两道题作为以后的练习题，直接进入树哈希。</p><h1>树同构（树哈希）</h1><p>顾名思义，就是检查两棵树的结构是否相同。</p><p>有 AHU 算法和树哈希两种比较方式，而树哈希更常用，于是就用树哈希来求解。</p><p>最常用的树哈希基于多重集的一个哈希函数。由于树点有子节点，那么哈希函数可以写成：<br>$$<br>f(x)=(c+\sum_{v\in son(x)}g(f(v)))\bmod m<br>$$<br>其中 $g$ 函数是一个映射，通常使用 xor shift：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">shift</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> x)</span></span>&#123;</span><br><span class="line">    x^=mask;</span><br><span class="line">    x^=x&lt;&lt;<span class="number">13</span>;</span><br><span class="line">    x^=x&gt;&gt;<span class="number">7</span>;</span><br><span class="line">    x^=x&lt;&lt;<span class="number">17</span>;</span><br><span class="line">    x^=mask;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然可以选择不同的移位位数，但是 <code>x^=mask</code> 是防止树哈希被卡的关键一步。</p><p>看样子错误率较高？错误的。</p><p>有人证明了当哈希值域 $m=O(n^x)(x\geq3)$ 时，它的错误率是 $O(\frac{1}{n})$，甚至可以达到 $O(\frac{1}{\operatorname{poly}(n)})$ 的，但是看不懂，所以不搬了。</p><p>模板题：P5043 [BJOI2015]树的同构</p><p>对于无根树，我们要找一个关键点来进行树哈希。（或者使用换根 dp）</p><p>考虑树的重心只有两个，那么可以以重心为根进行哈希，如果重心有两个，就取较小的一个哈希值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem: P5043 【模板】树同构（[BJOI2015]树的同构）</span></span><br><span class="line"><span class="comment">// Contest: Luogu</span></span><br><span class="line"><span class="comment">// URL: https://www.luogu.com.cn/problem/P5043</span></span><br><span class="line"><span class="comment">// Memory Limit: 250 MB</span></span><br><span class="line"><span class="comment">// Time Limit: 1000 ms</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Powered by CP Editor (https://cpeditor.org)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n[<span class="number">51</span>],m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">line</span>&#123;</span><br><span class="line"><span class="type">int</span> to,link;</span><br><span class="line">&#125;E[<span class="number">101</span>][<span class="number">51</span>];</span><br><span class="line"><span class="type">int</span> head[<span class="number">51</span>][<span class="number">51</span>],tot[<span class="number">51</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addE</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">E[++tot[now]][now].link=head[u][now];</span><br><span class="line">E[tot[now]][now].to=v;</span><br><span class="line">head[u][now]=tot[now];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> rt[<span class="number">2</span>],siz[<span class="number">51</span>],dp[<span class="number">51</span>]=&#123;<span class="number">998244353</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getrt</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> now,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">dp[now]=<span class="number">0</span>;</span><br><span class="line">siz[now]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now][id];i;i=E[i][id].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i][id].to==f)<span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">getrt</span>(id,E[i][id].to,now);</span><br><span class="line">siz[now]+=siz[E[i][id].to];</span><br><span class="line">dp[now]=<span class="built_in">max</span>(dp[now],siz[E[i][id].to]);</span><br><span class="line">&#125;</span><br><span class="line">dp[now]=<span class="built_in">max</span>(dp[now],n[id]-siz[now]);</span><br><span class="line"><span class="keyword">if</span>(dp[now]==dp[rt[<span class="number">0</span>]])rt[<span class="number">1</span>]=now;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(dp[now]&lt;dp[rt[<span class="number">0</span>]])rt[<span class="number">0</span>]=now,rt[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long<span class="comment">//自然溢出</span></span></span><br><span class="line">ull hh[<span class="number">51</span>];</span><br><span class="line"><span class="comment">//const ull mod=13331;</span></span><br><span class="line">ull mask=chrono::steady_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>();</span><br><span class="line"><span class="function">ull <span class="title">S</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">x^=mask;</span><br><span class="line">x^=x&lt;&lt;<span class="number">5</span>;</span><br><span class="line">x^=x&gt;&gt;<span class="number">7</span>;</span><br><span class="line">x^=x&lt;&lt;<span class="number">13</span>;</span><br><span class="line">x^=mask;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ull <span class="title">gethash</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> now,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> H=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[now][id];i;i=E[i][id].link)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i][id].to==f)<span class="keyword">continue</span>;</span><br><span class="line">H=(H+<span class="built_in">S</span>(<span class="built_in">gethash</span>(id,E[i][id].to,now)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans[<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;m;</span><br><span class="line"><span class="type">int</span> temp;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">cin&gt;&gt;n[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n[i];j++)&#123;</span><br><span class="line">cin&gt;&gt;temp;</span><br><span class="line"><span class="keyword">if</span>(temp)<span class="built_in">addE</span>(i,temp,j),<span class="built_in">addE</span>(i,j,temp);</span><br><span class="line">&#125;</span><br><span class="line">rt[<span class="number">0</span>]=rt[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">getrt</span>(i,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">hh[i]=<span class="built_in">gethash</span>(i,rt[<span class="number">0</span>],<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(rt[<span class="number">1</span>])hh[i]=<span class="built_in">min</span>(hh[i],<span class="built_in">gethash</span>(i,rt[<span class="number">1</span>],<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(hh[i]==hh[j])&#123;</span><br><span class="line">ans[i]=j;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经测试，自然溢出的正确率最高。</p><p>下班！</p><h1>虚树</h1><p>鸽…咕咕咕…</p><h1>练习题</h1><p>鸽…咕咕咕…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;鲜花&lt;/h1&gt;
&lt;p&gt;听 Mea 讲树论，但是还是脱不了修锅的命运（&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;注：本文中，&lt;code&gt;dfs 序&lt;/code&gt; 等同于 &lt;code&gt;dfn 序&lt;/code&gt;。&lt;/p&gt;
&lt;h1&gt;树的基础&lt;/h1&gt;
&lt;h2 id=&quot;树的直径&quot;&gt;树的直径&lt;/h2</summary>
      
    
    
    
    <category term="OI" scheme="http://blog.eltaos.top/categories/OI/"/>
    
    
    <category term="OI" scheme="http://blog.eltaos.top/tags/OI/"/>
    
  </entry>
  
  <entry>
    <title>1001周总结</title>
    <link href="http://blog.eltaos.top/2023/1001%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.eltaos.top/2023/1001%E5%91%A8%E6%80%BB%E7%BB%93/</id>
    <published>2023-10-01T07:12:00.000Z</published>
    <updated>2023-10-01T07:12:42.774Z</updated>
    
    <content type="html"><![CDATA[<h2 id="鲜花">鲜花</h2><p>lxs 的歌好好听！</p><p><a href="https://npm.elemecdn.com/blog-uses/music/lxs.mp3">下载lxs.mp3</a></p><h2 id="考试">考试</h2><p>lxs contest #1(184-re)那场属于是放水了，看到不会 T2 直接不做了，赛时的时候甚至去调了一道根号分治，如如题，结果是 $r$ 和 $l$ 写反了。</p><p>lxs contest #2(188-re)挂了 20 分，因为没开 long long，如如！直接沦为暴力分。T2 写莫队乱搞过去（但是挂了 20）了，这还是我第一次考试写莫队，但是没想到可以用前缀和 $O(1)$ 解决。T1 不会是首次，但是 T3 不知道怎么算期望，T4 看不懂，直接放弃（</p><p>以下是在 #188 赛后未评讲时看懂了的题的简要思路：</p><p>#184 T1：模拟，略。</p><p>#184 T2：考虑一个结论，段数不超过 $2$，那么直接 dp 求最大单调上升子序列即可。</p><p>#188 T2：先双指针求出以每个点为起点的最短满足条件的子段，然后推式子+前缀和即可，当然，莫队这种方法对于无脑求解是很管用的，毕竟这比出题人的目标复杂度（$O(n \log^2n)$）快多了。</p><h2 id="做题">做题</h2><p>为什么国庆不讲课？</p><p><font size=5>为什么国庆不讲课？</font></p><p><font size=6>为什么国庆不讲课？</font></p><p>这导致只能补题…</p><p>如果分块的题不卡常那可以多做几道（</p><p>补了几道优先队列，准备尽量补一些 dp 的题。</p><p>计算几何该复习了…（辛普森，启动！）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;鲜花&quot;&gt;鲜花&lt;/h2&gt;
&lt;p&gt;lxs 的歌好好听！&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://npm.elemecdn.com/blog-uses/music/lxs.mp3&quot;&gt;下载lxs.mp3&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;考试&quot;&gt;考试&lt;/h2&gt;
&lt;p</summary>
      
    
    
    
    <category term="OI" scheme="http://blog.eltaos.top/categories/OI/"/>
    
    
    <category term="OI" scheme="http://blog.eltaos.top/tags/OI/"/>
    
  </entry>
  
  <entry>
    <title>20230924周总结</title>
    <link href="http://blog.eltaos.top/2023/20230924%E5%91%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.eltaos.top/2023/20230924%E5%91%A8%E6%80%BB%E7%BB%93/</id>
    <published>2023-10-01T07:11:00.000Z</published>
    <updated>2023-10-01T07:11:46.290Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1965041412&auto=1&height=66"></iframe><h1>20230924周总结</h1><p>该文同步发布到我的个人博客上。（什么？你说你不知道我的个人博客在哪里？很好！）</p><h2 id="What-I’ve-Learned">What I’ve Learned</h2><p>对于dp，除了树形dp一窍不通。讲dp优化那天全程掉线。</p><p>图写的非常顺手，Tarjan基本已掌握，就是判断题目中对于求哪些连通分量还需加强。</p><p>之前我一遇到树或者图就不想写，现在除了树或者图或者计算几何其他都只想着找规律了。</p><p>在0922（周五）那天自己把费用流的所有算法写了一遍，主要是想比较一下各种算法的效率，然后感觉现在费用流比最大流都还好写。</p><h2 id="About-Exams">About Exams</h2><p>这周只考了一场。</p><p>T1简单规律题，但是CF评级2600，笑死。</p><p>T2毒瘤计算几何，谁知道多边形的重心怎么求啊，差评。</p><p>T3，T4不会，跳了。</p><p>罚坐30min。</p><h2 id="Things-going-to-do">Things going to do</h2><ul class="lvl-0"><li class="lvl-2"><p>写费用流题解（幸亏没关题解区</p></li><li class="lvl-2"><p>狂肝dp。</p></li></ul><p>没了</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><p>&lt;br&gt;</p><h1><font size=10>鸠鸠可爱捏！</font></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=1965</summary>
      
    
    
    
    <category term="OI" scheme="http://blog.eltaos.top/categories/OI/"/>
    
    
    <category term="OI" scheme="http://blog.eltaos.top/tags/OI/"/>
    
  </entry>
  
  <entry>
    <title>Splay and LCT</title>
    <link href="http://blog.eltaos.top/2023/Splay-and-LCT/"/>
    <id>http://blog.eltaos.top/2023/Splay-and-LCT/</id>
    <published>2023-10-01T07:08:00.000Z</published>
    <updated>2020-01-19T07:13:14.397Z</updated>
    
    <content type="html"><![CDATA[<h1>前言</h1><p><strong>从这里开始，信竞的路就开始向未来延伸了</strong></p><p>之前觉得信息竞赛不过是打打电脑，敲敲代码，从来没想到这其实是对思维的一种锻炼。</p><p>信息竞赛的终端是NOI，也就是国赛，那场比赛会让一部分人极度高兴，也会让一部分人迷惘，无奈，最后退役，除这两者之外，也会有一些人陷入沉思——</p><blockquote><p>无数高二的OIer，他们两年，三年，甚至五年，六年的OI生涯，就在走出NOI赛场的那一刻，彻底终结。</p></blockquote><p>原文链接：<a href="https://blog.csdn.net/weixin_43960287/article/details/126443477?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-126443477-blog-111053886.235%5Ev38%5Epc_relevant_anti_vip&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-126443477-blog-111053886.235%5Ev38%5Epc_relevant_anti_vip&amp;utm_relevant_index=2">link</a>（经过2d左右的寻找终于找到了）</p><p>…</p><p>让我们开始吧…</p><h1>什么是Splay？</h1><p>用一个经典问题引入：</p><p>你需要维护一些数，其中需要提供以下操作：</p><ol><li class="lvl-3"><p>插入 $x$ 数</p></li><li class="lvl-3"><p>删除 $x$ 数(若有多个相同的数，应只删除一个)</p></li><li class="lvl-3"><p>查询 $x$ 数的排名(排名定义为比当前数小的数的个数 $+1$ )</p></li><li class="lvl-3"><p>查询排名为 $x$ 的数</p></li><li class="lvl-3"><p>求 $x$ 的前驱(前驱定义为小于 $x$，且最大的数)</p></li><li class="lvl-3"><p>求 $x$ 的后继(后继定义为大于 $x$，且最小的数)</p></li></ol><p>$1\leq n \leq 10^5$</p><p>因为有操作2，这道题暴力的时间复杂度是 $O(n^2)$ 的。</p><p>那么，二叉搜索树就出现了——</p><p>二叉搜索树是一种二叉树的树形数据结构，其定义如下：</p><ol><li class="lvl-3"><p>空树是二叉搜索树。</p></li><li class="lvl-3"><p>若二叉搜索树的左子树不为空，则其左子树上所有点的附加权值均小于其根节点的值。</p></li><li class="lvl-3"><p>若二叉搜索树的右子树不为空，则其右子树上所有点的附加权值均大于其根节点的值。</p></li><li class="lvl-3"><p>二叉搜索树的左右子树均为二叉搜索树。</p></li></ol><p>上述定义来源于 OI Wiki。</p><p>二叉搜索树上的基本操作所花费的时间与这棵树的高度成正比。对于一个有 $n$ 个结点的二叉搜索树中，这些操作的最优时间复杂度为 $O(\log n)$，最坏为 $O(n)$。</p><p>而 Splay 的出现就是为了防止二叉搜索树退化成链从而导致不能保证时间复杂度。</p><h1>如何实现Splay？</h1><h3 id="一些基本变量">一些基本变量</h3><table><thead><tr><th>rt</th><th>tot</th><th>fa[i]</th><th>ch[i][0/1]</th><th>v[i]</th><th>cnt[i]</th><th>stre_size[i]</th></tr></thead><tbody><tr><td>根节点编号</td><td>节点个数</td><td>父亲</td><td>左右儿子编号</td><td>节点权值</td><td>权值出现次数</td><td>子树大小或其他</td></tr></tbody></table><p>还有…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> lson 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson 1</span></span><br></pre></td></tr></table></figure><h3 id="一些基本操作">一些基本操作</h3><h4 id="maintain">maintain()</h4><p>和 pushup() 是一个道理，更新子树大小或者题中要我们维护的信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">maintain</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">stre_size[x]=stre_size[ch[x][rson]]+stre_size[ch[x][lson]]+cnt[x];<span class="comment">//这个是维护子树大小</span></span><br><span class="line"><span class="comment">//sum[x]=sum[ch[x][rson]]+sum[ch[x][rson]]+cnt[x]*v[x];//这个是维护权值和，但是多开一个数组</span></span><br><span class="line"><span class="comment">//还有其他各种各样的</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get">get()</h4><p>获取节点 $x$ 是父亲的哪个儿子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ch[fa[x]][rson]==x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="clear">clear()</h4><p>用来销毁节点 $x$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    fa[x]=v[x]=cnt[x]=stre_size[x]=ch[x][lson]=ch[x][rson]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="旋转-rotate">旋转-rotate()</h3><p>在讲 Splay 如何让二叉搜索树不退化成链前，先说说实现 Splay 最重要的操作：左旋与右旋。</p><p><img src="https://oi-wiki.org/ds/images/splay-rotate.svg" alt=""></p><p>没看明白？想想二叉搜索树的性质！旋转前后都要保证二叉搜索树的性质，也就是左 $&lt;$ 中 $&lt;$ 右！</p><p>假如说以上图右旋 2 节点为例，2 节点需要向上一层，根据二叉搜索树的性质，1 节点处的值是大于 2 节点处的值，那么在新树里，1 就是 2 的右儿子。同样的，可以推出 5 节点的值是大于 2 节点的值，同时 1 节点的值大于 5 节点的值，所以在新树中，5 是 1 的左儿子。</p><p>以此类推，我们可以推出旋转的通用方法：</p><ol><li class="lvl-3"><p>假设要旋转的节点为 $x$，它的父亲是 $y$，$x$ 是 $y$ 的 $chk$ 儿子（左 $→ 0$，右 $→ 1$），那么 $x$ 的 $chk$ $xor$ $1$ 儿子是 $y$ 的 $chk$ 儿子，<strong>还要记得把这个儿子（如果这个儿子存在的话）的父亲设为 $y$</strong>。</p></li><li class="lvl-3"><p>$y$ 的父亲为 $x$，$x$ 的 $chk$ $xor$ $1$ 儿子为 $y$。（注意按顺序来）</p></li><li class="lvl-3"><p>设原来的 $y$ 的父亲是 $z$，那么 $x$ 的父亲是 $z$，如果 $z$ 存在（不为 $0$），那么设原来 $z$ 的 $k$ 儿子是 $y$，现在 $z$ 的 $k$ 儿子是 $x$。</p></li><li class="lvl-3"><p><strong>最后从下到上更新信息即可。</strong>(易漏)</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> y=fa[x],z=fa[y];</span><br><span class="line">    <span class="type">bool</span> chk=<span class="built_in">get</span>(x);</span><br><span class="line">    fa[y]=x;</span><br><span class="line">    ch[y][chk]=ch[x][chk^<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(ch[x][chk^<span class="number">1</span>])fa[ch[x][chk^<span class="number">1</span>]]=y;</span><br><span class="line">    ch[x][chk^<span class="number">1</span>]=y;</span><br><span class="line">    fa[x]=z;</span><br><span class="line">    <span class="keyword">if</span>(z)ch[z][ch[z][rson]==y]=x;</span><br><span class="line">    <span class="built_in">maintain</span>(y);</span><br><span class="line">    <span class="built_in">maintain</span>(x);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="splay">splay()</h3><p>Splay 的最核心操作，目的是把一个节点旋转到根节点上。</p><p>分为以下几种情况：</p><ol><li class="lvl-3"><p><strong>zig</strong>操作：在 splay 操作开始时节点具有奇数深度时用于 splay 的最后一步。</p></li></ol><p><img src="https://oi-wiki.org/ds/images/splay-zig.svg" alt=""></p><p>直接将节点 $x$ 旋转即可。</p><p><s>甚至这个图和上面旋转的那个图一模一样…</s></p><ol start="2"><li class="lvl-3"><p><strong>zig-zig</strong>操作：当节点的父亲与该节点都是他们的父亲的同侧儿子时使用。</p></li></ol><p><img src="https://oi-wiki.org/ds/images/splay-zig-zig.svg" alt=""></p><p>可能有些抽象了。</p><p>如果还是直接旋转两次节点 $x$ 的话，这个图就会从这样</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/5wyjcaxi.png" alt=""></p><p>变成…</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/6eqnhvy9.png" alt=""></p><p>这样…</p><p>好像确实不是我们想要的，对吧？</p><p>稍微模拟一下过程可以发现，因为节点 $0$ 无法旋转，那么应该先旋转节点 $1$，即待旋转节点 $3$ 的父亲，在旋转节点 $3$。</p><p>具体过程演示：</p><p>整张图应该先变成这样：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/rweodtoi.png" alt=""></p><p>然后再旋转节点 $3$，变成这样：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/2f8t0vi3.png" alt=""></p><p>这就是我们想要的了，但是前提是节点 $3$ 的爷爷节点 $0$ 存在。</p><ol start="3"><li class="lvl-3"><p><strong>zig-zag</strong>操作：当节点的父亲与该节点是他们的父亲的异侧儿子时使用。</p></li></ol><p><img src="https://oi-wiki.org/ds/images/splay-zig-zag.svg" alt=""></p><p>还是老样子，先尝试只旋转节点 $x$。</p><p>整张图的变换过程差不多长这样：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/yn1i5n14.png" alt=""> $→$ <img src="https://cdn.luogu.com.cn/upload/image_hosting/j4zzq4lk.png" alt=""> $→$ <img src="https://cdn.luogu.com.cn/upload/image_hosting/lwfmjwt6.png" alt=""></p><p>诶？这好像是就是我们需要的！</p><p>于是，针对于这种情况，旋转两次原来的节点 $x$ 即可。</p><p>整合上面三种情况，就可以写出 splay() 的代码了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;fa[x];<span class="built_in">rotate</span>(x))&#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[fa[x]])<span class="built_in">rotate</span>((<span class="built_in">get</span>(x)==<span class="built_in">get</span>(fa[x]))?fa[x]:x);</span><br><span class="line">    &#125;</span><br><span class="line">    rt=x;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这可能不够，有些时候我们 splay 到一个特定节点就停了，所以还要新增一个参数，改进后的函数长这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> tar=<span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;fa[x]!=tar;<span class="built_in">rotate</span>(x))&#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[fa[x]]!=tar)<span class="built_in">rotate</span>(<span class="built_in">get</span>(x)==<span class="built_in">get</span>(fa[x])?fa[x]:x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tar==<span class="number">0</span>)rt=x;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="insert">insert()</h3><p>插入分为这几步：</p><ol><li class="lvl-3"><p>如果树是空的，直接插入根节点即可。</p></li><li class="lvl-3"><p>如果要插入的值与正遍历到的值相等，直接 <code>cnt[cur]++</code> 即可。</p></li><li class="lvl-3"><p>如果要插入的值大于当前值，则向右遍历，小于则向左遍历，直到遍历到第一个空节点时插入。</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt)&#123;</span><br><span class="line">        v[++tot]=x;</span><br><span class="line">        rt=tot;</span><br><span class="line">        cnt[rt]++;</span><br><span class="line">        <span class="built_in">maintain</span>(rt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cur=rt,buf=fa[cur];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[cur]==x)&#123;</span><br><span class="line">            cnt[cur]++;</span><br><span class="line">            <span class="built_in">maintain</span>(cur);</span><br><span class="line">            <span class="built_in">maintain</span>(buf);<span class="comment">//爸爸也要上传信息!</span></span><br><span class="line">            <span class="built_in">splay</span>(cur);<span class="comment">//最后都要splay!!!!!</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buf=cur;</span><br><span class="line">        cur=ch[cur][v[cur]&lt;x];</span><br><span class="line">        <span class="keyword">if</span>(!cur)&#123;</span><br><span class="line">            cnt[++tot]++;</span><br><span class="line">            ch[buf][v[buf]&lt;x]=tot;</span><br><span class="line">            v[tot]=x;</span><br><span class="line">            fa[tot]=buf;</span><br><span class="line">            <span class="built_in">maintian</span>(tot);</span><br><span class="line">            <span class="built_in">maintain</span>(buf);</span><br><span class="line">            <span class="built_in">splay</span>(tot);<span class="comment">//最后都要splay!!!!!!!!!!!!!!!!!!</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，如果是在特定的两个元素之间插入，那么可以将这两个元素先 splay 到根，此时这两个元素之间必然为空，直接插入即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="built_in">splay</span>(l);</span><br><span class="line">    <span class="built_in">splay</span>(r,l);</span><br><span class="line">    ch[r][lson]=++tot;</span><br><span class="line">    v[tot]=x;</span><br><span class="line">    cnt[tot]++;</span><br><span class="line">    fa[tot]=r;</span><br><span class="line">    <span class="built_in">maintain</span>(tot);</span><br><span class="line">    <span class="built_in">maintain</span>(r);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（注：上面这种插入很少见，请谨慎使用）</p><h3 id="numx-rank-search">numx_rank_search()</h3><p>即查询数 $x$ 的排名。</p><p>同样的，遍历一遍即可。</p><ol><li class="lvl-3"><p>如果当前数的值大于 $x$，则向左子树寻找。</p></li><li class="lvl-3"><p>如果当前数的值小于 $x$，则将当前排名加上 <code>stre_size[ch[cur][lson]]+cnt[cur]</code> 在向右子树遍历。</p></li><li class="lvl-3"><p>当当前数正好等于 $x$ 或当前遍历到的节点为空时，返回当前排名 +1。</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">numx_rank_search</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cur=rt,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[cur]&gt;x)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!ch[cur][lson])&#123;</span><br><span class="line">                <span class="built_in">splay</span>(cur);</span><br><span class="line">                <span class="keyword">return</span> res+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur=ch[cur][lson];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            res+=stre_size[ch[cur][lson]];</span><br><span class="line">            <span class="keyword">if</span>(v[cur]&lt;x)&#123;</span><br><span class="line">                res+=cnt[cur];</span><br><span class="line">                <span class="keyword">if</span>(!ch[cur][rson])&#123;</span><br><span class="line">                    <span class="built_in">splay</span>(cur);</span><br><span class="line">                    <span class="keyword">return</span> res+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur=ch[cur][rson];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">splay</span>(cur);</span><br><span class="line">                <span class="keyword">return</span> res+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rankx-num-search">rankx_num_search()</h3><p>即查询排名为 $x$ 的数是什么。</p><p>与 numx_rank_search() 很类似。设 $x$ 是剩余排名。</p><ol><li class="lvl-3"><p>若 $x$ 大于左子树的大小，那就将 $x$ 减去左子树的大小，再减去当前节点的 <code>cnt</code>，如果此时 $x$ 大于 $0$ ，那就可以继续向右子树寻找，否则直接返回当前的值。</p></li><li class="lvl-3"><p>若 $x$ <strong>不大于</strong>左子树的大小，直接向左子树寻找即可。</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rankx_num_search</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cur=rt;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=stre_size[ch[x][lson]])&#123;<span class="comment">//据说加了判断左子树非空会更严谨，实测确实会更快一点</span></span><br><span class="line">            cur=ch[x][lson];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x-=stre_size[ch[x][lson]]+cnt[x];</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">splay</span>(cur);</span><br><span class="line">            <span class="keyword">return</span> cur;<span class="comment">//也可返回 v[cur]</span></span><br><span class="line">        &#125;</span><br><span class="line">        cur=ch[x][rson];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="del">del()</h3><p>即删除数 $x$。</p><p>这里要用到还没有提到的函数：查找前驱。</p><h4 id="方法一">方法一</h4><p>遍历查找一遍数 $x$ 并 splay，如果找到的节点的 <code>cnt</code> 大于 $1$，那么可以直接 <code>cnt[cur]--</code> 即可。否则要合并两个子树。</p><p>如何合并？</p><ol><li class="lvl-3"><p>如果两个树有空树，直接返回那个树或者空树即可。</p></li><li class="lvl-3"><p>先将左子树中的最大值 splay 到根，然后连接右子树，更新信息即可。</p></li></ol><p>左子树中的最大值就是查找原根结点的前驱，即为左子树中一直向右最终遍历到的点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">numx_rank_search</span>(x);<span class="comment">//这一步就是查找加splay</span></span><br><span class="line">    <span class="keyword">if</span>(cnt[rt]&gt;<span class="number">1</span>)&#123;<span class="comment">//易漏!</span></span><br><span class="line">        cnt[rt]--;</span><br><span class="line">        <span class="built_in">maintain</span>(rt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!ch[rt][lson]&amp;&amp;!ch[rt][rson])&#123;</span><br><span class="line">        <span class="built_in">clear</span>(rt);</span><br><span class="line">        rt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!ch[rt][lson])&#123;</span><br><span class="line">        <span class="type">int</span> ed_rt=rt;</span><br><span class="line">        fa[ch[rt][rson]]=<span class="number">0</span>;<span class="comment">//注意是左儿子还是右儿子</span></span><br><span class="line">        rt=ch[rt][rson];</span><br><span class="line">        <span class="built_in">clear</span>(ed_rt);<span class="comment">//注意清理目标</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!ch[rt][rson])&#123;</span><br><span class="line">        <span class="type">int</span> ed_rt=rt;</span><br><span class="line">        fa[ch[rt][lson]]=<span class="number">0</span>;</span><br><span class="line">        rt=ch[rt][lson];</span><br><span class="line">        <span class="built_in">clear</span>(ed_rt);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ed_rt=rt;</span><br><span class="line">    <span class="type">int</span> cur=ch[rt][lson];</span><br><span class="line">    <span class="keyword">while</span>(ch[cur][rson])cur=ch[cur][rson];<span class="comment">//查找前驱用的函数内部就差不多是这样</span></span><br><span class="line">    <span class="built_in">splay</span>(cur);<span class="comment">//此时ed_rt一定没有左子树，可以较方便的删除</span></span><br><span class="line">    ch[rt][rson]=ch[ed_rt][rson];</span><br><span class="line">    fa[ch[rt][rson]]=cur;</span><br><span class="line">    <span class="built_in">clear</span>(ed_rt);</span><br><span class="line">    <span class="built_in">maintain</span>(rt);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法二">方法二</h4><p>把后继与前驱按顺序 splay 到根，这时原来的节点一定在后继左子树并且只有这一个节点在这棵子树中，直接断绝父子关系即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">numx_rank_search</span>(x);</span><br><span class="line">    <span class="type">int</span> cur1=rt,cur2=rt;</span><br><span class="line">    <span class="keyword">if</span>(ch[rt][lson])&#123;</span><br><span class="line">        cur1=ch[rt][lson];</span><br><span class="line">        <span class="keyword">while</span>(ch[cur1][rson])cur1=ch[cur1][rson];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ch[rt][rson])&#123;</span><br><span class="line">        cur2=ch[rt][rson];</span><br><span class="line">        <span class="keyword">while</span>(ch[cur2][lson])cur2=ch[cur2][lson];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">splay</span>(cur2);</span><br><span class="line">    <span class="built_in">splay</span>(cur1);</span><br><span class="line">    <span class="keyword">if</span>(cnt[ch[cur2][lson]]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        cnt[ch[cur2][lson]]--;</span><br><span class="line">        <span class="built_in">splay</span>(ch[cur2][lson]);</span><br><span class="line">        <span class="built_in">maintain</span>(ch[cur2][lson]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">clear</span>(ch[cur2][lson]);</span><br><span class="line">    ch[cur2][lson]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">maintain</span>(cur2);</span><br><span class="line">    <span class="built_in">maintain</span>(cur1);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="search-prenum">search_prenum()</h3><p>即查找前驱。前面已提到核心代码，但是如果该数不在树里怎么办？</p><p>先插入，运算完了，删除即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">search_prenum</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">insert</span>(x);</span><br><span class="line">    <span class="type">int</span> cur=rt;</span><br><span class="line">    <span class="keyword">if</span>(ch[rt][lson])&#123;</span><br><span class="line">        cur=ch[rt][lson];</span><br><span class="line">        <span class="keyword">while</span>(ch[cur][rson])cur=ch[cur][rson];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">splay</span>(cur);</span><br><span class="line">    <span class="built_in">del</span>(x);</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="search-nextnum">search_nextnum()</h3><p>与前驱基本一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">search_prenum</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">insert</span>(x);</span><br><span class="line">    <span class="type">int</span> cur=rt;</span><br><span class="line">    <span class="keyword">if</span>(ch[rt][rson])&#123;</span><br><span class="line">        cur=ch[rt][rson];</span><br><span class="line">        <span class="keyword">while</span>(ch[cur][lson])cur=ch[cur][lson];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">splay</span>(cur);</span><br><span class="line">    <span class="built_in">del</span>(x);</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Splay 到这里完结撒花！</p><h3 id="代码整合">代码整合</h3><p>贴的直接是模板的 AC 代码，可能与上面的代码有些不一样的地方。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson 1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Splay</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> rt;<span class="comment">//根节点编号</span></span><br><span class="line"><span class="type">int</span> tot;<span class="comment">//节点个数</span></span><br><span class="line"><span class="type">int</span> fa[<span class="number">10000001</span>];<span class="comment">//各个节点的父亲</span></span><br><span class="line"><span class="type">int</span> ch[<span class="number">10000001</span>][<span class="number">2</span>];<span class="comment">//左右儿子编号</span></span><br><span class="line"><span class="type">int</span> v[<span class="number">10000001</span>];<span class="comment">//节点权值</span></span><br><span class="line"><span class="type">int</span> cnt[<span class="number">10000001</span>];<span class="comment">//权值出现次数</span></span><br><span class="line"><span class="type">int</span> stre_size[<span class="number">10000001</span>];<span class="comment">//各个节点子树大小</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">maintain</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">//在改变节点位置后，将节点 x 的 size 更新。</span></span><br><span class="line"><span class="keyword">if</span>(x)stre_size[x]=(ch[x][lson]?stre_size[ch[x][lson]]:<span class="number">0</span>)+(ch[x][rson]?stre_size[ch[x][rson]]:<span class="number">0</span>)+cnt[x];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">//判断节点 x 是父亲节点的左儿子还是右儿子。</span></span><br><span class="line"><span class="keyword">return</span> ch[fa[x]][rson]==x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">//销毁节点 x。</span></span><br><span class="line">fa[x]=ch[x][lson]=ch[x][rson]=v[x]=cnt[x]=stre_size[x]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//为了使 Splay 保持平衡而进行旋转操作，旋转的本质是将某个节点上移一个位置。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> y=fa[x],z=fa[y],chk=<span class="built_in">get</span>(x);</span><br><span class="line">ch[y][chk]=ch[x][chk^<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span>(ch[y][chk])fa[ch[y][chk]]=y;</span><br><span class="line">ch[x][chk^<span class="number">1</span>]=y,fa[y]=x,fa[x]=z;</span><br><span class="line"><span class="keyword">if</span>(z)ch[z][ch[z][rson]==y]=x;</span><br><span class="line"><span class="built_in">maintain</span>(y);</span><br><span class="line"><span class="built_in">maintain</span>(x);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">//每访问一个节点 x 后都要强制将其旋转到根节点。</span></span><br><span class="line"><span class="keyword">for</span>(;fa[x];<span class="built_in">rotate</span>(x))</span><br><span class="line"><span class="keyword">if</span>(fa[fa[x]])&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">get</span>(fa[x])==<span class="built_in">get</span>(x))<span class="built_in">rotate</span>(fa[x]);<span class="comment">//!!!!!</span></span><br><span class="line"><span class="keyword">else</span> <span class="built_in">rotate</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">rt=x;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Self-add functions are here*/</span></span><br><span class="line"><span class="comment">//插入操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!rt)&#123;<span class="comment">//如果树空了，则直接插入根并退出。</span></span><br><span class="line">v[++tot]=x;</span><br><span class="line">cnt[tot]++;</span><br><span class="line">rt=tot;</span><br><span class="line"><span class="built_in">maintain</span>(rt);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cur=rt,buf=<span class="number">0</span>;<span class="comment">//这一次的和上一次的(fa[rt]=0) </span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(v[cur]==x&amp;&amp;cnt[cur])&#123;<span class="comment">//如果当前节点的权值等于 k 则增加当前节点的大小并更新节点和父亲的信息，将当前节点进行 Splay 操作。</span></span><br><span class="line">cnt[cur]++;</span><br><span class="line"><span class="built_in">maintain</span>(cur);</span><br><span class="line"><span class="built_in">maintain</span>(buf);</span><br><span class="line"><span class="built_in">splay</span>(cur);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">buf=cur;</span><br><span class="line">cur=ch[cur][x&gt;v[cur]];<span class="comment">//左子树任意节点的值 &lt; 根节点的值 &lt; 右子树任意节点的值。</span></span><br><span class="line"><span class="comment">//按照二叉查找树的性质向下找，找到空节点就插入即可</span></span><br><span class="line"><span class="keyword">if</span>(!cur)&#123;</span><br><span class="line">fa[++tot]=buf;</span><br><span class="line">ch[buf][x&gt;v[buf]]=tot;</span><br><span class="line">v[tot]=x;</span><br><span class="line">cnt[tot]++;</span><br><span class="line"><span class="built_in">maintain</span>(tot);</span><br><span class="line"><span class="built_in">maintain</span>(buf);</span><br><span class="line"><span class="built_in">splay</span>(tot);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询 x 的排名</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">numx_rank_search</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> res=<span class="number">0</span>,cur=rt;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//如果 x 比当前节点的权值小，向其左子树查找。</span></span><br><span class="line"><span class="keyword">if</span>(x&lt;v[cur])&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!ch[cur][lson])&#123;</span><br><span class="line">                    <span class="built_in">splay</span>(cur);</span><br><span class="line"><span class="keyword">return</span> res+<span class="number">1</span>;</span><br><span class="line">&#125;cur=ch[cur][lson];</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果 x 比当前节点的权值大，将答案加上左子树（size）和当前节点（cnt）的大小，向其右子树查找。</span></span><br><span class="line">res+=(ch[cur][lson]?stre_size[ch[cur][lson]]:<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(x&gt;v[cur])&#123;</span><br><span class="line">res+=cnt[cur];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!ch[cur][rson])&#123;</span><br><span class="line">                        <span class="built_in">splay</span>(cur);</span><br><span class="line"><span class="keyword">return</span> res+<span class="number">1</span>;</span><br><span class="line">&#125;cur=ch[cur][rson];</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果 x 与当前节点的权值相同，将答案加 1 并返回。</span></span><br><span class="line"><span class="comment">//注意最后需要进行 Splay 操作。</span></span><br><span class="line"><span class="built_in">splay</span>(cur);</span><br><span class="line"><span class="keyword">return</span> res+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询排名 x 的数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rankx_num_search</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> cur=rt;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//如果左子树非空且剩余排名 x 不大于左子树的大小 size，那么向左子树查找。</span></span><br><span class="line"><span class="keyword">if</span>(ch[cur][lson]&amp;&amp;x&lt;=stre_size[ch[cur][lson]])&#123;</span><br><span class="line">cur=ch[cur][lson];</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//否则将 x 减去左子树的和根的大小。</span></span><br><span class="line">x-=stre_size[ch[cur][lson]]+cnt[cur];</span><br><span class="line"><span class="comment">//如果此时 x 的值小于等于 0，则返回根节点的权值</span></span><br><span class="line"><span class="keyword">if</span>(x&lt;=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//注意最后需要进行 Splay 操作!!!!!!!!!</span></span><br><span class="line"><span class="built_in">splay</span>(cur);</span><br><span class="line"><span class="keyword">return</span> v[cur];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//否则继续向右子树查找。</span></span><br><span class="line">cur=ch[cur][rson];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">//首先将 x 旋转到根的位置。</span></span><br><span class="line"><span class="built_in">numx_rank_search</span>(x);<span class="comment">//最后都是splay了的</span></span><br><span class="line"><span class="comment">//如果 cnt[x]&gt;1（有不止一个 x），那么将 cnt[x] 减 1 并退出</span></span><br><span class="line"><span class="keyword">if</span>(cnt[rt]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">cnt[rt]--;</span><br><span class="line"><span class="built_in">maintain</span>(rt);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//否则，合并它的左右两棵子树即可。</span></span><br><span class="line"><span class="comment">//如何合并？</span></span><br><span class="line"><span class="comment">//设两棵树的根节点分别为 x 和 y，那么我们要求 x 树中的最大值小于 y 树中的最小值。</span></span><br><span class="line"><span class="comment">//如果 x 和 y 其中之一或两者都为空树，直接返回不为空的那一棵树的根节点或空树。</span></span><br><span class="line"><span class="keyword">if</span>(!ch[rt][lson]&amp;&amp;!ch[rt][rson])&#123;</span><br><span class="line"><span class="built_in">clear</span>(rt);</span><br><span class="line">rt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!ch[rt][lson])&#123;</span><br><span class="line">                <span class="type">int</span> ed_rt=rt; </span><br><span class="line">rt=ch[rt][rson];</span><br><span class="line">                fa[rt]=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">clear</span>(ed_rt);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!ch[rt][rson])&#123;</span><br><span class="line">                <span class="type">int</span> ed_rt=rt;</span><br><span class="line">rt=ch[rt][lson];</span><br><span class="line">                fa[rt]=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">clear</span>(ed_rt);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//否则将 x 树中的最大值 Splay 到根，然后把它的右子树设置为 y 并更新节点的信息，然后返回这个节点。</span></span><br><span class="line"><span class="type">int</span> ed_rt=rt;</span><br><span class="line"><span class="type">int</span> cur=ch[rt][lson];</span><br><span class="line"><span class="keyword">while</span>(ch[cur][rson])cur=ch[cur][rson];</span><br><span class="line"><span class="built_in">splay</span>(cur);</span><br><span class="line"><span class="comment">//查找前驱(无需insert或del，所以就直接复制上来了) </span></span><br><span class="line">ch[rt][rson]=ch[ed_rt][rson];</span><br><span class="line">fa[ch[rt][rson]]=rt;</span><br><span class="line"><span class="built_in">clear</span>(ed_rt);</span><br><span class="line"><span class="built_in">maintain</span>(rt);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//另一个思路</span></span><br><span class="line"><span class="comment">//将rt的前驱与后继都Splay，此时，rt会在后继的左儿子处，直接断绝关系即可</span></span><br><span class="line"><span class="comment">//void del(int x)&#123;</span></span><br><span class="line"><span class="comment">//int cur=ch[rt][lson];</span></span><br><span class="line"><span class="comment">//while(ch[cur][rson])cur=ch[cur][rson];</span></span><br><span class="line"><span class="comment">//int curr=ch[rt][rson];</span></span><br><span class="line"><span class="comment">//while(ch[cur][lson])cur=ch[cur][lson];</span></span><br><span class="line"><span class="comment">//splay(curr);</span></span><br><span class="line"><span class="comment">//splay(cur);</span></span><br><span class="line"><span class="comment">//int temp=ch[curr][lson];</span></span><br><span class="line"><span class="comment">//if(cnt[temp]&gt;1)&#123;</span></span><br><span class="line"><span class="comment">//cnt[temp]--;</span></span><br><span class="line"><span class="comment">//maintain(temp);</span></span><br><span class="line"><span class="comment">//splay(temp);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//else&#123;</span></span><br><span class="line"><span class="comment">//ch[curr][lson]=0;</span></span><br><span class="line"><span class="comment">//maintain(curr);</span></span><br><span class="line"><span class="comment">//maintain(cur);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//return;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//查询前驱</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search_prenum</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">//前驱定义为小于 x 的最大的数</span></span><br><span class="line"><span class="comment">//转化:</span></span><br><span class="line"><span class="comment">//将 x 插入（此时 x 已经在根的位置了）</span></span><br><span class="line"><span class="built_in">insert</span>(x);</span><br><span class="line"><span class="comment">//前驱即为 x 的左子树中最右边的节点</span></span><br><span class="line"><span class="type">int</span> cur=ch[rt][lson];</span><br><span class="line"><span class="keyword">if</span>(!cur)<span class="keyword">return</span> cur;<span class="comment">//没有这种数 </span></span><br><span class="line"><span class="keyword">while</span>(ch[cur][rson])cur=ch[cur][rson]<span class="comment">/*,cout&lt;&lt;v[cur]&lt;&lt;&quot; test&quot;&lt;&lt;endl;*/</span>;</span><br><span class="line"><span class="built_in">splay</span>(cur);</span><br><span class="line">            </span><br><span class="line"><span class="built_in">del</span>(x);<span class="comment">//最后将 x 删除即可。</span></span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询后继:与前驱极其类似</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search_nextnum</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">//后继定义为大于 x 的最小的数</span></span><br><span class="line"><span class="comment">//转化:</span></span><br><span class="line"><span class="comment">//将 x 插入（此时 x 已经在根的位置了）</span></span><br><span class="line"><span class="built_in">insert</span>(x);</span><br><span class="line"><span class="comment">//后继即为 x 的右子树中最左边的节点</span></span><br><span class="line"><span class="type">int</span> cur=ch[rt][rson];</span><br><span class="line"><span class="keyword">if</span>(!cur)<span class="keyword">return</span> cur;<span class="comment">//没有这种数 </span></span><br><span class="line"><span class="keyword">while</span>(ch[cur][lson])cur=ch[cur][lson];</span><br><span class="line"><span class="built_in">splay</span>(cur);</span><br><span class="line"><span class="built_in">del</span>(x);<span class="comment">//最后将 x 删除即可。</span></span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line">&#125;tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;P6136_5.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> n,m,op,x,last=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        tree.<span class="built_in">insert</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">cin&gt;&gt;op;</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">cin&gt;&gt;x;</span><br><span class="line">tree.<span class="built_in">insert</span>(x^last);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">cin&gt;&gt;x;</span><br><span class="line">tree.<span class="built_in">del</span>(x^last);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">3</span>)&#123;</span><br><span class="line">cin&gt;&gt;x;</span><br><span class="line">last=tree.<span class="built_in">numx_rank_search</span>(x^last);</span><br><span class="line">            ans^=last;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">4</span>)&#123;</span><br><span class="line">cin&gt;&gt;x;</span><br><span class="line">last=tree.<span class="built_in">rankx_num_search</span>(x^last);</span><br><span class="line">            ans^=last;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">5</span>)&#123;</span><br><span class="line">cin&gt;&gt;x;</span><br><span class="line">last=tree.v[tree.<span class="built_in">search_prenum</span>(x^last)];</span><br><span class="line">            ans^=last;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">6</span>)&#123;</span><br><span class="line">cin&gt;&gt;x;</span><br><span class="line">last=tree.v[tree.<span class="built_in">search_nextnum</span>(x^last)];</span><br><span class="line">            ans^=last;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//if(!(m%10000))cout&lt;&lt;m&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板地址：<a href="https://www.luogu.com.cn/problem/P6136">here</a></p><h1>从 Splay 到 LCT</h1><p>鸽…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;前言&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;从这里开始，信竞的路就开始向未来延伸了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;之前觉得信息竞赛不过是打打电脑，敲敲代码，从来没想到这其实是对思维的一种锻炼。&lt;/p&gt;
&lt;p&gt;信息竞赛的终端是NOI，也就是国赛，那场比赛会让一部分人极度高兴，也</summary>
      
    
    
    
    <category term="OI" scheme="http://blog.eltaos.top/categories/OI/"/>
    
    
    <category term="OI" scheme="http://blog.eltaos.top/tags/OI/"/>
    
  </entry>
  
  <entry>
    <title>SP22343-NORMA2-Norma</title>
    <link href="http://blog.eltaos.top/2023/SP22343-NORMA2-Norma/"/>
    <id>http://blog.eltaos.top/2023/SP22343-NORMA2-Norma/</id>
    <published>2023-08-28T14:58:45.000Z</published>
    <updated>2023-10-01T07:09:39.086Z</updated>
    
    <content type="html"><![CDATA[<p>双倍经验：<a href="http://www.luogu.com.cn/problem/P6406">$P6406$</a></p><h2 id="题目描述">题目描述</h2><p>给定一个序列$ a_i,\cdots,a_n $，求：</p><p>$$ \sum_{i=1}^{n} \sum_{j=i}^{n} (j-i+1) \min(a_i,a_{i+1},\cdots,a_j) \max(a_i,a_{i+1},\cdots,a_j) $$</p><h2 id="分析">分析</h2><p>根据 $ n \leq 5\times10^5 $，$O(n^3)$ 的暴力肯定要炸，于是考虑分治，即把序列分成左区间与右区间，分别计算以下三种情况：</p><ol><li class="lvl-3"><p>区间左右端点均落在左区间。</p></li><li class="lvl-3"><p>区间左右端点均落在右区间。</p></li><li class="lvl-3"><p>区间左端点落在左区间，区间右端点落在右区间。</p></li></ol><p>其中第 $1$，$2$ 种情况用分治递归解决就行了，于是来着重解决如何求第 $3$ 种情况的问题。</p><p>首先，暴力枚举求第 $3$ 种情况的时间复杂度显然是 $O(n^2)$，总时间复杂度是 $O(n^2 \log n)$，肯定是过不了的。于是可以想一些关于区间的优化：</p><p>线段树？好吧，这个蒟蒻作者不会线段树维护区间最大最小值。</p><p>单调队列？虽然使用单调队列可以不用分治，但是由于区间长度是不定的，这也需要 $O(n^2)$ 的时间复杂度，还是过不了。</p><p>前缀和？前缀最小最大值的前缀和？这能算吗…好像真可以…</p><p>于是用分治+前缀和预处理，$O(n \log n)$ 的时间复杂度就能过掉此题。</p><h2 id="具体实现">具体实现</h2><p><s>（为什么要推这种式子啊）</s></p><p>如果在左区间内定一个下标 $ i $，对于每一个 $ i $，记 $ mi $ 为在 $ a_i,\cdots ,a_{mid} $ 内的最小值下标，$ mx $ 为该区间内最大值下标。显而易见，当 $ i=mid,mid-1,\cdots,1 $ 时，$ mi $ 与 $ mx $ 也是严格单调递减的。</p><p>同样的，记 $ mi_{to} $ 为右区间内最后一个大于 $ a[mi] $ 的下标，$ mx_{to} $ 为右区间内最后一个小于 $ a[mx] $ 的下标。同样显而易见的是，当 $ i=mid,mid-1,\cdots,1 $ 时，$ mi_{to} $ 与 $ mx_{to} $ 也是严格单调递增的。</p><p>所以，我们可以将第三种情况对于每一个 $ i $ 分 $ 3 $ 个部分来求：</p><h3 id="第一个部分：-mid-1-min-mi-to-mx-to">第一个部分：$ [mid+1,\min(mi_{to},mx_{to})) $</h3><p>这一部分最大值为 $ mx $，最小值为 $ mi $，直接等差数列求和就行了，这里就不赘述了。</p><h3 id="第二个部分：-min-mi-to-mx-to-max-mi-to-mx-to">第二个部分：$ [\min(mi_{to},mx_{to}),\max(mi_{to},mx_{to})) $</h3><p>这一部分 $ mi_{to} $ 与 $ mx_{to} $ 只有一个可用，这个时候就要用前缀和了。假定 $ mi_{to} &gt; mx_{to} $，最小值可用 $ mi_{to} $，最大值就只能用右区间的前缀最大值的前缀和。但是由于 $ i $ 不定，又不能针对于每一个 $ i $ 都算一遍（不然时间复杂度就爆炸了），所以前缀和要算两次，具体如下：</p><p>设 $ sum1_k $ 是 $ \max(a_{mid},\cdots,a_k) $ 的前缀和，$ sum2_k $ 是 $ (k + 1) \times \max(a_{mid},\cdots,a_k) $ 的前缀和。</p><p>由于区间长度为 $ k-i+1 $，所以可知，这一部分的贡献是 $ sum2[\max(mi_{to},mx_{to})]-sum2[\min(mi_{to},mx_{to})]-i\times(sum1[\max(mi_{to},mx_{to})]-sum1[\min(mi_{to},mx_{to})]) $。</p><p><s>（作者推式子好累，但打式子更累）</s></p><p>$ mi_{to} &lt; mx_{to} $ 是一样的。</p><h3 id="第三个部分：-max-mi-to-mx-to-r">第三个部分：$ [\max(mi_{to},mx_{to}),r] $</h3><p>只要第二部分搞出来了那这一部分就没什么问题了，不过是求 $ \max(a_{mid},\cdots,a_k) \times \min(a_{mid},\cdots,a_k) $ 和 $ (k+1)\times\max(a_{mid},\cdots,a_k) \times \min(a_{mid},\cdots,a_k)  $ 的前缀和就行了。</p><p>这样这道题就搞出来了。</p><p>什么？你说取模爆炸了？来试试 __int128 吧！（见代码）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> __int128 mod=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a[MAXN];</span><br><span class="line">__int128 summin1[MAXN],summin2[MAXN],summax1[MAXN],summax2[MAXN],summul1[MAXN],summul2[MAXN];</span><br><span class="line"><span class="function">__int128 <span class="title">fz</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)<span class="keyword">return</span> a[l]*a[l];</span><br><span class="line"><span class="keyword">if</span>(l+<span class="number">1</span>==r)<span class="keyword">return</span> (a[l]*a[l]+a[r]*a[r]+<span class="number">2</span>*<span class="built_in">min</span>(a[l],a[r])*<span class="built_in">max</span>(a[l],a[r]));</span><br><span class="line">__int128 mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">__int128 ans=(<span class="built_in">fz</span>(l,mid)+<span class="built_in">fz</span>(mid+<span class="number">1</span>,r));</span><br><span class="line">__int128 nowmin=a[mid+<span class="number">1</span>],nowmax=a[mid+<span class="number">1</span>];</span><br><span class="line">summin1[mid]=summin2[mid]=summax1[mid]=summax2[mid]=summul1[mid]=summul2[mid]=<span class="number">0</span>;</span><br><span class="line">summin1[mid+<span class="number">1</span>]=a[mid+<span class="number">1</span>];</span><br><span class="line">summin2[mid+<span class="number">1</span>]=a[mid+<span class="number">1</span>]*(mid+<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=mid+<span class="number">2</span>;i&lt;=r;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]&lt;nowmin)nowmin=a[i];</span><br><span class="line">summin1[i]=summin1[i<span class="number">-1</span>]+nowmin;</span><br><span class="line">summin2[i]=(i+<span class="number">1</span>)*nowmin+summin2[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">summax1[mid+<span class="number">1</span>]=a[mid+<span class="number">1</span>];</span><br><span class="line">summax2[mid+<span class="number">1</span>]=a[mid+<span class="number">1</span>]*(mid+<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=mid+<span class="number">2</span>;i&lt;=r;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]&gt;nowmax)nowmax=a[i];</span><br><span class="line">summax1[i]=summax1[i<span class="number">-1</span>]+nowmax;</span><br><span class="line">summax2[i]=(i+<span class="number">1</span>)*nowmax+summax2[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">nowmin=a[mid+<span class="number">1</span>],nowmax=a[mid+<span class="number">1</span>];</span><br><span class="line">summul1[mid+<span class="number">1</span>]=a[mid+<span class="number">1</span>]*a[mid+<span class="number">1</span>];</span><br><span class="line">summul2[mid+<span class="number">1</span>]=a[mid+<span class="number">1</span>]*a[mid+<span class="number">1</span>]*(mid+<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=mid+<span class="number">2</span>;i&lt;=r;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]&lt;nowmin)nowmin=a[i];</span><br><span class="line"><span class="keyword">if</span>(a[i]&gt;nowmax)nowmax=a[i];</span><br><span class="line">summul1[i]=summul1[i<span class="number">-1</span>]+nowmax*nowmin;</span><br><span class="line">summul2[i]=(i+<span class="number">1</span>)*nowmax*nowmin+summul2[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mi=mid,mx=mid,mi_to=mid,mx_to=mid;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=mid;k&gt;=l;k--)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[k]&lt;a[mi])mi=k;</span><br><span class="line"><span class="keyword">if</span>(a[k]&gt;a[mx])mx=k;</span><br><span class="line"><span class="keyword">while</span>(a[mi_to]&gt;=a[mi]&amp;&amp;mi_to&lt;=r)mi_to++;</span><br><span class="line"><span class="keyword">if</span>(mi_to&gt;mid)mi_to--;</span><br><span class="line"><span class="keyword">while</span>(a[mx_to]&lt;=a[mx]&amp;&amp;mx_to&lt;=r)mx_to++;</span><br><span class="line"><span class="keyword">if</span>(mx_to&gt;mid)mx_to--;</span><br><span class="line">ans+=(((<span class="built_in">min</span>(mi_to,mx_to)-k+<span class="number">1</span>+mid-k+<span class="number">2</span>)*(<span class="built_in">min</span>(mi_to,mx_to)-mid))*a[mi]*a[mx])/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(mi_to&gt;mx_to)ans+=(summax2[mi_to]-summax2[mx_to]-k*(summax1[mi_to]-summax1[mx_to]))*a[mi];</span><br><span class="line"><span class="keyword">else</span> ans+=(summin2[mx_to]-summin2[mi_to]-k*(summin1[mx_to]-summin1[mi_to]))*a[mx];</span><br><span class="line">ans+=(summul2[r]-summul2[<span class="built_in">max</span>(mx_to,mi_to)]-k*(summul1[r]-summul1[<span class="built_in">max</span>(mx_to,mi_to)]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;a[i];</span><br><span class="line">cout&lt;&lt;(<span class="type">long</span> <span class="type">long</span>)((<span class="built_in">fz</span>(<span class="number">1</span>,n))%mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;双倍经验：&lt;a href=&quot;http://www.luogu.com.cn/problem/P6406&quot;&gt;$P6406$&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;给定一个序列$ a_i,&#92;cdots,a_n $，求：&lt;/p&gt;
&lt;p&gt;$$ &#92;su</summary>
      
    
    
    
    <category term="OI" scheme="http://blog.eltaos.top/categories/OI/"/>
    
    
    <category term="题解" scheme="http://blog.eltaos.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>P2533 [AHOI2012] 信号塔</title>
    <link href="http://blog.eltaos.top/2023/P2533-AHOI2012-%E4%BF%A1%E5%8F%B7%E5%A1%94/"/>
    <id>http://blog.eltaos.top/2023/P2533-AHOI2012-%E4%BF%A1%E5%8F%B7%E5%A1%94/</id>
    <published>2023-08-28T14:44:52.000Z</published>
    <updated>2023-10-01T07:10:46.496Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3><p>给定 $ n $ 个点 $(x_i,y_i)$，求半径最小的圆使该圆能覆盖所有的点。</p><p>所以这是一道最小覆盖圆的板子题，双倍经验：<a href="https://www.luogu.com.cn/problem/P1742"><strong>P1742</strong></a></p><h3 id="实现">实现</h3><p>使用随机增量法：</p><p>很容易我们能证明，若第 $ i $ 个点不在前 $ i-1 $ 个点的最小覆盖圆上，那么第 $ i $ 个点在前 $ i $ 个点的最小覆盖圆上。</p><p>这个时候，就要求前 $ i $ 个点的最小覆盖圆了。在初始化时，把圆心设为第 $ i $ 个点的坐标，半径设为 $ 0 $，强制使这个点在圆上。然后枚举就行了，如果当前这个点在当前这个圆外时就去求第 $ i $ 个点与该点在圆上时的最小覆盖圆，这个时候就要枚举除这两个点以外的第三个点（三点定圆）。枚举结束后就能求出前 $ i $ 个点的最小覆盖圆。</p><p>注意循环不用从 $ 1 $ 到 $ n $ 全部枚一遍，这样会造成重复枚举。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">is_po_in_circle</span>(a[i],c))&#123;</span><br><span class="line">        c=<span class="built_in">get_circ</span>(<span class="number">0</span>,a[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i<span class="number">-1</span>;j++)</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">is_po_in_circle</span>(a[j],c))&#123;</span><br><span class="line">                c.r=<span class="built_in">dist</span>(a[i],a[j])/<span class="number">2</span>;</span><br><span class="line">                c.o.x=(a[i].x+a[j].x)/<span class="number">2</span>;</span><br><span class="line">                c.o.y=(a[i].y+a[j].y)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=j<span class="number">-1</span>;k++)</span><br><span class="line">                    <span class="keyword">if</span>(!<span class="built_in">is_po_in_circle</span>(a[k],c))</span><br><span class="line">                        c=<span class="built_in">get_circle_from_po</span>(a[i],a[j],a[k]);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>现在最大的问题来了：两点加直径定圆很简单，但是三点定圆有点难度，所以开始推式子：</p><p>假设两点 $(x_1,y_1)$ 与 $(x_2,y_2)$，易得它们的中点是 $(\frac{x_1+x_2}{2},\frac{y_1+y_2}{2})$，经过它们的直线的斜率为 $\frac{y_1-y_2}{x_1-x_2}$。</p><p>因为三角形外接圆圆心（即外心）在在三条线段的中垂线上，故可知刚刚两个点的中垂线斜率为 $-\frac{x_1-x_2}{y_1-y_2}$。再代入刚刚的中点，把式子化为 $ Ax+By+C=0$ 的形式，可知中垂线解析式为：</p><p>$$ (x_1-x_2)x+(y_1-y_2)y+\frac{y_2^2-y_1^2+x_2^2-x_1^2}{2}=0 $$</p><p>其他两条直线是一样的，联立求交点即可，这样圆心和半径都求出来了。</p><h3 id="复杂度证明">复杂度证明</h3><p>这个看似时间复杂度是 $ O(n^3) $ 的做法实际上时间复杂度为 $O(n)$，证明如下：</p><p>由于所有点中，每次最多有 $3$ 个点来确定最小覆盖圆，所以每次只有最多 $\frac{3}{n}$ 的概率选到参与确定最小覆盖圆的点，即每个循环向下调用的概率不超过 $\frac{3}{n}$。</p><p>首先最后一层循环的复杂度是 $O(j)$ 的，向上可以推得第二层的时间复杂度为：</p><p>$$O(i)+\sum_{j=1}^i \frac{3}{i}O(j)$$</p><p>因为要经过随机排序，通过上面的式子容易得到这层的时间复杂度是 $O(i)$，那第一层的时间复杂度也显而易见是 $O(n)$ 了。</p><p>AC 代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">po</span>&#123;</span><br><span class="line">    <span class="type">double</span> x,y;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">vec</span>&#123;</span><br><span class="line">    <span class="type">double</span> A,B,C;<span class="comment">//Ax+By+C=0;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">circ</span>&#123;</span><br><span class="line">    po o;</span><br><span class="line">    <span class="type">double</span> r;</span><br><span class="line">&#125;;</span><br><span class="line">po a[<span class="number">2000001</span>];</span><br><span class="line">circ c;</span><br><span class="line"><span class="function">vec <span class="title">get_vec_from_po</span><span class="params">(po p,po q)</span></span>&#123;</span><br><span class="line">    vec v;</span><br><span class="line">    v.A=p.y-q.y;</span><br><span class="line">    v.B=q.x-p.x;</span><br><span class="line">    v.C=p.x*q.y-q.x*p.y;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">po <span class="title">get_po_from_vec</span><span class="params">(vec c,vec d)</span></span>&#123;</span><br><span class="line">    po pp;</span><br><span class="line">    pp.x=((<span class="type">double</span>)(-d.B*c.C+c.B*d.C)/(<span class="type">double</span>)(-c.B*d.A+c.A*d.B));</span><br><span class="line">    pp.y=((<span class="type">double</span>)(-d.A*c.C+c.A*d.C)/(<span class="type">double</span>)(c.B*d.A-c.A*d.B));</span><br><span class="line">    <span class="keyword">return</span> pp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dist</span><span class="params">(po a,po b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_po_in_circle</span><span class="params">(po test,circ d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> d.r&gt;=<span class="built_in">sqrt</span>((test.x-d.o.x)*(test.x-d.o.x)+(test.y-d.o.y)*(test.y-d.o.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">circ <span class="title">get_circle_from_po</span><span class="params">(po A,po B,po C)</span></span>&#123;</span><br><span class="line">    vec buf1,buf2;</span><br><span class="line">    buf1.A=<span class="number">2</span>*(A.x-B.x),buf1.B=<span class="number">2</span>*(A.y-B.y),buf1.C=B.x*B.x-A.x*A.x+B.y*B.y-A.y*A.y;</span><br><span class="line">    buf2.A=<span class="number">2</span>*(B.x-C.x),buf2.B=<span class="number">2</span>*(B.y-C.y),buf2.C=C.x*C.x-B.x*B.x+C.y*C.y-B.y*B.y;</span><br><span class="line">    circ temp;</span><br><span class="line">    temp.o=<span class="built_in">get_po_from_vec</span>(buf1,buf2);</span><br><span class="line">    temp.r=<span class="built_in">dist</span>(temp.o,A);</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">circ <span class="title">get_circ</span><span class="params">(<span class="type">double</span> r,po o)</span></span>&#123;</span><br><span class="line">    circ temp_;</span><br><span class="line">    temp_.r=r;</span><br><span class="line">    temp_.o=o;</span><br><span class="line">    <span class="keyword">return</span> temp_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;a[i].x&gt;&gt;a[i].y;</span><br><span class="line">    <span class="built_in">random_shuffle</span>(a+<span class="number">1</span>, a+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">is_po_in_circle</span>(a[i],c))&#123;</span><br><span class="line">            c=<span class="built_in">get_circ</span>(<span class="number">0</span>,a[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i<span class="number">-1</span>;j++)</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">is_po_in_circle</span>(a[j],c))&#123;</span><br><span class="line">                    c.r=<span class="built_in">dist</span>(a[i],a[j])/<span class="number">2</span>;</span><br><span class="line">                    c.o.x=(a[i].x+a[j].x)/<span class="number">2</span>;</span><br><span class="line">                    c.o.y=(a[i].y+a[j].y)/<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=j<span class="number">-1</span>;k++)</span><br><span class="line">                        <span class="keyword">if</span>(!<span class="built_in">is_po_in_circle</span>(a[k],c))</span><br><span class="line">                            c=<span class="built_in">get_circle_from_po</span>(a[i],a[j],a[k]);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">2</span>)&lt;&lt;c.o.x&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;c.o.y&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">2</span>)&lt;&lt;c.r&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;题目描述&lt;/h3&gt;
&lt;p&gt;给定 $ n $ 个点 $(x_i,y_i)$，求半径最小的圆使该圆能覆盖所有的点。&lt;/p&gt;
&lt;p&gt;所以这是一道最小覆盖圆的板子题，双倍经验：&lt;a href=&quot;https://www.luogu.com.cn/problem/</summary>
      
    
    
    
    <category term="OI" scheme="http://blog.eltaos.top/categories/OI/"/>
    
    
    <category term="题解" scheme="http://blog.eltaos.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Tree-Summing-UVA112</title>
    <link href="http://blog.eltaos.top/2023/Tree-Summing-UVA112/"/>
    <id>http://blog.eltaos.top/2023/Tree-Summing-UVA112/</id>
    <published>2023-08-28T14:42:09.000Z</published>
    <updated>2020-01-19T07:13:30.301Z</updated>
    
    <content type="html"><![CDATA[<p>这题主要算法最多<strong>普及-</strong>，输入的难度个人认为高达<strong>省选</strong>！（调输入的时间占做这题时间的九成！！！）</p><h3 id="题目描述">题目描述</h3><p>给出一棵整数的二叉树，请写一个程序判定是否存在这样一条从树根到树叶的路，路上的结点的总和等于一个特定的整数。</p><p>这道题极其坑人的的点在判断两个儿子是否都为叶节点和输入上。</p><h3 id="0x01-树的遍历">0x01 树的遍历</h3><p>这里推荐使用在线算法，因为写起来简单。</p><p>很容易发现在每次读入数时，我们就到达了一个叶节点或一颗子树的根节点，这个时候可以加和，等到该节点的子树遍历完之后像自己的父亲，也就是上一个节点回溯。回溯的过程很简单，就是把当前的加和减去现在节点的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sign 是负数的标志</span></span><br><span class="line">cin&gt;&gt;po;</span><br><span class="line">sum+=po*sign;</span><br><span class="line"><span class="built_in">dfs</span>(dep+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">dfs</span>(dep+<span class="number">1</span>);</span><br><span class="line">sum-=po*sign;</span><br></pre></td></tr></table></figure><p>那么，知道了如何加和，那如何比较结果呢？</p><p>对于这道题，显然是在叶子节点处比较结果。那么，如何判断是否为叶子结点呢？</p><h3 id="0x02-判断是否为叶子节点">0x02 判断是否为叶子节点</h3><p>根据题意，叶子节点的格式是这样的：<code>(num()())</code>，要想判断叶子节点，就要判断两个空树。</p><p>方法一：如果读入第一个 <code>(</code> 后在探测下几个字符（探测的用法下一个部分要讲），如果为 <code>)()</code> 那就成功判断一个叶节点。</p><p>但是 C++ 自带的探测函数指针不后移，如果后移的话像 <code>()(...)</code> 这样的数据就会过度输入，对后面的遍历产生影响。</p><p>方法二：只探测每个树第一个 <code>(</code> 后是否为 <code>)</code>，如果是，就返回 $1$，如果一个节点的左右子树都是空树，那么才进行现在的加和与给定的数的比较。当然，探测到 <code>)</code> 后要指针后移，避免在下次遍历的开始读到右括号从而影响遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(cin.<span class="built_in">peek</span>()==<span class="string">&#x27;)&#x27;</span>)&#123;<span class="comment">//探测下一个字符是否为&#x27;)&#x27;</span></span><br><span class="line">cin.<span class="built_in">ignore</span>();<span class="comment">//指针后移</span></span><br><span class="line"><span class="keyword">return</span> (sum==n);<span class="comment">//可以返回 1，也可以直接返回比较结果</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">temp+=<span class="built_in">dfs</span>(dep+<span class="number">1</span>);</span><br><span class="line">temp+=<span class="built_in">dfs</span>(dep+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(temp==<span class="number">2</span>)&#123;<span class="comment">//如果在上面返回 1，这里就要进行比较</span></span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这样的话，我们的递归函数的返回值就是该节点是否为子树，需要一个新的变量来存比较的结果。</p><p>主要算法都讲完了，但先别急，因为这道题的输入可以让你爆炸！！！</p><h3 id="0x03-输入">0x03 输入</h3><p>我推荐的方法是用探测和指针后移的方式来实现左右括号的读入与判断。</p><p>先介绍函数，探测函数是 <code>cin.peek()</code>，这个函数返回该指针的下一个字符。后移函数是 <code>cin.ignore()</code>，这个函数使当前输入的指针后移一位。读入的时候就从后移后的下一个字符开始读入，后移后指针所指的字符不读入。</p><p>首先，我们要实现对于空格和换行的跳过：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">space</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(cin.<span class="built_in">peek</span>()&lt;=<span class="number">32</span>)cin.<span class="built_in">ignore</span>();<span class="comment">//&#x27; &#x27;,&#x27;\n&#x27;,&#x27;\r&#x27;的ASCII值都小于等于32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们就在想要探测并跳过左右括号或者负号时，先去空格等字符，然后读入，判断，跳过就行了（但是很容易写错！！！）。</p><p>完整 AC 代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> k,kk;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">space</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(cin.<span class="built_in">peek</span>()&lt;=<span class="number">32</span>)cin.<span class="built_in">ignore</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">long</span> <span class="type">long</span> dep)</span></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> po;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> temp=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">space</span>();</span><br><span class="line">cin.<span class="built_in">ignore</span>();</span><br><span class="line"><span class="built_in">space</span>();</span><br><span class="line"><span class="keyword">if</span>(cin.<span class="built_in">peek</span>()==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">cin.<span class="built_in">ignore</span>();</span><br><span class="line"><span class="keyword">return</span> (sum==n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> sign=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(cin.<span class="built_in">peek</span>()==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">sign=<span class="number">-1</span>;</span><br><span class="line">cin.<span class="built_in">ignore</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">space</span>();</span><br><span class="line">cin&gt;&gt;po;</span><br><span class="line">sum+=po*sign;</span><br><span class="line">temp+=<span class="built_in">dfs</span>(dep+<span class="number">1</span>);</span><br><span class="line">temp+=<span class="built_in">dfs</span>(dep+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(temp==<span class="number">2</span>)&#123;</span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">sum-=po*sign;</span><br><span class="line"><span class="built_in">space</span>();</span><br><span class="line">cin.<span class="built_in">ignore</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">string s;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> u=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">flag=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">s=(flag)?<span class="string">&quot;yes&quot;</span>:<span class="string">&quot;no&quot;</span>;</span><br><span class="line">cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这题主要算法最多&lt;strong&gt;普及-&lt;/strong&gt;，输入的难度个人认为高达&lt;strong&gt;省选&lt;/strong&gt;！（调输入的时间占做这题时间的九成！！！）&lt;/p&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;题目描述&lt;/h3&gt;
&lt;p&gt;给出一棵整数的二叉树，请写一个程序判定是否存在这样</summary>
      
    
    
    
    <category term="OI" scheme="http://blog.eltaos.top/categories/OI/"/>
    
    
    <category term="题解" scheme="http://blog.eltaos.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>P8734 [蓝桥杯 2020 国 A] 奇偶覆盖</title>
    <link href="http://blog.eltaos.top/2023/P8734-%E8%93%9D%E6%A1%A5%E6%9D%AF-2020-%E5%9B%BD-A-%E5%A5%87%E5%81%B6%E8%A6%86%E7%9B%96/"/>
    <id>http://blog.eltaos.top/2023/P8734-%E8%93%9D%E6%A1%A5%E6%9D%AF-2020-%E5%9B%BD-A-%E5%A5%87%E5%81%B6%E8%A6%86%E7%9B%96/</id>
    <published>2023-08-28T14:28:58.000Z</published>
    <updated>2023-10-01T07:10:21.831Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3><p>在平面内有一些矩形，它们的两条边都平行于坐标轴。</p><p>我们称一个点被某个矩形覆盖，是指这个点在矩形的内部或者边界上。</p><p>请问，被奇数个矩形覆盖和被偶数（$\leq2$）个矩形覆盖的点的面积分别是多少?</p><h3 id="实现">实现</h3><p>显然这题是一道扫描线，不会扫描线的同学先去做<a href="https://www.luogu.com.cn/problem/P5490">这道题</a>。本题解就不讲扫描线是如何实现的了。</p><p>由于要奇偶分开输出，我们的线段树就不能像下面的代码一样只维护一个区间长度了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tree[now].num)&#123;</span><br><span class="line">tree[now].len=x[tree[now].r+<span class="number">1</span>]-x[tree[now].l];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">tree[now].len=tree[now*<span class="number">2</span>].len+tree[now*<span class="number">2</span>+<span class="number">1</span>].len;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然，上面这份代码的 <code>len</code> 要被拆成两个，一个用来存奇数覆盖，一个用来存偶数覆盖。由于要保证奇加上偶的面积等于总面积并，我们需要修改原来的上推函数。</p><p>显然，这要分成 $3$ 种情况：</p><ul class="lvl-0"><li class="lvl-2"><p>没有覆盖：奇偶都只需要从左右儿子加和就行了。</p></li><li class="lvl-2"><p>覆盖的矩形数为奇数：此时当前的奇数长度更多要依赖区间长度计算，于是先算偶数长度。根据偶等于奇（当前覆盖矩形数）加奇（左右儿子），偶数长度是左右儿子奇数长度之和。又由于满足奇偶加和为总面积并，所以奇数长度就等于区间长度减刚刚才算的偶数长度。</p></li><li class="lvl-2"><p>覆盖的矩形数为偶数：根据奇等于偶加奇，奇数长度是左右儿子奇数长度之和。同上面的分析，偶数长度是区间长度减刚刚算的奇数长度。</p></li></ul><p>在扫描线的基础上这样修改完上推函数，这道题也就做完了。</p><p>提示：记得把空间开大一点！</p><p>AC 代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> x[<span class="number">2000001</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segtree</span>&#123;</span><br><span class="line"><span class="type">int</span> l;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> len1,len2,num;</span><br><span class="line">&#125;;</span><br><span class="line">segtree tree[<span class="number">4000050</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">defline</span>&#123;</span><br><span class="line"><span class="type">int</span> xl,xr,y;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> num;</span><br><span class="line">&#125;;</span><br><span class="line">defline line[<span class="number">4000050</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(defline a,defline b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.y&lt;b.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line">tree[now].l=l,tree[now].r=r;</span><br><span class="line">tree[now].len1=<span class="number">0</span>;</span><br><span class="line">tree[now].len2=<span class="number">0</span>;</span><br><span class="line">tree[now].num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="built_in">build</span>(l,mid,now*<span class="number">2</span>),<span class="built_in">build</span>(mid+<span class="number">1</span>,r,now*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tree[now].num==<span class="number">0</span>)&#123;</span><br><span class="line">tree[now].len1=tree[now*<span class="number">2</span>].len1+tree[now*<span class="number">2</span>+<span class="number">1</span>].len1;</span><br><span class="line">tree[now].len2=tree[now*<span class="number">2</span>].len2+tree[now*<span class="number">2</span>+<span class="number">1</span>].len2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(tree[now].num%<span class="number">2</span>)&#123;</span><br><span class="line">tree[now].len2=tree[now*<span class="number">2</span>].len1+tree[now*<span class="number">2</span>+<span class="number">1</span>].len1;</span><br><span class="line">tree[now].len1=x[tree[now].r+<span class="number">1</span>]-x[tree[now].l]-tree[now].len2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">tree[now].len1=tree[now*<span class="number">2</span>].len1+tree[now*<span class="number">2</span>+<span class="number">1</span>].len1;</span><br><span class="line">tree[now].len2=x[tree[now].r+<span class="number">1</span>]-x[tree[now].l]-tree[now].len1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> now,<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x[tree[now].r+<span class="number">1</span>]&lt;=l||x[tree[now].l]&gt;=r)<span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(x[tree[now].r+<span class="number">1</span>]&lt;=r&amp;&amp;x[tree[now].l]&gt;=l)&#123;</span><br><span class="line">tree[now].num+=num;</span><br><span class="line"><span class="built_in">pushup</span>(now);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">update</span>(l,r,now*<span class="number">2</span>,num);</span><br><span class="line"><span class="built_in">update</span>(l,r,now*<span class="number">2</span>+<span class="number">1</span>,num);</span><br><span class="line"><span class="built_in">pushup</span>(now);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n,xlt,xrt,yup,ydown;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;xlt&gt;&gt;ydown&gt;&gt;xrt&gt;&gt;yup;</span><br><span class="line">x[i*<span class="number">2</span><span class="number">-1</span>]=xlt;</span><br><span class="line">x[i*<span class="number">2</span>]=xrt;</span><br><span class="line">line[i*<span class="number">2</span><span class="number">-1</span>].xl=xlt;</span><br><span class="line">line[i*<span class="number">2</span><span class="number">-1</span>].xr=xrt;</span><br><span class="line">line[i*<span class="number">2</span><span class="number">-1</span>].y=ydown;</span><br><span class="line">line[i*<span class="number">2</span><span class="number">-1</span>].num=<span class="number">1</span>;</span><br><span class="line">line[i*<span class="number">2</span>].xl=xlt;</span><br><span class="line">line[i*<span class="number">2</span>].xr=xrt;</span><br><span class="line">line[i*<span class="number">2</span>].y=yup;</span><br><span class="line">line[i*<span class="number">2</span>].num=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">n*=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">sort</span>(x+<span class="number">1</span>,x+n+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">sort</span>(line+<span class="number">1</span>,line+n+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="type">int</span> tot=<span class="built_in">unique</span>(x+<span class="number">1</span>,x+n+<span class="number">1</span>)-x<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,tot<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans1=<span class="number">0</span>,ans2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="built_in">update</span>(line[i].xl,line[i].xr,<span class="number">1</span>,line[i].num);</span><br><span class="line">ans1+=tree[<span class="number">1</span>].len1*(line[i+<span class="number">1</span>].y-line[i].y);</span><br><span class="line">ans2+=tree[<span class="number">1</span>].len2*(line[i+<span class="number">1</span>].y-line[i].y);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans1&lt;&lt;endl&lt;&lt;ans2&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目描述&quot;&gt;题目描述&lt;/h3&gt;
&lt;p&gt;在平面内有一些矩形，它们的两条边都平行于坐标轴。&lt;/p&gt;
&lt;p&gt;我们称一个点被某个矩形覆盖，是指这个点在矩形的内部或者边界上。&lt;/p&gt;
&lt;p&gt;请问，被奇数个矩形覆盖和被偶数（$&#92;leq2$）个矩形覆盖的点的面积分别是多少?&lt;/</summary>
      
    
    
    
    <category term="OI" scheme="http://blog.eltaos.top/categories/OI/"/>
    
    
    <category term="题解" scheme="http://blog.eltaos.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>四月天</title>
    <link href="http://blog.eltaos.top/2023/17/"/>
    <id>http://blog.eltaos.top/2023/17/</id>
    <published>2023-04-13T15:40:00.000Z</published>
    <updated>2023-09-27T02:33:50.618Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="723f13727003201488357231ee73d3a42cd574eafe3f6adb7b7fc23dfe319dc0">502f5a5d5c295f55e2be09c3bd909305bb7063d6ec785008713d29663f9a9d2ceb775084130e06cf664f7570b966425ce04562d5f33a54535f65763948dc1ff8f14901d4e1926d386e4184e6c5df9ae8cec7ceb873b094d57d05d2df84ba46c23da0d248f35cc56c487500357d103f35ade84860564a969846ee5d9d7e68bad94417405df986b7779fb7f64c38116da44f4e5823f011c81ceec23cf3b1311b6da12767f0bc0c1265c7502ba6f3d674416a783f24cb1aee59bae01b19cc2d4953f6f7102f5625d92a292505ea1e1591834e75ff3d74ab223d49e744efe365c394d30f9d8d8d5122819567421cc5ee1ba8f062956f8a4f5396fc79c715ef7e8743690bdcdaf2a642ce1392b1cf8972b921bce918b7b090ce9242906fa321cf1566757d6f1a6a4af69514181bdad44a0d552eb2f5073f9240544343d5d32472329c217330e661cbbbf01551468611fe30a4c0606dd0fdd6608c5342513e5ac8591a5ecbd996d43a852677d424d77aa28427d6083ca26414cb5fa988f6f29caf8f6d4a40e35538fe6b8c1a798c09c56f0bf32c5de20e5f3a06ad910f1ce590aa32816ca3c2747b1381a0c70a6549041cb6910de44b67a5a739a82e8ced604fb1a5ea9c856f528967e1becfacbd653fb6512a94744088d139695925012be80a6dbf6600918be68bf2d8e538ebdc8dbde584c4db00d13007c1ca168262ce1713ac19591db9f1e793f9e313297aedd2438cd95652fc8960d9e5453e62ce84f8d2622a15ee9aa5f46ab1df99a41e6e880bbaf2bd3d636a6caf845884fbd7d1bc17ed15248538937f61f9c36ed5b1e9f5c0e66929c7bd8a8cedd04df7740ddf0b90d9f41efaa30b3dacdc34cf203da6f98c9143feb85fe65ef4c35cffa521909dc63974f7140f4c865187d8900c14265a04812886a33637a5321fe511de609f54383312a7d4b5598e012f510d1859e065bbd218068419193c6ca1dfc52328e3e8c735802457605370789f4f81d6f068a3ab169b04fe55ee9eafd62d97fbc8a4f8a8274289a6e3a5a919aaf035ad5405d185503115226a84f06c4358360272abfd9265a54b0069e02312ec2a4b321b4cbe600968b2c5097448555abb3bd76b710b5168d2dc46b809eb760d0123ad9d31400a438d2589da7c475d80a7a9b766ea3e27c6083e64ee8648b571c4eeb5cf523b0fe8334fa8f75650b5cdf98c4a60e854f47ddf776b3e7a50e12bd63c611ffbdf98d38870279874e758b30d61c8213fba77d3e24f8d4301b779af2eb77131fb996ffcb690b80ef2c99d5e32ac50c66103d261f14edbc5bbbbc9d6435807ac5be664154ea784ac5b76e58f4f1f12fa8a88ed0b86158c51562c441098c0b05e7c7a61ae16d204007d18e75f675475426abe3ac8d72539a33eaaf362b9811517520ed706d1e9dea5f20896cfa422e4cac39be4efcbcdc50a75772efadf109b5a6eee454085259ebffa84a3e607b1c7dcafa4b0687eeb9a204e3a87db170d3ec39c3b0e2aeeb7f5aac51b03a8a3f4bdac230c969c54d69bdb4f8f5a9b1b662c8d6b027952d213e0c065fc5da48e9d7a2d84d347fc4a01f1a3c35b6f802200430245767757415c46b27a641df0e983fccc942778729235f552052691aa448fb264ebaad73b1b57b127971b8d5712b6edfe444fef81b74a326a73405d1892140947a5c2824e7ff5fb3fb30c200fdc67b59d51e6b624866607ea40d8649128265c4da4d13951e086a02e2c1af5b4e5535a77c16b61a65d523ac48a376ab266b9f563af17fe166f05cbfa54292240cff656f1afe4b795d402ec076ef51afe9781e0e98d235adbd020b767ba0f4d066b05e7f7c44cd5b84bd84cd0370efce0ba7ca1c6531ab689a805245b3673e32cc420d295f31b80632a28334c8b959b45a8f339e0002cef5e5bfac35e2aebb566612ffdf9520bb567b33ae92e2e6aae411a641e7f0b3a8f1ac2bac2fdf33b379be9e9e4264637c0de18b502f1b50998cb60f1dc3e4053fd71f8d534165f3bdaf8ebf5a5823b6b1a7abb033ed94530a3c28dc35489f151beb97e3465a7db51b6e0b48c5a6eebbd48b24648923e5082eebaa5ed0bd138b8582a6018e0583688c04d20177f418cd2476d590604ba9c30da277080b41a4bac3f80b7f4fc38474491cde863b6d727b29fc604735b143eb9120a3b1e7351319de679e15bbfd837e6aac55f51c1ded8fa6353c10a290fc14cdc01c5ad13947642725c9f245c58b8e29432bbf68cf209af7ea9959c8f90c7fe4f4d734c29ea69dabe0bbaf726e82b377d81d290d1c568831d7de5ba50187a3e2ae46e3c7a9c508544823929ae7a81f6ad0fe24da92adcd299309d1a070be049168afae2287f993049f40070fa4e9a4d98e2d4d8b1601e0b116cc3f12e483643df257ab001ae561973b7f9c52b26324be41bab110b6104b4deb7d17df6f8b3c4bbbe048765ab81418d43f37d9e0b14842561487b09af84346a72e3f2fe03e5074e612fe8a247aa8593c713b8e3a47a04c62d7e2ba46feaf947e83ae2c944f111ddd1692e4185a705b2db6d8e7adb0370e5286a38a838c881a4923bc1d792fbb5e6914e0f3aae706b797d9a21df84288500f56cc8c63ea66aec0b58b0f01401b8be6d00338c56d24b926d7ec1ac63f1608e477b631ebe69d68af6d85e1f95b57ffc411771b9c03eba24287fc82997e165af4eec90aba2255cae23aa44b436fbadbbb710574ffee5e6e530217e02fb6c8e54e758917f764a862806bdb029bc40ccfe43299334e6d6eb91200b8e190194017420bc6cac24e4afb7eac748c19725fef47f6c60147af46884ebb122f1b10c99afb5e17381f06e239fbc83387f3a7db8b3e7c3899d690f016fb619375adc545f8837a0f9ef1447d0c503450bad4b6263c1067a164937d58d16ec275cc82ff9ee548d6c713fc438112058e81e4a17d0ede05c52f77df67a743d714900bd8542952ea774d92d2e540af91fa551eb980157254e34d2fb1ee3ff265157eaf2427c84f4667ad38decd4e7c678ff0737a1dc5a4e13a94cedf6c6b72381eac2a48a3984824018120960f59886e2b6af1658c47cf5161c6319bb257fed50d1bc70afa9cc2a64f1f4ef0f80e66f42e4a124c3cb4a98359d3ce878feed705b2503849d4248758984af06b6439a5c702e32ac088b23ca12448ac93e0da8f92fd74d908216d698cb58ad95d322928f7b1d16bdc644833c76b1dba0b618ae273f621c005dc80ceb1779e95d078620534991b5bfbbc68a90b11f2c925a6a148f3efc135819a07cd9df0f2b390611117b43f28351a2ece4b19ffca1ef18696a17e448bd4123f8dd86cba3587f485ad1842218647d03bd3270dd3b11afa77e879ed089b12ab9dfd888ca0e752eb2a7ffbfdc2bd30ed5a648510b7e61958ed9422092e97269f22f4f58c967cc5d4d4578bbb8bb7d9aab7a97b40a06d8998d9cfc4aea33b0fb4adf34e66a9a94cf0b76a61155e65f608a2b9a73fad09b1ecdfd86be2390647ff2d2d6b155aec328fae4b3a628da775a1b2dd47de38c1559ee19a32f6c9ce468eedad7f71baeb81cb504738abb19a3467ed1a123ac0b6c66312220b9c3d26a8f362f3369a09dd814082da3e58636a4a66df11daeef88ffdd78fc81aadfe75933f022df1c92dd98c5c8f37ef38e3768a989f9bfe0ab1a78c14e3c30c0f23f0157f994b34a6de222b8851b226ae87b68a6e9dcb2a90703e6923626ae122d1efbc99ca0daac489d2f9ed6fbb4d3da3b658b3cb77ca4608428012357b6cf726ff0c921d4450ad91cb699c0da95ac12e0f82786f53fa880a6268a994506408b6f9f7b2602a61d343fb6cb96738b1bec89b0f67f241afae1630a5cf20255bae85080ab5c65905cd19139d41c70fb42b0676d63a552cd52c8c83cb78514070909b0d834dbea9ec7542bd1ff0a8b70e740889239b41c74f4cf3b46120f164e9b942669ffcd708cb9802ebbe524b7e35924f4df5a66e0f04ea6449ca5889c93e95cf7c0d0751680f334b5c3805c375d73e4904c2e7b926f659942e0f42c7c5ba30a4342a648adb415bdfa4deed5675ecdaef5ed7b16dda341631b4e4b0a839956ce3bdc382312d53282fd995fa5175b8c986cd80a46808194eb9212ffe35f23fd74ac09b3b8319d405070d3a0fe057d7081483548a9e301ef4f696d1b1867ed8af9a82b104a660f9725051b15e799ad85e090dd4a5de5f1687028e3e435ad7108e4cdf5a02ab02fb8153bb8502a5c9f1b4baa9582a101ff4115d757084c186b672c451436f8067e233f1a263d5371c2f958da7cadfaf6651c912e1e5072f04ba291fd2c2d8862c3efc9ca0166080f7b7479100ab3de7e2ffb82c03454d2d61bbf4f373f1fbb4a556487cf42be5f68a3e8109fb09076e4c94055f81d55913fc397c7c7ddecb85cf6337947261a65f9ef0da68d1568c7f3c544b77bf3b1f95344e01204ef334e101e84e6ac7c66187359a938b17d816fc4dbaf8e0b653a4f5861cd85520dff01350f2ffba196fddba5444bbcef4b10e957c87d31574b8b6da6b11a37768ac7ec517e6629bce058a359e24f517f01770470b15dd47a6eae6e9238ec7820baeb198450090cf0d120119115514cbc01518e77fafcf77f3ad8193c6cc632b27ab12da9cd0aff7602bc45ca5fd3260906303fef384261abb291f8d10590b0e0eeb5740702e9948514df860931f79a97d92374fad532c0a959d963d6c64d49e4d62561b3b4d33ef3a0dde6db0ae9882b2a8071d1b12143a1386ac58cb6b63e720e1e8745c4b9a20afe2996667cc4a8ded64aea35193edd94c4291f981011bf0cbfa8a870601ab7369d24eb42648cbee371713840a2cbfd64e320ab660d1a77fe323582ef777b191bedbef7d558773bb309e1df14e2d18227688caebf83df8a67674eda7396703a3c200cdc5b4a85435f6fea6292f2db2db77e9e5b237f85130aaf7ab15479ba31bac03c2ad7d252282b688a1af1195942059cb9d95509c03f8b21e419c046975dbc517c817ed872ef0110e7d761bb147db4d48a884347a95f334eb333c5d68fa4172042d26049003873d5c9083651d4b40c2f9806acafaa324e274fa14b86e1ef0ea42446845fffee618f0488b2d39ad4de0a79cd7f12c1cd325fb0c4c4acbbef540db594a6fc3a27242be2c809577bc3fa3296be40a2bf85a1d67f1a19eaff1079d9d5c4e95c3774f62e01490a0013d0e6e6a39232ee2e3e2841d043747487820728e56bf90821658f31acd9bde991fa9f8ca558daff0336628a319aa8950e8efe22e9ea80fbf439b415ca0e5fd263e75522e72d6ff0df37a083f4f61110d91993714e0062f96913e73616755846ce6808ad71560ad1de1154eb8a0a0979aba2a436d758bca23053761807f3fe37ea090fb99f3609d959e01bef5a9e664d28d212b5fafeec9068ad38431c9577a0b87ccb14fb621c751862b8fa53286b8b264819ab2b6e891af65259753f3dea665fe64552bcffbbd1bc3caaab9931555bcfd549c63595fe56d5ef5de6fd05f8f89e7af4ac7e6ff91952905111b08899e16077456c2415dd9ac6dba466965310fcbda601206d3bd1c22a85b315287b71c65c3e510a0cbb7a4e7d81334ee9d6eed85a0bbf1b5cae8488ec59fa105cdafc513b4f514f7cb5a0601a0ce3ac3222afb80e2c7405e34a223b4f21adcad7f1052c7f2df06fc5f5a4177e570a66fcd28d3a9726d00cb6d4796226b35c3c01e04623dc87034a44eb735363009883060e73a1745af7291160d88b9c05d7db791dfb52bbca190fd2fc68e2ccf97729b43f0a467b83c35af28733a49c906452855c0cbb811563cc24c2c3230fbe4b1209ab9ec60254ed52781327d4eb56e97d6ce5bad132c129a70a8b5fb724d7d58639fc8a94953eb7efa766b0ed478f8c6242bde83970c600d5c389f1fada2e3268c0540705f354ecc6f421b1f0973f64ba3bdda1bd2edaa74c52f07a7118e5b69388cdbbfe0a635da9ea24ed82de30d1295c03ca44fc91b2ed6782049942fb1752a7112934d61408fb07fbb8bd8a84d0763f14084273289a5787913b447d2aebcdf3b7d374786e50bd7964d51303f63332a7e49cf361b38008e811facfc7041871b228b39239012a9d6faaa78d2d212e1548205b2cc3ac9a2cc439dd0d15770570fa0d17a92a3715125dbda0f3bf55cbc50f1bb5b6d500017aa3c1b966b0b8422e3ccac7ab1e82e20cfdcf5405512f2015ab992cf5be9cfae79efdb52cf79ea9198bffd5d92ae47dd24af858a213ceaf77c8463fec76cf0794497229c80f01eecfc738c500a7a29f6373df5b14f61d7878d7d6b01d3b46bb37ec16852aeaba1d28b6c1e8167390727e2ce0abd8c17046dbc0d9ccd5ef64fe9e6faa6cc018ab8168bbde2c378171bbf50109a9442f03fb225c53f29290c500df28cf16180902785886aea17fc8b18368964b03c423537be581f67cf884657b4d5f5fb8686920f418603e1fb63bf7e257ceea1d547aae5b6189a69c2e2ba96b9cad15c19e00681a00a5ff59f6f37716f822294d6e9cd31c23fc66685e24c395ffb9c2b24073c6f525259bb1883684f0ce23300eb0b853aa0b1b630b61b912291b473ef198f1ac33088cab81f01f41528ba3c607eea2d5822e4df7083454e9024f1971b1bde21e51f9c0a67cad15fd77973a35a70efd518417b65c7d38e6e39b5fde1efbe6c76f32a0ec557dff66a313881345d98d98f9badec10188cdc07536b9a6ec637e2992980d59035b19948e5042683cb8e4373028d6bac242a0db523f7671881c622fba09a9b3010008385c09958894fdaec80387d690b9d4e4554c56bf86c7300fe248607e8e8e964b8651fc733c3d21076e3fbd4e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这是我这周星期四的一个小小的随笔。如果你现在的精神状态非常不好，去窗边看看风景，出门散散步，与朋友谈谈心，最重要的是要相信未来。我在这里与君共勉~</summary>
    
    
    
    <category term="关于我的琐碎小事" scheme="http://blog.eltaos.top/categories/%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84%E7%90%90%E7%A2%8E%E5%B0%8F%E4%BA%8B/"/>
    
    
    <category term="学习" scheme="http://blog.eltaos.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="随笔" scheme="http://blog.eltaos.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>步入初三下的感想</title>
    <link href="http://blog.eltaos.top/2023/16/"/>
    <id>http://blog.eltaos.top/2023/16/</id>
    <published>2023-02-12T03:47:45.000Z</published>
    <updated>2023-09-27T02:32:48.879Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="b1b1c23c46ab83f34b623adda6783e03dd4feb82d54e68c62b4ab560c5a9c8f8">eb0c39d974ec344f2c390a7d4fcbdea8173e26188b68e655aef7493d45ee144509e446c5c6f3b7ece2ff971ed9bef949d6cbde0910c759585438131bf2d5efe75cda71d47a678426658277dfbc52294ce1fb8c861f599430bc838772ce187cd83f2fc110f9ffbe323961be764f8926d837cae0892aced3a612ba991c30a655c14fbc41706ffe6f03d71ca640ce3abc55d3f7ddc020381c9d9c30eff478f9a629e020a14c9ab0b4613afb588750b9576c8704e06ba2dd37b47ed4e88dc554f1d789a25e2f81091ea662ecc4c7286e13598d1fcd3f3275acfbcb8c23ce0216957faa3b1ae8066cce1d3c6a0528fbb7a0ecad5d80d75967a2a22f95094a43e9643a99cf18a7bc4832971727e5fd75399f34e0930a52666e1ba667c7986eecfa3858faca43a9942178ebd0d753206c4c25b43ad533f64b2dd7018a48750e8eecda3d714a93c3c64d784928e4d3ae59b2663cdf8c520daa272f268b3c979026597b74bae80d3a5505375e09fc985e5547714bdd933e29e3483b3fdbb970e6d576e6728b126b943175e4eac3698c84c5a4075e633fca34928dc826a60aede025a2cf2af7862e6d0a661069653c0270ee336ee7cfd9e2ae209e00f404da71c650157bebf09d6e87c368cab605dfbdbbe19b51e83f5b6684e27ddb3be2540d7f78e0191a5a8c7e06cc4fe302c967b7b9002408164d9a7ba3ec06f7759715f73b0243aa7388938039c7bfcd07f0d523c08a4301ed1999ab52c59fe04269dec68a8288d3eed7fb84d1c97a495eff8427af6a5573cdb6ebe6151f2868b01aa73db021595fe089e896474d8e3c48c81bc5258f30021d359b88dd8a5a4bd1976ee50cebf8414c13fd20315279f2e6cc86207424cf5ee1cf6dbda77a6d2f37a8c198b9aa577398668130289b70f9e7fcd37881ab9d044c155045857ad9cee15010d9b21a13ac405d55b04abd3751bd5486959f34b7fe5d217081adddd83cb8fcce5dab5506c78101acd2b66e957d6fe93291be2beb62babc3f89ca38f3f5d8eeefd94cd9d10b8c2c81651ba4241a24e3bd2999d44b280f3bb6a91845338443909f8574b959da00872b6afe416a46a50a708e46b03e4e13cb178657382ec1368186f746a929f4872d8927cb815e9bb9aae19017c61090ba25d2cb30d4f82e184f834139e593309f4f0b70d014beb765f4cb65514604a0a7d74c9254e97c6e3417087d8ef114fddd0fe35ff00775db999fafb437daeeefda7d467f6f0fd3b82c85cd832ec0754189d712a7447935f9be4fe1c379bab53014613c4538b9ddf64aaaa26cf726c9b1ad10bf9e953485ac6c74debe650a06c1f0d0f3e57543868eadeb70ebdee865b8ee5a365267f992c9b36d49b07070bd416b93f23ccddf671169b9a1fad1358c7fc8446152b3598398750a0b5208dc0040058ce85d77914328e5c670158c18a2412eee036f07635aefbe2d8236f28266b9b1502b8b9470268f3dfc57d00a74a1b2f95b5915a3de96faa5433b4b173086608243df0e99b272b4196985732eaaa6d018de87b0ea33582cc514562769dabf5da77815768f0dafdc2da7f4a6420e1077fc4c97dd97756ed8691723b26519a4ce243477d36a3edb42a2dc3e98a9f9563cfa0f03c225a0e558852f0f91f983bcf67eba054339b1d24c47d7bf1b95a5e5f992a65100b18fa542bbd37f13917a10391fc66b47f046e022d872049e4899771910cb7e23ab39d08a0b2ae87fc9870e027104b0f94b8e18ea8f41c58f081c6b0e9c320a1b67ebfb0f35bce303c9f49aed4a167764dbbf75eeda31eb995b711802c248822cdd25459cfb2e3665f5cd1e9774cb8ebdd80d019688107c83398100541b6ace4c9c03b8dba8caf537b169671ce3c8c4138e3d60f87c98fe1b44ff5ce6c06ab4d20a01cc1bd3f11f3b72a548d1d91cd2eb256e40aa19be6a4f338ce608d696f7b14ea25e6b8d7206faf7675e11be21a254723ea3842bc64bc0f3760b00cc8b504b5b68c0c210af3d8c9252de53fb95903ed6c0247a3f9f6a8701156c73b309d8d5e27a22d0f4c7523f2c6c828253bcbcbebb427984492135cef79ac1b448fc2fa74295f0200b1cc5e07563aed01e22d236d81093d24269f75d6419c6a6910d082d9bf589f9541b5ffad39bade8ef0b815f40ae2ac241cccac3b9bf4966be10d573e909b0e922acfd138085462fa6694419408651592c4029b98a1bf9383dab90728c9a0ddbd9fbdbdeb7857d408d7517c1abd41a6ca6a84718b77f3614a4d2405f6b2868a9fe3ff7b1b6b89eadc246d32b9ad87d831a9c518aaac384a7bfd8320b4e22aa08262c29fce8d9a10a28f2841df73db164aba4c60eb1573aeb2ca5de510d2e8c77088988457ea504e9e16e70542d0cbd388e47685de145c44e416f8bf2453095b66e18aa87464d55c98e5f194ce73a0976126b234752aaea96431ef38eccce2685c9148933d21e6ea288f4bec085b7c9c08a58eaa73f004e0ef13cb84e4024cc082062d5d903185411dbb781fb8ef308e4f62fa0181f328d5cf889f428b2d6a59e47d44fc40243cb6b1068c0cefae2f0fe657f01c1084a2907f07fcc8984c931269ec6bca9d3f79e31bae3832e397b30a936fb075d8d956a6b12f183dd111580249306c76158c99df36f4ca4c325b7d5965c59a8a409e04ec219c737cdba82c422673436059a5d0c46fcf867800678f19b3f9be999268378852d048d3689e718d7378c46c03be348c5688b35a00c230bdef040d78ef2cf33cd4580b83c441cb19ffdc2f1bf3bda0f222bded8dfd8a11576d04d4070da8a204666d58970c475e6c415efe836ea3c655a9f20a965f06351ca9d512937589b27c4e2b743d16588ab763a76685e6fbdb2ab408ce777d9bfb6da10d051f50229d1ee5f793566fd0949d0cd3c58ad1abf2a74d3b653697f19a8385bc9fa9dffcb5ecd60c394879b92badba0d53f3c2a4e6ba34bad8feb9fc8afda8935fac1139ff97403c3070853ce3f418ddce8bc13be49b0dd0cd89295817c8abba3e5311abd3e8a314a316790dfc4dedff23c39bd96450b11d3189bd022531c0f05c4f2b4765e35f5d74ad167b047cd96a9b5b98094da241c21921376e7df33983eda9e59d17f5d1f9f8beb4e6ce72f397a7a5d585649ad7b24109d6d1fce0ecccbec74295d309ff525e58bddc11b8b7a4fc1ef8f47bbe9de1c3d2be49333a5748ce4abc7afb66d6d4dbad092326dcb705d33dd9896cb24c55e5e2fc7d8e3e23b98e26775ad561297c793747d17c7143667988bf582c3b389388d2531f4b9d1d4512395b03fcf9e97c67261d0401c63a29f6a37f137a3f9a3bb14d3d01093858b755fe78d7bcafcd081121b0a684f012b1150dd446c2375c6dffbfc3bae117d27d2b257b0141bf571c287297857b823abc4fc58cf7ab3626f223afa0b6f045d3cfc374ee3315810c6b69538e676e483af6c32fd09fc35d52bcb7ff2e29ad67b850a1717d69142f579ef8e5090dfdfc1a5396a8259256cc6605e22fb7ed6285c7d6d45e63527a65964832301f6902d66157adef89d63b4e0ddbe70826ea23fdaf500523cef64a749001eb5d32167f9218e03eeb4bcc9e912cbf37c6d5411a929100c030c89aa7977e8aa477a95544e0a7a43498072e17966a8</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="关于我的琐碎小事" scheme="http://blog.eltaos.top/categories/%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84%E7%90%90%E7%A2%8E%E5%B0%8F%E4%BA%8B/"/>
    
    
    <category term="学习" scheme="http://blog.eltaos.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>RGB常用颜色对照表</title>
    <link href="http://blog.eltaos.top/2023/15/"/>
    <id>http://blog.eltaos.top/2023/15/</id>
    <published>2023-02-01T00:51:21.000Z</published>
    <updated>2023-02-01T03:00:58.018Z</updated>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>RGB颜色是网页常用的一种颜色表示法，但是常用颜色的代码千奇百怪。下面整理了一常用颜色的代码值。</p><h1>使用方法</h1><p>以下代码仅适用于html文档。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> </span><br><span class="line">这里是非颜色文字 </span><br><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&quot;%该颜色代码值%&quot;</span>&gt;</span> 这里是带颜色的文字 <span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h1>常用颜色代码值</h1><p>注：以下说明顺序：名称，代码，效果（部分颜色在暗色主题下显示不清，可将主题颜色调为亮色食用）</p><ul class="lvl-0"><li class="lvl-2"><p>黑色 #000000 <font color="#000000">黑色</font></p></li><li class="lvl-2"><p>红色 #FF0000 <font color="#FF0000">红色</font></p></li><li class="lvl-2"><p>白色 #FFFFFF <font color="#FFFFFF">白色</font></p></li><li class="lvl-2"><p>灰色 #CCCCCC <font color="#CCCCCC">灰色</font></p></li><li class="lvl-2"><p>黄色 #FFFF00 <font color="#FFFF00">黄色</font></p></li><li class="lvl-2"><p>紫红 #FF00FF <font color="#FF00FF">紫红</font></p></li><li class="lvl-2"><p>绿色 #00FF00 <font color="#00FF00">绿色</font></p></li><li class="lvl-2"><p>青色 #00FFFF <font color="#00FFFF">青色</font></p></li><li class="lvl-2"><p>蓝色 #0000FF <font color="#0000FF">蓝色</font></p></li><li class="lvl-2"><p>橙色 #FF7F00或#FF8000 <font color="#FF7F00">橙色</font></p></li><li class="lvl-2"><p>浅橙 #FFCC00 <font color="#FFCC00">浅橙</font></p></li></ul><p>以下是其他常用颜色的值：</p><p><a href="https://imgse.com/i/pSBKcDO"><img src="https://s1.ax1x.com/2023/02/01/pSBKcDO.png" alt="pSBKcDO.png"></a></p><p>当然，这并不是全部，你可以通过<a href="https://www.colorhexa.com/">www.colorhexa.com</a>找出（或调配出）你想要的颜色。</p>]]></content>
    
    
    <summary type="html">RGB颜色是网页常用的一种颜色表示法，但是常用颜色的代码千奇百怪。这篇博客整理了常用颜色的代码值，让网页颜色撰写不再困难。</summary>
    
    
    
    <category term="html" scheme="http://blog.eltaos.top/categories/html/"/>
    
    
    <category term="网站" scheme="http://blog.eltaos.top/tags/%E7%BD%91%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>更新说明&amp;预告</title>
    <link href="http://blog.eltaos.top/2023/14/"/>
    <id>http://blog.eltaos.top/2023/14/</id>
    <published>2023-01-28T14:59:52.000Z</published>
    <updated>2023-04-16T02:46:06.243Z</updated>
    
    <content type="html"><![CDATA[<h1>预计网站会更新的</h1><ul class="lvl-0"><li class="lvl-2">更改一切相关域名</li></ul><h1>预计要写的</h1><ul class="lvl-0"><li class="lvl-2"><p>Markdown语法汇总</p></li></ul><h1>更新内容</h1><p>注：该板块从2023/2/1开始统计。</p><p>2023/4/16：四月天</p><p>2023/2/12：步入初三下的感想</p><p>2023/2/1：随笔，RGB常用颜色对照表</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;预计网站会更新的&lt;/h1&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;更改一切相关域名&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;预计要写的&lt;/h1&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;Markdown语</summary>
      
    
    
    
    <category term="网站公告" scheme="http://blog.eltaos.top/categories/%E7%BD%91%E7%AB%99%E5%85%AC%E5%91%8A/"/>
    
    
  </entry>
  
  <entry>
    <title>随笔</title>
    <link href="http://blog.eltaos.top/2022/13/"/>
    <id>http://blog.eltaos.top/2022/13/</id>
    <published>2022-12-31T00:36:41.000Z</published>
    <updated>2023-04-02T04:50:57.618Z</updated>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>作为一个学生，总有一些事，居于学习之上，却又被我们忽略了吧…</p><h1>2022/12/31</h1><h2 id="前言">前言</h2><p>今天跨年了，希望一诊后的我们成绩突飞猛进！</p><h2 id="感受">感受</h2><p>每次相遇，必然有它存在的意义，毕竟，下一次相遇的时间，还是未定的。</p><h2 id="正文">正文</h2><p>“…好，这周就做这些，快走吧！”β的声音终于消逝了，他盯着身旁的几个硕大的背包，心中升起一丝怨恨。</p><p>他背起书包，提起口袋；他承受的重量令人生畏，在回家的路上，总使身旁的人惊讶万分。</p><p>走过人流密集区后，他想起了自己糟糕的成绩，心想自己又要与老师“促膝长谈”，自己的时间又要被老师的“提升建议”占用。冥冥之中，他觉得自己承受的重量变大了。</p><p>走进小区门，他遇见了一个同班同学。他艰难地走过去，想要对他诉说自己所处的成绩差的境况。但是很不巧，那位同学考得很好，仿佛他就是年级第一似的，一讲到关于成绩的话题，他就得意得变得目中无人。想到自己的糟糕成绩，无法超越其他人，他感到自己背上的包袱再次变重了。</p><p>在小区中穿行的过程中，他看见了几个无忧无虑玩耍嬉戏的小孩，他们在滑滑梯上打闹，拿着各种道具争斗，叫着各种名字玩乐…想到自己尚未完成，或者说拖了很久的作业，他感到自己全身火辣辣的疼，承重已经快要超过自己的承受极限了…</p><p>终于要走到家门口了，望着远在天边，又近在眼前的家门，他突然想到父母听到自己的糟糕反馈，会有多感慨，多失望，多愤怒。他身上的重量再次增加，撑破了他的底线，他就这样被压垮了，在自己家门口被压垮了。</p><p>这就是一个学生因周围的压力而崩溃的经历。</p><h1>2023/1/7</h1><h2 id="前言-2">前言</h2><p>一诊即将到来，希望我们都能在一诊中取得好成绩！</p><h2 id="感受-2">感受</h2><p>就算是离你很近的地方，你也可能对它的沧桑巨变一无所知。</p><h2 id="正文-2">正文</h2><p>好久没吃米线了。</p><p>还记得儿时，我去上XES的课外班。一下课，我总会到那家抄手店去吃一碗米线。老板身手敏捷，将米线随铁纱筐一起放入锅中水煮，捞起后又行云流水一般配好佐料，一起放到碗中，端到我面前。碗中热气腾腾，米线如海浪一般汹涌，佐料就如海中游鱼。一口下肚，米香直冲味蕾，和着葱，辣椒，让人神清气爽。它消除了我上课时的紧张，卷走了我的学习压力；仿佛就只有这一刻，是在学习之余，享受生活的。</p><p>但是，我不久后转班了，离开了那个校区，也就吃不到那碗热气升腾的米线了。</p><p>升入初中，在饮食方面，我印象最深的是那碗牛肉面。那碗面，夹杂着食堂叔叔阿姨的热情，饱含着学校对我们的期待之情，承载着我们对未来的向往。但是，我总看不惯它细小却污浊的身躯，丝毫不像米线那样出淤泥而不染。</p><p>由此我联想到我的成长，我从一个单纯，透明的懵懂小孩变成了一个心灵充实，思想浑浊的中学青年；就如这面与米线一样。米线承载着我的过去，而面承载着我的现在与未来。其实面也是由植株做成的，只不过米线制作简单，面制作复杂罢了…</p><p>所以，几年后又经成长的我，又会像面变成什么呢？</p><h1>2023/1/16</h1><h2 id="感受-3">感受</h2><p>当你完成一个让你历经挫折的事时，也许，这件事就不会再次发生了…</p><h1>2023/2/1</h1><h2 id="感受-4">感受</h2><p>有些事，在心中憋闷久了，总会抒发出来的。</p><h1>2023/4/2</h1><h2 id="前言-3">前言</h2><p>好久不更新了。</p><p>昨天有些事发生，导致原本开开心心的我差点崩溃，第二天我很快就恢复了（八成是因为作业写不完了），这里就不赘述了。</p><p>以下，是名为“内卷”的一篇随笔，但由于作业写不完了，我就只把结尾放送了，剩余的之后再放送吧。</p><h2 id="感受-5">感受</h2><p>生活中的一种种颜色</p><p>都 是 假 的</p><h2 id="正文-3">正文</h2><p>又要谈到往昔了。几个月前（），我和同学们拜读了一篇往届毕业生对我们学校的评价。同学们都关注的是那些优雅却又风俗的有趣文字，我却关注的是这篇评价的结尾，他是这样写的——</p><p>“感激你，你将我送上了更高级的平台，使我日后能够大展身手。</p><p>不怀念你，转身收拾了剩下的事物，竟发现除那以外，便一无所有。”</p><p>怀念是一定要怀念的，但是怀念的是那时的人与生活，还是只有那时的人，就因卷而异了，我心想。</p>]]></content>
    
    
    <summary type="html">作为一个学生，总有一些事，居于学习之上，却又被我们忽略了吧......</summary>
    
    
    
    <category term="关于我的琐碎小事" scheme="http://blog.eltaos.top/categories/%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84%E7%90%90%E7%A2%8E%E5%B0%8F%E4%BA%8B/"/>
    
    
    <category term="随笔" scheme="http://blog.eltaos.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>关于我对异性感情的思考</title>
    <link href="http://blog.eltaos.top/2022/12/"/>
    <id>http://blog.eltaos.top/2022/12/</id>
    <published>2022-12-24T00:44:44.000Z</published>
    <updated>2020-01-19T07:16:35.820Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="8a53d3e31419a207e5157616b5b938fb8999d16f1504372bc196d53c2d280f26">5fb68be3ed78271bfb95c0e1cce6382e2d0b18c7b2b8f624d45c458a622151268208601131f40c1ecc570f4378429ff51034f98f013e6951f7a679ea9f48eb6444ea81dae97dd342b3563fdb51802c5bab49aad0b3f6f43786627c3f6c30c0355568733df8aa96ef50d28f33ee3587d1a823c53356d875adb55010522ec1101d8570ff42264801c063ae41bce59bc27a7a9d181e76f31072d7fd054f41c68055e87e422eac4ddcfc371c86947f38bfd64745fb21777fbc397b81bde0ad38b0331b67093ff7e98ebd7feb42fe505afa41d656750e33a1694560c5ce57c9dd4ddba55ebe31deee7ef89bc6a191e05a2cae52761c5bffc20e217b420d02e9764f8e5feedef7dcb395c1b02effd29cafa85a07cdca4547fcdba165cda072c098caac1735eb4dd20e4123776e294220e18690893b2bb1a664829619e81cc5844c057c2d717cb404bfda0e884a860d0133aa222deb9fe59672ed37c9b6d803a7d4bf5181fd1125c35599c1046eced75fe752f007d131d8ecd694fe84673db85437adf7e06e98ab1b4ab9c79e6eb72d86796928ca0c735eaea8c2f354a597908d4bb49d1ab91d885e235d7d2c9e8175fb8300c96af358cff3d9e65440e16ae1857b08a1ed3f76f22dcd688dbebac80a979330cb6154d3a66e89a61bc4ded42f4d3eb5a3a74352b6eeacdbcc6e787daa94ca5a2a37ada1638137ad4998649c18b4a8ecf7272507b70244c9f09f84760866bdbb1d7c62754f0df92d02e186e875f15c424a55492eba913daacdbab193e94ee2d1288ba1b9479a01e2fd3fbe038cac37b047c93f38434b68f38d4d71081120b20393f7327eb9e5096869631b19b4d48e15366fad27f3dd6755a81aead3c03540a37b4fde8c404ecc62bb29e5dec263e688f83198e30c8b2f4c4971fe1acd247a4d5f964871cd4076672172c903550f4c0e10a20bc3cff6e7284e753837a2b590cb84ab9a2960e87859f027136af48a71b4667172033c6ed0534746f69e9c530e0343c79a25a39ede9438c21125cf9302e22ed3f7db65186ae486095f29ae1891b6e973c0e6db6e2a125fda5c50ded8054a7943ca714fc3600abda2bd1ba0e85fa6d0e1635e5e447f5082781cfdba4a192bfdc850b115fb2da2242216e7b43e15275c9965ed99bfbcaed984156f42c389263794437e7a523274974fa7902a406b1a90d19a6dfe789fbaa8a000b53645f1b3d6690cab1d3361b3deac8e8552f93873a6eb133241e74484125ca8c0a724b25d66a209e223f2aea7f6400bb49f3e5cedb33f264ee1217013d316a2d20f83b4794a59ecdd4557f1ff77230941836739cf6b8197a756cffa12ce8c1123686301aa29b6bfc27ea977053938ba98ef106160b1603b09ffebb41d941d37533527f7aa24e72c926349e965b718decde84374b65780772a410aa79d540a47fef228d85fb9eba824c8a0e4f27f2b02e3be1d64bbc96920174d22e382609b0f782eccec8aef00e5147445fd38df557eb3da6784a2d8c2d0447d1d2968bc967c918d655bc843be183109c6fe002e8d78268aecf5fa5ae23172c39b8dfaa78c146973443a47a345aaab54395dc525b303a2a247b2a431faf7ee84a2988d519751173e6750a0282f85e479518859725a31b1ebb962e1a9e09fe5502485c56a7acbcf29895d451d1f8973b17a63aeda762211154341ef0917220ef40dc234dd67ffd160f38b291521f67b956c5aaa1c0820f61a701cb9931709ecfada442dc7561ca7c6b497a2b5c60caf52cd6172da1d086a895f1c93d342f40e06ba35ef2ea33352ca39433b383508f30b456880d6e18bb01944897245d2a39d971a34c8718e093e05987897c2d421f4b6080289a13172faaedb5905add0d6a33bc136484e4e24b1f8e86c934de863362924ebb7031e2d008c04a2090f42c81b38707666572556be7e21fdf75da8c41abd433abbfe2b2def659f96a6c15b49e32206b9211b399f4c78d96b55a8b6058617906b8c300f91233d067e84c5db4b041059c24afbde25cafe12d09f43e9b55b073d0dd47b9a6a44800c8fd941d30f4db49902fcb1d2680c814cc53dcb68046e07f1dff1298226376253db8132278db7b9844e905a1bf551210e1b042465d79bcd67c40a5f2dd892fc67cc6101cf05251b205699311ba1fd7914efc55358b84316b54fdbc9686874bb7607f23650c70c48ac30b6a0fc5413d3fda265169f45a532f42dee5d0c09e7a94fc24c2169ad044e81912391cf120a3d1a0413651b2ea07bd4aa60f202162e55a7022d01d77d7167f04532cf3bfe09e44705e054a9101da926c607009c9e01c0c36254c1f3ecda7b512877b47c94c8bd901c51564e1d5ca7a2e94230752da00836ac37fe61f5026a6fbf2a3b36e7509f62eeba4a99aa59faa36f7fa5d975b8f3f9877a8e194d43d47c92aa772e0bcd3a26824b4a87e7a98a86b986bc067b0a83e04accf83ee6a19b2d61e41901a08ad446ceb516b2ef6a56f9f386442e6a41b98627b3f62a6d0eb7bd0ab9ff635071f620be7167ad62e526bae6848157b48f8422557888c69b4582fc9767a365804771f9300bb2e373abe22fd74389c2f61b57fd0e448e548f2c6288a640b509fb18525c99642addb21b72cf4cd4f991da20dffd4e503dbd59a2fd08806cd15e455431fd70f670a26934396124f8ea2a10578447bf37911311fdbe9a7c58f1236af489872f75844e83f14f6abf03b5a73b9ffb52fb98e948ea5b7573287bd1593ee4e2612360e8356a0673584bc49f83c9362410db8eeb7c67cd458454df7a7bbdf98ec316c73166069545baf3ff13dcf181961e8a9eea3d2eeeb3b9c111004e4978fd4dd175b626802e72394fa4a7b6139109ee869130cf8502c872d4e8a14787cb3790a6782a73637953f758bbabd1c6473b6c161a8d7ea2e7b50e6e4e019e1923ea8e933952ac24912e7584286b1e5256273fe90e5a7390075930c3d568d24e9646a8659da3a8665fb34840d415261dc52dfe656c29112c3fbb6c85a3f609e4c730ed1ba63b8adf9120013a0da418b6725cb66c105958f1693d932bba103d0a2c5d8bad1ef126182d0135dee15ef406ea15b2e3dda0c2be58a714d3fe84e66cc468527492dd411c91dde7bc538c0151b0bfe897954391059c64aa1ca1d7bcab72673c50afaaaa97f4da037556712a1aed293531cb00dbcb3fb1bd0954b1c923ed7297bbfb98201ce47e392150aa37ded0b3fdbd62033b21ac20aa067aec1448cb5d4a8468dc4d05403051c0bd4822116adf07763ff7ec952f35d981b63add4bb40fe4d021d985b8698a33eb5258d57ad501f67677b8964f8d9be3f2026b22c767ac352d3f79149af568ff077e00de03f7f02c926de76ad0198b79bc1bedcf04ec668bd0a1fbcb32002b9ca7bc5218f73aabea592bb7b44f693f72553845b3afa29ad46dfda67d8d3ed43d1eeb0184a5585a0cbed13359c59bc65803fa75dd4df47b233dada0a518b7800bb41f80c5446d55a4e2aeb19bef745758183c788fea9d9a8e6ffaf7f1ae6a59261aa602dd0e81cf16c66d1b86ed379570e10b87959d1a4266dbe157014edbf8b2d1d9ae05e12aa96824f551f907611538850122f2922b710195af46d9df1196222892ca1aef7b9ae53e3382368e9d0ed0a51677d4d89eb9acdca3c0cca968b3b4674ba7bdcd1798bafc03939f62928c68f7cee91f132568500bfb8d117ec3b37c66c01715c7a439a369fac5c7b3f477a446853b7ed18c9170237656ea8a953569252a41255272342b6e16ca2dd9194c1ffc4daf137e477c1fd54414540b4244056dce063bef093beed506f07f31b2529ea4af9b3d1f93165a6fcb954bd678530d6c67de237277c1f45c8bd77c695e15396b4dfd27192f1bbfa6b80ed06eafafb3a61ba684234dec6f49af8a70d7abe4d3807e3cd788f5f946a1b66afe64034c4ef19a2d55d7583a1116c7b949e56eb3b61d9f5f85020509d7af6c2ef626fdb2391a6d92a5b8e75463a7706bbc35c9806a76e15b9bc415e1eec2137f6d0d70f914064dd14739dcc2896d5be5a30640108f48f8744ccbcdea979ad852a8aef0ee73c08cfeca6a9fdd8480d1e1db7dd766f3e007ed47367b10f13d0799b0a2dc357a13a480a63aab0bcb969574647d1a68497b510467a56d2815fac12c64f818727e4cfb7eb4685a63b3b3564f9d716adb52b206a6b9f9057447febf4c67963e0a2b034fb2c94f974bb14a4e2ce82921a881fcac0121e6448523663c8e45935b70e303b3c2230d4ebb5c8bbef24d408afa844e9af98515c0bc6d912775a9a6c940d6927288c27d51acd1592453f71f9ec4c41d41acc760bb1aebfd44c2304e9ce8cf552e7b4d01b479201c0e31bd97cee10cb17b2cbf9b7faec8a14b2504366987fa676167bdc30a24b67d43467dca147c19c702cd639551a040d398f2c54bd612fdc4dd940d22d10b15c8954eeb585afdaedb2361453b8898d9f557655e2dad2bdbe4fc8de6cb032599860ba65c9278eeb5f5be310da9f7e0a13addcf6ef8ed4955d462f16ec5e5ae8f3e72b53da9251d81677f9bdd1bd6a2e7328580d30c00afcdedee29fe5fb3877e2b8439192133b713d414bf72c8c47e040974d6b6ff4a612a3f839d14a952a1fb34ff7a2fdff674bd14baf8219dbabedc69fbb542d8d24d1b033b4b6003a747abaf6f1465d590a494b930ef1dd2e713b84210af008c6992c6354e9aad19b2089f57578e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">最近，FCW和YKL的亿些事件，促发了一些词语或句子的产生，如：“钙W化合物”和“钙盖是W哥的，W哥是，钙盖的，谁”等。所以我写下这篇《文章》，来表达我对于这种现象的看法。</summary>
    
    
    
    <category term="我对一些事物的思考" scheme="http://blog.eltaos.top/categories/%E6%88%91%E5%AF%B9%E4%B8%80%E4%BA%9B%E4%BA%8B%E7%89%A9%E7%9A%84%E6%80%9D%E8%80%83/"/>
    
    
    <category term="感情" scheme="http://blog.eltaos.top/tags/%E6%84%9F%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>12月月考的一些感想</title>
    <link href="http://blog.eltaos.top/2022/10/"/>
    <id>http://blog.eltaos.top/2022/10/</id>
    <published>2022-11-30T14:04:07.000Z</published>
    <updated>2023-01-31T01:26:48.511Z</updated>
    
    <content type="html"><![CDATA[<h1>考试前</h1><p>咱们就直奔主题吧。</p><p>月考总是令人提心吊胆，但我已放松心态。并不是说考多好或多差不能影响我，是我已习惯了。</p><p>浅定个目标吧：</p><table>    <tbody>        <tr class="firstRow">            <td width="99" valign="top" style="word-break: break-all;">                学科            </td>            <td width="99" valign="top" style="word-break: break-all;">                语文            </td>            <td width="99" valign="top" style="word-break: break-all;">                数学            </td>            <td width="99" valign="top" style="word-break: break-all;">                英语            </td>            <td width="99" valign="top" style="word-break: break-all;">                物理            </td>            <td width="99" valign="top" style="word-break: break-all;">                化学            </td>            <td width="99" valign="top" style="word-break: break-all;">                总分            </td>        </tr>        <tr>            <td width="99" valign="top" style="word-break: break-all;">                目标年排            </td>            <td width="99" valign="top" style="word-break: break-all;">                85-            </td>            <td width="99" valign="top" style="word-break: break-all;">                10-            </td>            <td width="99" valign="top" style="word-break: break-all;">                70-            </td>            <td width="99" valign="top" style="word-break: break-all;">                30-            </td>            <td width="99" valign="top" style="word-break: break-all;">                40-            </td>            <td width="99" valign="top" style="word-break: break-all;">                30-            </td>        </tr>    </tbody></table><p>    <br/></p><p>加油！</p><p>浅浅预告一下：新的DL-Fanmade-Class11-Only有望在一诊后出！</p><p>2022.11.30</p><h1>考试结束且未出成绩</h1><p>感觉崩了，除了英语可能好一点其他都差…</p><p>估分：</p><p>语文：110</p><p>数学：134</p><p>英语：133</p><p>物理：68</p><p>化学：47</p><p>总：492</p><p>真是差到极致了！！！！！</p><p>2022.12.03</p><h1>出成绩后</h1><p>感觉这次的改的很奇怪，以下是我的数据：</p><p>总分：496；年排：19；</p><p>下次加油！</p><p>2022.12.10</p>]]></content>
    
    
    <summary type="html">月考总是令人提心吊胆，但我已放松心态。并不是说考多好或多差不能影响我，是我已习惯了。</summary>
    
    
    
    <category term="关于我的学习" scheme="http://blog.eltaos.top/categories/%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习" scheme="http://blog.eltaos.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="考试" scheme="http://blog.eltaos.top/tags/%E8%80%83%E8%AF%95/"/>
    
  </entry>
  
</feed>
